<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[洛谷P1896][SCOI2005]互不侵犯]]></title>
    <url>%2F2018%2F09%2F20%2F%5B%E6%B4%9B%E8%B0%B7P1896%5D%5BSCOI2005%5D%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AF%2F</url>
    <content type="text"><![CDATA[题目题目描述在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。 注：数据有加强（2018/4/25） 输入输出格式输入格式只有一行，包含两个数N，K （ 1 &lt;=N &lt;=9, 0 &lt;= K &lt;= N * N） 输出格式所得的方案数 输入样例13 2 输出样例116 题解建议先食用这道题这道题，其实也是一道模板题，只不过情况稍微复杂了一点，状态稍微难转移一点。 函数\变量名 作用 $f[i][j][m]$ 第$i$行，第$j$个状态，放了$m$个国王 $get_one(x)$ 返回二进制数$x$的1的个数 $can[i]$ 预处理合法状态 $num[i]$ $i$状态有多少个1 和玉米田不同的是，这里$f$的第二维是第$j$个状态而不是状态$j$ 预处理$can$以及$f[1]$：不能有相邻的国王，左移后若没有重叠则合法顺便将当前状态的第一行赋值为1 后面就和玉米田差不多了，注释里只有与玉米田不同的注释 代码12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n,k,cnt;long long f[10][1000][100];//第i行，第j个状态，放了m个国王int can[1000],num[1000];int get_one(int x)&#123; int ans=0; for(;x&gt;0;x&gt;&gt;=1)ans+=x&amp;1; return num[cnt]=ans;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;k; int top=(1&lt;&lt;n)-1; for(int i=0;i&lt;=top;i++)&#123; if(((i&lt;&lt;1)&amp;i)==0)can[++cnt]=i,f[1][cnt][get_one(i)]=1; &#125; for(int i=2;i&lt;=n;i++)&#123; for(int j=1;j&lt;=cnt;j++)&#123; int x=can[j]; for(int z=1;z&lt;=cnt;z++)&#123; int y=can[z]; if ((x&amp;y)||(x&amp;(y&lt;&lt;1))||(x&amp;(y&gt;&gt;1))) continue;//左下角和右下角都不能放 for (int l=0;l&lt;=k;l++) f[i][j][num[j]+l]+=f[i-1][z][l];//l是上个状态的国王数量，而我们找到的合法状态国王数量应该是上个国王数量加上当前状态的国王数量 &#125; &#125; &#125; long long res=0;//注意long long for (int i=1;i&lt;=cnt;i++) res+=f[n][i][k]; printf("%lld",res); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>状态压缩动规</category>
      </categories>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1879][USACO06NOV]玉米田Corn Fields]]></title>
    <url>%2F2018%2F09%2F20%2F%5B%E6%B4%9B%E8%B0%B7P1879%5D%5BUSACO06NOV%5D%E7%8E%89%E7%B1%B3%E7%94%B0Corn%20Fields%2F</url>
    <content type="text"><![CDATA[题目题目描述Farmer John has purchased a lush new rectangular pasture composed of M by N (1 ≤ M ≤ 12; 1 ≤ N ≤ 12) square parcels. He wants to grow some yummy corn for the cows on a number of squares. Regrettably, some of the squares are infertile and can’t be planted. Canny FJ knows that the cows dislike eating close to each other, so when choosing which squares to plant, he avoids choosing squares that are adjacent; no two chosen squares share an edge. He has not yet made the final choice as to which squares to plant. Being a very open-minded man, Farmer John wants to consider all possible options for how to choose the squares for planting. He is so open-minded that he considers choosing no squares as a valid option! Please help Farmer John determine the number of ways he can choose the squares to plant. 农场主John新买了一块长方形的新牧场，这块牧场被划分成M行N列(1 ≤ M ≤ 12; 1 ≤ N ≤ 12)，每一格都是一块正方形的土地。John打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。 遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是John不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。 John想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案） 输入输出格式输入格式：第一行：两个整数M和N，用空格隔开。 第2到第M+1行：每行包含N个用空格隔开的整数，描述了每块土地的状态。第i+1行描述了第i行的土地，所有整数均为0或1，是1的话，表示这块土地足够肥沃，0则表示这块土地不适合种草。 输出格式：一个整数，即牧场分配总方案数除以100,000,000的余数。 输入样例1232 31 1 10 1 0 输出样例19 题解一道状态压缩入门题，也是第一道我在不看任何题解的情况下写出来的状压dp题状压dp一般会有明显的数据范围特征，即n,m一般都在20以内 状压dp的状态设计和转移是有套路的，就拿这道题来说，$f[i][j]$表示第$i$行在状态$j$的时候的方案数，其中$j$我们用一个二进制数来表示。转移的时候只要判断与当前行和上一行是否冲突即可，如果不冲突，$f[i][j]=\sum_{z为不冲突的状态} f[i-1][z]$ $\sum_{1\le i\le cnt} f[n][i]$ 就是最后的答案（$cnt$为状态总数） 至于为什么在下面的代码里先枚举本层，在枚举上一层：因为我们动态规划是靠状态转移来实现的，上一行相当于处在i-1阶段，我们需要不断用上一个阶段来更新下一个阶段（逆推），因此本层循环在外侧。 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int mod=100000000;int f[13][5000];int ok[13];//纪录每一行输入的数据，也是用二进制保存int n,m;int can[5000],cnt;//预处理出所有合法状态int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; int a; cin&gt;&gt;a; ok[i]&lt;&lt;=1;//这里的顺序一定要注意 ok[i]|=a; &#125; &#125; int MAXN=(1&lt;&lt;m)-1;//假设m为5最大的状态显然为1 1 1 1 1 for(int i=0;i&lt;=MAXN;i++)if((i&amp;(i&lt;&lt;1))==0)can[++cnt]=i;//自己如果和自己左移重叠了，说明有相邻的，不合法，只有不重叠才合法，注意从0开始 for(int i=1;i&lt;=cnt;i++)&#123; if(can[i]&amp;(~ok[1]))continue;//第一行单独处理，~按位取反 f[1][i]=1; &#125; for(int i=2;i&lt;=n;i++)&#123; for(int j=1;j&lt;=cnt;j++)&#123;//枚举当前行 int x=can[j]; for(int z=1;z&lt;=cnt;z++)&#123;//枚举上一行 int y=can[z]; if(x&amp;y||x&amp;(~ok[i])||y&amp;(~ok[i-1]))continue; f[i][j]=(f[i][j]+f[i-1][z])%mod; &#125; &#125; &#125; int ans=0; for(int i=1;i&lt;=cnt;i++)ans=(ans+f[n][i])%mod; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>状态压缩动规</category>
      </categories>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[开学考试]最大平方数]]></title>
    <url>%2F2018%2F09%2F08%2F%5B%E5%BC%80%E5%AD%A6%E8%80%83%E8%AF%95%5D%E6%9C%80%E5%A4%A7%E5%B9%B3%E6%96%B9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目题目描述给出 $N$ ,求 $1$ 到 $N$ 个数中选出任意个数相乘能组成的最大平方数,由于此数可能很大,你只需要输出此数除 $100000007$ 的余数即可。 样例输入17 样例输出1144 样例解释$2\times 3 \times 4\times 6=144$ 数据下载由于各大oj可能没有，故在此提供测试数据 题解题目就是这么简单，然而考试并没有想到$QAQ$因为是任意个数相乘，我们可以将$N!$进行质因数分解然后因为$A^2\times B^2=(A\times B)^2$我们就可以把所有的2的整数倍次方全部乘入答案里，就是最大的平方数。 而普通的方法分解$N!$需要$O(N\sqrt{N})$的时间复杂度，我们可以考虑一种新方法。 显然，$N!$的每个质因子都不会超过$N$，我们可以先筛选出$1-N$的每个质数$p$，然后考虑阶乘中一共包含多少个质因子$p$ $N!$中质因子$p$的个数就等于$1-N$每个数包含的质因子$p$的个数之和。在$1-N$中，$p$的倍数，即至少包含1个质因子$p$的显然有$\lfloor N/p \rfloor$个。而$p^2$的倍数，即至少包含2个质因子$p$的有$\lfloor N/p^2 \rfloor$个。不过其中的一个质因子已经在$\lfloor N/p \rfloor$中统计过，所以只需要再统计第2个质因子，即累加上$\lfloor N/p^2 \rfloor$，而不是$2\times \lfloor N/p^2 \rfloor$ 综上所述，$N!$中质因子$p$的个数为： $$ \left\lfloor \dfrac{N}{P} \right\rfloor+\left\lfloor \dfrac{N}{P^2} \right\rfloor+\left\lfloor \dfrac{N}{P^3} \right\rfloor+\dots+\left\lfloor \frac{N}{P^{\lfloor log_p N \rfloor}} \right\rfloor=\sum_{p^k\le N}\left\lfloor \dfrac{N}{P^k} \right\rfloor $$ 上面的计算只需要$O(logN)$的时间整个过程只需要$O(NlogN)$的时间 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int mod=100000007;int n,ans=1;bool v[10000010];vector&lt;int&gt; prime;void get_prime(int n)&#123; for(int i=2;i&lt;=n;i++)&#123; if(v[i])continue; prime.push_back(i); for(int j=i;j&lt;=n/i;j++)v[i*j]=1; &#125;&#125;int main()&#123; cin&gt;&gt;n; get_prime(n); for(int i=0;i&lt;prime.size();i++)&#123; int p=prime[i],c=0; for(int j=n;j;j/=p)c+=j/p; if(c==0)continue; if(c&amp;1)&#123; for(int i=1;i&lt;c;i++)ans=(long long)ans*p%mod;//这里要么取两次mod，要么用long long，后者快一点，当然可以用快速幂，更快（我懒orz &#125; else for(int i=1;i&lt;=c;i++)ans=(long long)ans*p%mod;//这里要么取两次mod，要么用long long，后者快一点，当然可以用快速幂，更快 &#125; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[国际信息学奥赛]官方视频搬运]]></title>
    <url>%2F2018%2F09%2F08%2F%5B%E5%9B%BD%E9%99%85%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%A5%A5%E8%B5%9B%5D%E5%AE%98%E6%96%B9%E8%A7%86%E9%A2%91%E6%90%AC%E8%BF%90%2F</url>
    <content type="text"><![CDATA[今年的国际信息学奥赛的比赛已经告一段落，官网也发布了一些视频，蒟蒻看没人搬就搬过来了。 【国际信息学奥赛】IOI 2018 JAPAN Arrival Sep.1 【国际信息学奥赛】IOI 2018 JAPAN Opening Ceremony Sep.2 【国际信息学奥赛】IOI 2018 JAPAN Contest Day 1 Sep.3 【国际信息学奥赛】IOI 2018 JAPAN Excursion 1 Sep.4 【国际信息学奥赛】IOI 2018 JAPAN Contest Day 2 Sep.5 【国际信息学奥赛】IOI 2018 JAPAN Excursion 2 Sep.6 【国际信息学奥赛】IOI 2018 JAPAN Closing Ceremony Sep.7 这些视频都是一些剪辑，至于比赛，开幕式等完整过程，在ioi官网有，不过是在NicoNico以直播的形式放送的，搬运难度大，而且费时间，NOIP前并没有搬运的打算。]]></content>
  </entry>
  <entry>
    <title><![CDATA[个人dp小结]]></title>
    <url>%2F2018%2F08%2F29%2F%E4%B8%AA%E4%BA%BAdp%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言：最近做了很多动态规划题，但是每次遇到新的题目的时候还是做不出来，于是就像做一个小结，梳理下近些天做的题目，从中获取经验。 第零节：DP的基础概念动态规划和其他某些算法具有一定的相似度，都是利用问题的可划分性以及子问题的相似性来进行归纳，降低时间复杂度。来说说动态规划的几个基本条件： 条件 解释 无后效性 已求解的子问题不受后续阶段的影响$^{[1]}$ 最优子结构 下一个阶段的最优解应该能够由前面各阶段子问题的最优解导出 子问题重叠 动态规划通过对每个子问题只解一次，把解保存在一个需要时就可以查看的表中$^{[2]}$ [1]：在《算法竞赛进阶指南》中有一个很好的说法，“动态规划对状态空间的遍历构成一张有向无环图，遍历顺序就是该图的一个拓扑序。”[2]：其实就是动态规划会用查询的方式解决重复出现的子问题，而不是像递归那样每次算一遍。 构成动态规划的三要素： 要素 解释 状态 即我们通常所说的f或dp数组，他们用来表示什么 阶段 即各个状态在不同时刻的表示 决策 状态如何转移到 下一个状态 知道了这些并没有什么用，重要的还是在题目中体会。 第一节：线性DP我们在解决一些线性区间上的最优化问题的时候，往往也能够利用到动态规划的思想，这种问题可以叫做线性dp。 线性空间 在有关线性dp问题中，有着几个比较经典而基础的模型，例如最长上升子序列(LIS)、最长公共子序列(LCS)、最大子序列和等，那么首先我们从这几个经典的问题出发开始对线性dp的探索。 注：下表引用自《算法竞赛进阶指南》P258表 LIS问题 问题描述 最长上升子序列。给定一个长度为$N$的数列$A$，求数值单调递增的子序列的长度是多少。$A$的任意子序列$B$可表示为$B={A_{k1},A_{k2},…,A_{kp}}$，其中$k_1&lt;k_2&lt;…&lt;k_p$ 状态表示 $F[i]$表示以$A[i]$为结尾的“最长上升子序列”的长度 阶段划分 子序列的位置（数列$A$中的位置，从前到后） 转移方程 $F[i]=max{F[j]+1},0\le j&lt;i,A[j]&lt;A[i]$ 边界 $F[0]=0$ 目标 $max{F[i]},1\le i \le N$ 还有两个大家自行看书~（打这个太累啦）通过这三个问题，我们可以了解到，线性DP无论是多维还是一维，“线性”都体现在“作用在空间上的递推”————DP的阶段沿着各个维度线性增长，从一个或多个“边界点”开始有方向地向整个状态空间转移、扩展，最后每个状态上都保留了以自身为目标子问题的最优解。下面我们开始线性DP的进阶，我们从例题开始。 【例1】Mr. Young’s Picture Permutations$^{poj2279}$这是一个五维的线性DP，从该题给出的解法中我们发现，设计动态规划的状态转移方程，不一定要以“如何计算出一个状态”的形式给出，也可以考虑“一个已知状态应该更新哪些后续阶段的未知状态”。 第二节：背包其实我们OIer很多时候都是靠眼睛学习的，偶尔通过听觉也是不错的。 ⭐0/1背包⭐完全背包⭐多重背包⭐分组背包区间DP树形DP⭐背包类树形DP推荐个视频]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SP15637][POJ2279]GNYR04H - Mr Youngs Picture Permutations]]></title>
    <url>%2F2018%2F08%2F26%2F%5BSP15637%5D%5BPOJ2279%5DGNYR04H%20-%20Mr%20Youngs%20Picture%20Permutations%2F</url>
    <content type="text"><![CDATA[题目题目描述杨先生希望为他的班级拍照。学生将排成一行，每行不超过后面的行，并且行的左端对齐。例如，可以安排12名学生排列（从后到前）5,3,3和1名学生。1234X X X X XX X XX X XX 此外，杨先生希望每排学生安排高度从左到右减少。此外，学生身高应从后向前减少。想想看，杨先生看到，对于这个12人的例子，至少有两种安排学生的方式（数字代表高度，其中1代表最高）：12341 2 3 4 5 1 5 8 11 126 7 8 2 6 99 10 11 3 7 1012 4 杨先生想知道，对于给定排列的排列，可能有多少不同的学生安排。他尝试用长度为3,2和1的行开始计数，并计数16个排列：123123 123 124 124 125 125 126 126 134 134 135 135 136 136 145 14645 46 35 36 34 36 34 35 25 26 24 26 24 25 26 256 5 6 5 6 4 5 4 6 5 6 4 5 4 3 3 杨先生认为，手动点数对于任何合理数量的学生来说都不会很有效。他通过编写计算机程序来帮助你确定一组给定行的学生的不同安排数量。 输入格式输入描述了一系列测试，每个测试分两行描述。第一行将行数k作为十进制整数。第二行包含从后到前的行的长度（n {1} 1 ，n {2} 2 ，…，n _ {K} ķ ）作为由单个空格分隔的十进制整数。问题集以行计数为0的行结束。最多不会超过5行，学生总数N（行长度总和）最多不超过30行。 输出格式对于每个测试用例输出一个整数：N个学生排列在给定行中的数量，以便高度从左到右沿着每行减少，并且从后到前沿着每列减小（假定所有高度都不同）。结果应该分开。输入数据将被选择，以便结果总是适合一个无符号的32位整数。 输入样例1234567891011121313051 1 1 1 133 2 145 3 3 156 5 4 3 2215 150 输出样例123456111641581418926089694845 翻译by@_UMR_ 题解看到网上很多人说《算法竞赛进阶指南》上的方法不行，会MLE那动态开空间不就是了……在合法的方案中，每一行，每一列都是单调的，也就是说我们要确保每一次放的时候，放的人要小于左边的，上面的。其实这也很好办，假设我们放的人的高度是递减的，第一行我们只要放得去，就能满足单调，而下面几行，只要各自人数小于等于上面一行的人数就OK了。让我们来看看这一题的“动态规划信息表” 信息 表示方式 解释 状态 $F_{a_1,a_2,a_3,a_4,a_5}$ 表示各排从左端起，分别占了$a_1,a_2,a_3,a_4,a_5$个人时，合影方案数量 边界 $F_{0,0,0,0,0}=1$ 其余为0 目标 $F_{N_1,N_2,N_3,N_4,N_5}$ 无 转移 无 若$a_1&lt;N_1$,则令$F_{a_1+1,a_2,a_3,a_4,a_5}+=F_{a_1,a_2,a_3,a_4,a_5}$。若$a_2&lt;N_2\&amp;\&amp;a_1&gt;a_2$则令$F_{a_1,a_2+1,a_3,a_4,a_5}+=F_{a_1,a_2,a_3,a_4,a_5}$ 第3~5同理 至于杨氏矩阵和钩长公式，还请大家自行了解。 代码1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int k,a[6],n[6];int main()&#123; while(scanf("%d",&amp;k))&#123; if(k==0)break; memset(n,0,sizeof(n)); for(int i=1;i&lt;=k;i++) scanf("%d",&amp;n[i]); int f[n[1]+1][n[2]+1][n[3]+1][n[4]+1][n[5]+1]; memset(f,0,sizeof(f)); f[0][0][0][0][0]=1; for(a[1]=0;a[1]&lt;=n[1];a[1]++) for(a[2]=0;a[2]&lt;=n[2];a[2]++) for(a[3]=0;a[3]&lt;=n[3];a[3]++) for(a[4]=0;a[4]&lt;=n[4];a[4]++) for(a[5]=0;a[5]&lt;=n[5];a[5]++)&#123; int t=f[a[1]][a[2]][a[3]][a[4]][a[5]]; if(a[1]&lt;n[1]) f[a[1]+1][a[2]][a[3]][a[4]][a[5]]+=t; if(a[2]&lt;n[2]&amp;&amp;a[1]&gt;a[2]) f[a[1]][a[2]+1][a[3]][a[4]][a[5]]+=t; if(a[3]&lt;n[3]&amp;&amp;a[2]&gt;a[3]) f[a[1]][a[2]][a[3]+1][a[4]][a[5]]+=t; if(a[4]&lt;n[4]&amp;&amp;a[3]&gt;a[4]) f[a[1]][a[2]][a[3]][a[4]+1][a[5]]+=t; if(a[5]&lt;n[5]&amp;&amp;a[4]&gt;a[5]) f[a[1]][a[2]][a[3]][a[4]][a[5]+1]+=t; &#125; printf("%d\n",f[n[1]][n[2]][n[3]][n[4]][n[5]]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>线性dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2014]联合权值]]></title>
    <url>%2F2018%2F08%2F25%2F%5BNOIP2014%5D%E8%81%94%E5%90%88%E6%9D%83%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目题目描述无向连通图G 有n 个点，n – 1 条边。点从1 到n 依次编号，编号为 i 的点的权值为W i ，每条边的长度均为1 。图上两点( u , v ) 的距离定义为u 点到v 点的最短距离。对于图G 上的点对( u, v) ，若它们的距离为2 ，则它们之间会产生Wu×Wv 的联合权值。请问图G 上所有可产生联合权值的有序点对中，联合权值最大的是多少？所有联合权值之和是多少？ 输入格式输入文件名为link .in。第一行包含1 个整数n 。接下来n – 1 行，每行包含 2 个用空格隔开的正整数u 、v ，表示编号为 u 和编号为v 的点之间有边相连。最后1 行，包含 n 个正整数，每两个正整数之间用一个空格隔开，其中第 i 个整数表示图G 上编号为i 的点的权值为W i 。 输出格式输出文件名为link .out 。输出共1 行，包含2 个整数，之间用一个空格隔开，依次为图G 上联合权值的最大值和所有联合权值之和。由于所有联合权值之和可能很大，输出它时要对10007 取余。「数据说明」对于30% 的数据，1 &lt; n≤ 100 ；对于60% 的数据，1 &lt; n≤ 2000；对于100%的数据，1 &lt; n≤ 200 , 000 ，0 &lt; wi≤ 10, 000 。 输入样例1234565 1 2 2 33 4 4 5 1 5 2 3 10 输出样例120 74 题解这道题其实是道水题（逃ε=ε=ε=┏(゜ロ゜;)┛我们首先要发现的一点就是如果我们确定了一个点，他所遍历到的所有点它们互相的距离就是$2$。所以我们就可以枚举每一个点，枚举它每一个可通往的点，最大值取$$Mx=max(Mx,该点遍历的最大值\times该点遍历到的次大值)$$而总和我们就取$$Ans=\sum V[遍历过的边] \times V[当前边]$$注意要最后答案要乘2，因为(1,3)(3,1)要算两次 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN = 200004, mod = 10007;int Head[MAXN], Nt[MAXN * 2], to[MAXN * 2];int tot, n;int v[MAXN];int mx, ans;void add(int a, int b) &#123; Nt[++tot] = Head[a]; to[tot] = b; Head[a] = tot;&#125;void get(int x) &#123; int sum = 0, ma = 0, m = 0;//当前总和，最大值，次大值 for (int i = Head[x]; i; i = Nt[i]) &#123; if (v[to[i]]&gt;ma) &#123; m = ma; ma = v[to[i]]; &#125; else if (v[to[i]]&gt;m)m = v[to[i]]; ans = (ans + sum * v[to[i]]) % mod; sum = (sum + v[to[i]]) % mod; &#125; mx= max(mx, ma*m);&#125;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt; n; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); add(a, b); add(b, a); &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;v[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; get(i); &#125; cout &lt;&lt; mx &lt;&lt; " " &lt;&lt; ans*2%mod &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>树的遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P4011]孤岛营救问题]]></title>
    <url>%2F2018%2F08%2F25%2F%5B%E6%B4%9B%E8%B0%B7P4011%5D%E5%AD%A4%E5%B2%9B%E8%90%A5%E6%95%91%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目题目描述$1944$ 年，特种兵麦克接到国防部的命令，要求立即赶赴太平洋上的一个孤岛，营救被敌军俘虏的大兵瑞恩。瑞恩被关押在一个迷宫里，迷宫地形复杂，但幸好麦克得到了迷宫的地形图。迷宫的外形是一个长方形，其南北方向被划分为 $N$ 行，东西方向被划分为 $M$ 列，于是整个迷宫被划分为 $N\times M$ 个单元。每一个单元的位置可用一个有序数对(单元的行号，单元的列号)来表示。南北或东西方向相邻的 $2$ 个单元之间可能互通，也可能有一扇锁着的门，或者是一堵不可逾越的墙。迷宫中有一些单元存放着钥匙，并且所有的门被分成 $P$ 类，打开同一类的门的钥匙相同，不同类门的钥匙不同。 大兵瑞恩被关押在迷宫的东南角，即 $(N,M)$ 单元里，并已经昏迷。迷宫只有一个入口，在西北角。也就是说，麦克可以直接进入 $(1,1)$ 单元。另外，麦克从一个单元移动到另一个相邻单元的时间为$1$ ，拿取所在单元的钥匙的时间以及用钥匙开门的时间可忽略不计。 试设计一个算法，帮助麦克以最快的方式到达瑞恩所在单元，营救大兵瑞恩。 输入格式 输出格式将麦克营救到大兵瑞恩的最短时间的值输出。如果问题无解，则输出 -1 。 输入样例12345678910111213144 4 991 2 1 3 21 2 2 2 02 1 2 2 02 1 3 1 02 3 3 3 02 4 3 4 13 2 3 3 03 3 4 3 04 3 4 4 022 1 24 2 1 输出样例114 说明 题解基本方法虽然它是网络流24题，但是其实根本不用网络流做。首先我们来看看这个题目的数据范围，挺有意思的。$N,M,P\le10$钥匙种类和地图大小都很小，嗯，感觉可以广搜，置于钥匙，我们就可以状态压缩一下 变量名 变量作用 $vis_{i,j,k}$ 记录你是否揣着$k$这个集合的钥匙到过$(i,j)$处 $map_{x1,y1,x2,y2}$ 表示$(x1,y1)$到$(x2,y2)$是个什么情况 $key_{i,j,k}$ 表示$(i,j)$存放的第$k$把钥匙 $num_{i,j}$ 表示在$(i,j)$处有几把钥匙 $tt$ 当前携带的钥匙集合 状态压缩至于状态压缩的话，假设现在有5种钥匙，我们用1表示现在身上有，0没有。初始情况： 0 0 0 0 0 现在，我们来了第二把钥匙（从右往左） 0 0 0 1 0 这东西是不是很像二进制？所以我们就可以用二进制来进行状压。每次我们得到钥匙时，$tt|=1&lt;&lt;(key[i][j][k]-1)$每次查询是否有第i把钥匙时，只要$tt\&amp;(1&lt;&lt;(i-1))$为真，我们就可以认为有这把钥匙。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int dx[4] = &#123; -1,1,0,0 &#125;;const int dy[4] = &#123; 0,0,-1,1 &#125;;struct node &#123; int x, y, step, key;&#125;;queue&lt;node&gt;q;bool v[11][11][1 &lt;&lt; 11];//v[x][y][tt]表示点(x,y)带有这么多的钥匙是否来过int n, m, p, k;int mp[11][11][11][11];//mp[x1][y1][x2][y2]表示两个点直接是否有墙或者是门，0表示可以直接通过int key[11][11][11];//key[x][y][i]表示点（x,y）放的第i把钥匙int num[11][11];//num[x][y]表示点（x,y)有多少把钥匙int bfs() &#123; int tt = 0; for (int i = 1; i &lt;= num[1][1]; i++) &#123; tt |= (1 &lt;&lt; (key[1][1][i] - 1));//初始点可以放钥匙 &#125; v[1][1][tt] = 1; q.push((node) &#123; 1, 1, 0, tt &#125;); while (!q.empty()) &#123; node x = q.front(); q.pop(); if (x.x == n &amp;&amp; x.y == m) return x.step; for (int i = 0; i &lt;= 3; i++) &#123; int xx = x.x + dx[i]; int yy = x.y + dy[i]; if (1 &lt;= xx &amp;&amp; xx &lt;= n &amp;&amp; 1 &lt;= yy &amp;&amp; yy &lt;= m) &#123;//是否合法 if (mp[x.x][x.y][xx][yy] == -1) continue;//墙，不能 int t; if ((t = mp[x.x][x.y][xx][yy]) != 0)//门 if ((x.key&amp;(1 &lt;&lt; (t - 1))) == 0) continue;//没有钥匙 int tt = x.key; for (int j = 1; j &lt;= num[xx][yy]; j++) tt = tt | (1 &lt;&lt; (key[xx][yy][j] - 1));//带上钥匙 if (v[xx][yy][tt]) continue;//同样的地点带着同样的钥匙，我们就认为状态重复了 v[xx][yy][tt] = 1; q.push((node) &#123; xx, yy, x.step + 1, tt &#125;); &#125; &#125; &#125; return -1;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; k; for (int i = 1; i &lt;= k; i++) &#123; int x1, x2, y1, y2, g; scanf("%d%d%d%d%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;g); if (g == 0)mp[x1][y1][x2][y2] = mp[x2][y2][x1][y1] = -1; else mp[x1][y1][x2][y2] = mp[x2][y2][x1][y1] = g; &#125; int s; scanf("%d", &amp;s); for (int i = 1; i &lt;= s; i++) &#123; int x, y, p; scanf("%d%d%d", &amp;x, &amp;y, &amp;p); key[x][y][++num[x][y]] = p; &#125; printf("%d\n", bfs()); return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>广搜</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVA11362]Phone List]]></title>
    <url>%2F2018%2F08%2F22%2F%5BUVA11362%5DPhone%20List%2F</url>
    <content type="text"><![CDATA[题目PDF 题解虽然我很想说这是一道字典树模板题，但是还是有点技巧的。对于每组输入，我们先把它存入字典树，然后再来查找（也就是所谓的离线）为了说明方便，用表格说明一下变量吧 变量名 变量作用 $st$ 保存读入的字符串，用于离线 $word$ 保存字典树每条边被覆盖的次数，遍历时为1说明不是前缀 $ch$ 字典树，第一维是编号，第二维是哪条边，值为指向的点 $sz$ 用来编号，类似于链式前向星里的$tot$ 关键是遍历的时候，只要word为1就返回0（就是它自己啊），能顺利的走下来就返回1 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int MAX = 1e5 + 10;int t,n;char st[10100][10];int word[MAX],ch[MAX][10],sz;void reset()&#123;//每组数据需要重置 sz = 1; memset(ch[0],0,sizeof(ch[0])); memset(word,0,sizeof(word));&#125;void insert(char *s)&#123;//插入进字典树 int nl = strlen(s),u = 0; for(int i = 0 ; i &lt; nl ;i++)&#123; int c = s[i] - '0'; if(! ch[u][c])&#123; memset(ch[sz],0,sizeof(ch[sz])); ch[u][c] = sz++; &#125; u = ch[u][c]; word[u]++; &#125;&#125;int find(char *s)&#123;//是否是前缀 int nl = strlen(s),u = 0; for(int i = 0; i &lt; nl; i++)&#123; int c = s[i] - '0'; u = ch[u][c]; if(word[u] == 1) return 0; &#125; return 1;&#125;int main()&#123; cin&gt;&gt;t; while(t--)&#123; reset(); scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n; i++)&#123; scanf("%s",st[i]); insert(st[i]); &#125; int ok = 1; for(int i = 1 ; i &lt;= n; i++) if(find(st[i]))&#123; ok = 0; break; &#125; if(ok) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>字典树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P4071][SDOI2016]排列计数]]></title>
    <url>%2F2018%2F08%2F22%2F%5B%E6%B4%9B%E8%B0%B7P4071%5D%5BSDOI2016%5D%E6%8E%92%E5%88%97%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目题目描述求有多少种长度为 n 的序列 A，满足以下条件：1 ~ n 这 n 个数在序列中各出现了一次若第 i 个数 A[i] 的值为 i，则称 i 是稳定的。序列恰好有 m 个数是稳定的满足条件的序列可能很多，序列数对 10^9+7 取模。 输入格式第一行一个数 T，表示有 T 组数据。接下来 T 行，每行两个整数 n、m。T=500000，n≤1000000，m≤1000000 输出格式输出 T 行，每行一个数，表示求出的序列数 输入样例12345651 01 15 2100 5010000 5000 输出样例12345012057802888760695423 题解没思路？我们来找规律！比如一个$n=5$的排列，我们假设$m=2$也就是说，我们其实已经确定了排列种某些位置的值，就这个例子来说： $12???$ $1?3??$ $1??4?$ $1???5$ $?23??$ $?2?4?$ $?2??5$ $??34?$ $??3?5$ $???45$ 共10种，很容易发现其实就是$C_n^m$，那么其中的问号又多少种排列呢？ 没思路？我们再来找规律！我们设$D_i$为i个?的可能的排列数，显然，$D_1=0$ $D_2=1$接着我们来看下$D_3$，可以有$312$,$231$如果我们继续找下去的话，容易出错，所以我们现在来找找规律（灵魂画师）。就拿$D_4$来说，上面的是数，下面的是位置，首先，1不能放到1号位，而且放到2，3，4上对于递推是等价的，于是他别无选择地放到了其他地方（假设是2号位）然后我们假设2放到1号位上去，剩下的3，4正好是$D_2$但2怎么可能只有放在1号位上的命运呢？它还可以不放到1号位，咦？我们之前说，i不能放到i号位，那么既然2不放到1号位，那么1号位在这里是不是等价于2号位呢？没错！而之前的“万恶之源”数字1，它有$n-1$种放法，所以我们就大胆猜测：$D_n=(n-1)(D_{n-1}+D_{n-2})$严谨的证明还请大家自己百度然后我们就愉快地输出$C_n^m\times D_{n-m}$就好啦其他知识点比如说逆元求组合数（费马小定理）还请大家自行了解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;const int MAXN=1000005,mod=1000000007;ll f[MAXN],inv[MAXN],d[MAXN];int t;ll qpow(ll a,ll b)&#123; ll ans=1; while(b)&#123; if(b&amp;1)ans=a*ans%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return ans;&#125;void prework()&#123; f[0]=1; for(int i=1;i&lt;MAXN;i++)&#123; f[i]=f[i-1]*i%mod; inv[i]=qpow(f[i],mod-2); &#125; d[1]=0,d[2]=1,d[3]=2; for(int i=4;i&lt;MAXN;i++)&#123; d[i]=(i-1)*(d[i-1]+d[i-2])%mod; &#125;&#125;int main()&#123; cin&gt;&gt;t; prework(); for(int i=1;i&lt;=t;i++)&#123; ll n,m; scanf("%lld%lld",&amp;n,&amp;m); if (n - m == 1) printf("0\n"); else if (m == n) printf("1\n"); else if (m == 0) printf("%lld\n",d[n]); else &#123; printf("%lld\n",f[n] * inv[m] % mod * inv[n-m] % mod * d[n-m] % mod); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数论</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>组合数</tag>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2009]最优贸易]]></title>
    <url>%2F2018%2F08%2F22%2F%5BNOIP2009%5D%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93%2F</url>
    <content type="text"><![CDATA[题目题目描述C 国有n 个大城市和m 条道路，每条道路连接这n 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这m 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为1 条。C 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。商人阿龙来到 C 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设C 国n 个城市的标号从1~ n，阿龙决定从1 号城市出发，并最终在n 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有n 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品——水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来C 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。假设 C 国有5 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。假设 1~n 号城市的水晶球价格分别为4，3，5，6，1。阿龙可以选择如下一条线路：1-&gt;2-&gt;3-&gt;5，并在2 号城市以3 的价格买入水晶球，在3号城市以5 的价格卖出水晶球，赚取的旅费数为2。阿龙也可以选择如下一条线路 1-&gt;4-&gt;5-&gt;4-&gt;5，并在第1 次到达5 号城市时以1 的价格买入水晶球，在第2 次到达4 号城市时以6 的价格卖出水晶球，赚取的旅费数为5。 现在给出 n 个城市的水晶球价格，m 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。 输入格式第一行包含 2 个正整数n 和m，中间用一个空格隔开，分别表示城市的数目和道路的数目。第二行 n 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这n 个城市的商品价格。接下来 m 行，每行有3 个正整数，x，y，z，每两个整数之间用一个空格隔开。如果z=1，表示这条道路是城市x 到城市y 之间的单向道路；如果z=2，表示这条道路为城市x 和城市y 之间的双向道路。 输出格式包含1 个整数，表示最多能赚取的旅费。如果没有进行贸易，则输出0。 输入样例12345675 54 3 5 6 11 2 11 4 12 3 23 5 14 5 2 输出样例15 数据范围输入数据保证 1 号城市可以到达n 号城市。对于 10%的数据，1≤n≤6。对于 30%的数据，1≤n≤100。对于 50%的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。对于 100%的数据，1≤n≤100000，1≤m≤500000，1≤x，y≤n，1≤z≤2，1≤各城市水晶球价格≤100。 题解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;using namespace std;const int MAXN = 500010;int n, m;int flag = 0;int Head[MAXN / 5], Nt[MAXN * 2], to[MAXN * 2], tot;int price[MAXN / 5], f[MAXN / 5], mi[MAXN / 5];void add(int a, int b) &#123; Nt[++tot] = Head[a]; to[tot] = b; Head[a] = tot;&#125;void dfs(int x, int minn, int pre) &#123; int flag = 1; minn = min(minn, price[x]); if (mi[x]&gt;minn)mi[x] = minn, flag = 0; int maxx = max(f[pre], price[x] - mi[x]); if (f[x]&lt;maxx)f[x] = maxx, flag = 0; if (flag)return; for (int i = Head[x]; i; i = Nt[i]) &#123; int y = to[i]; dfs(y, minn, x); &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; memset(mi, 0x7f, sizeof(mi)); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;price[i]); &#125; for (int i = 1; i &lt;= m; i++) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); add(a, b); if (c == 2)add(b, a); &#125; dfs(1, 1 &lt;&lt; 30, 0); printf("%d", f[n]); return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>深搜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1040]加分二叉树]]></title>
    <url>%2F2018%2F08%2F16%2F%5B%E6%B4%9B%E8%B0%B7P1040%5D%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目题目描述设一个n个节点的二叉树tree的中序遍历为（l,2,3,…,n），其中数字1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第j个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下： subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数。若某个子树为空 ，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空 子树。 试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。要求输出； （1）tree的最高加分 （2）tree的前序遍历 输入格式第1行：一个整数n（n＜30），为节点个数。 第2行：n个用空格隔开的整数，为每个节点的分数（分数＜100）。 输出格式第1行：一个整数，为最高加分（结果不会超过4,000,000,000）。 第2行：n个用空格隔开的整数，为该树的前序遍历。 输入样例1255 7 1 2 10 输出样例121453 1 2 4 5 题解一道入门的区间dp，当然，根据写法不同你还可以把它归类为树形dp或者记忆化搜索，其实都无所谓啦。作为一道入门题，我们完全可以“显然”地做出来，但是在这里还是想和大家回顾下动态规划以及区间动规。 Q：dp特点是什么？A：dp把原问题视作若干个重叠的子问题的逐层递进，每个子问题的求解过程都会构成一个“阶段”，在完成一个阶段后，才会执行下一个阶段。Q：dp要满足无后效性，什么叫无后效性？A：已经求解的子问题不受后续阶段的影响。 有人觉得dp很抽象，那是因为没有一步一步来想，直接听别人的结论，我们在这里以这道题为例，一步一步来推导。 首先，我们要做的就是设计状态，其实就是设计dp数组的含义，它要满足无后效性。关注这个 左子树*右子树+根 我只要知道左子树分数和右子树分数和根的分数（已给出），不就可以了吗？管他子树长什么样！所以，我们$f$数组存的就是最大分数，怎么存呢？我们发现：子树是一个或多个节点的集合。那么我们可不可以开一个$f[i][j]$来表示节点i到节点j成树的最大加分呢？可以先保留这个想法（毕竟暂时也想不到更好的了）。 如果这样话，我们就来设计状态转移方程。按照刚刚的设计来说的话，我们的答案就是$f[1][n]$了，那么我们可以从小的子树开始，也就是len，区间长度。有了区间长度我们就要枚举区间起点，i为区间起点，然后就可以算出区间终点j。通过加分二叉树的式子我们可以知道，二叉树的分取决于谁是根，于是我们就在区间内枚举根k。特别的，$f[i][i]=a[i]$其中a[i]为第i个节点的分数。因为是要求最大值，所以我们就可以设计出$$f[i][j]=MAX(f[i][k-1]*f[k+1][j]+f[k][k])$$于是乎，我们就自己设计出了一个dp过程，因为是顺着来的，所以很少有不成立的。 至于输出前序遍历，我们再设计一个状态$root[i][j]$来表示节点i到节点j成树的最大加分所选的根节点。所以我们按照$根-&gt;左-&gt;右$的顺序递归输出即可。 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int MAXN = 50;typedef long long ll;ll n;ll f[MAXN][MAXN], root[MAXN][MAXN];void print(ll l, ll r) &#123; if (l &gt; r)return; printf("%lld ", root[l][r]); if (l == r)return; print(l, root[l][r] - 1); print(root[l][r]+1,r);&#125;int main() &#123; scanf("%lld", &amp;n); for (int i = 1; i &lt;= n; i++)scanf("%lld", &amp;f[i][i]),f[i][i-1]=1, root[i][i] = i; for (int len = 1; len &lt; n; ++len) &#123; for (int i = 1; i + len &lt;= n; ++i) &#123; int j = i + len; f[i][j] = f[i + 1][j] + f[i][i];//默认它的左子树为空，如果有的话，这肯定不是最优解 root[i][j] = i;//默认从起点选根 for (int k = i + 1; k &lt; j; ++k) &#123; if (f[i][j] &lt; f[i][k - 1] * f[k + 1][j] + f[k][k]) &#123; f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k]; root[i][j] = k; &#125; &#125; &#125; &#125; cout &lt;&lt; f[1][n] &lt;&lt; endl; print(1, n); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>区间dp</category>
      </categories>
      <tags>
        <tag>中序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1771] 方程的解]]></title>
    <url>%2F2018%2F08%2F15%2F%5B%E6%B4%9B%E8%B0%B7P1771%5D%20%E6%96%B9%E7%A8%8B%E7%9A%84%E8%A7%A3_NOI%E5%AF%BC%E5%88%8A2010%E6%8F%90%E9%AB%98%2F</url>
    <content type="text"><![CDATA[题目题目描述佳佳碰到了一个难题，请你来帮忙解决。 对于不定方程a1+a2+…+ak-1+ak=g(x)，其中k≥2且k∈N，x是正整数，g(x)=x^x mod 1000(即x^x除以1000的余数)，x，k是给定的数。我们要求的是这个不定方程的正整数解组数。 举例来说，当k=3，x=2时，分别为(a1,a2,a3)=(2,1,1)’(1,2,1)，(1,1,2)。 输入格式输入文件equation.in有且只有一行，为用空格隔开的两个正整数，依次为k，x。 输出格式输出文件equation.out有且只有一行，为方程的正整数解组数。 输入样例13 2 输出样例13 说明对于40%的数据，ans≤10^16；对于100%的数据，k≤100，x≤2^31-1，k≤g(x)。 题解首先呢，$g(x)$我们是可以求解的，我们设$n=g(x)$我们可以先写出$n$个1，我们发现它们之间有$n-1$个空隙，而我们的任务是寻找k个数，使k个数的和等于$n$，于是我们就可以将问题转化成在$n-1$个空隙中选出$k-1$个空隙放挡板，形成的$k$个数的和正好就是$n$。换句话说，我们要求$C_{n-1}^{k-1}$对于样例的画图辅助理解 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;const int MAXN = 100, mod = 1000, inf = 1000000;ll k, x, n;ll sum[MAXN], cnt = 1;ll qpow(ll a, ll b) &#123; ll ans = 1; while (b) &#123; if (b &amp; 1)ans = ans * a%mod; a = a * a%mod; b &gt;&gt;= 1; &#125; return ans;&#125;void c(ll n, ll m) &#123; sum[1] = 1, cnt = 1; for (int i = m; i &gt;= m - n + 1; i--) &#123;//对组合数公式进行了化简 for (int j = 1; j&lt;MAXN; j++) &#123; sum[j] *= i; &#125; for (int j = 1; j&lt;MAXN; j++) &#123; if (sum[j] &gt;= inf) &#123; sum[j + 1] += sum[j] / inf; sum[j] %= inf; &#125; &#125; &#125; for (int i = 2; i &lt;= n; i++) &#123; for (int j = MAXN-1; j &gt;= 1; j--) &#123; if (sum[j] == 0) continue; if (sum[j] &gt;= i) &#123; sum[j - 1] += sum[j] % i*inf; sum[j] /= i; &#125; else sum[j - 1] += sum[j] * inf, sum[j] = 0; &#125; &#125;&#125;int main() &#123; ll k, x; cin &gt;&gt; k &gt;&gt; x; n = qpow(x, x); if (k - 1 &lt;= 0 || n - 1 &lt;= 0) &#123; printf("0"); return 0; &#125; c(k - 1, n - 1);//总共有n-1个间隙，要插k-1个隔板； int id; for (int i = MAXN - 1; i &gt;= 1; i--) &#123; if (sum[i]) &#123; id = i; break; &#125; &#125; printf("%lld", sum[id]); for (int i = id-1; i &gt;= 1; i--) &#123; printf("%06lld", sum[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>组合数</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVA10140]Prime Distance]]></title>
    <url>%2F2018%2F08%2F15%2F%5BUVA10140%5DPrime%20Distance%2F</url>
    <content type="text"><![CDATA[题目题目描述The branch of mathematics called number theory is about properties of numbers. One of the areas that has captured the interest of number theoreticians for thousands of years is the question of primality. A prime number is a number that is has no proper factors (it is only evenly divisible by 1 and itself). The first prime numbers are 2,3,5,7 but they quickly become less frequent. One of the interesting questions is how dense they are in various ranges. Adjacent primes are two numbers that are both primes, but there are no other prime numbers between the adjacent primes. For example, 2,3 are the only adjacent primes that are also adjacent numbers.Your program is given 2 numbers: L and U (1&lt;=L&lt; U&lt;=2,147,483,647), and you are to find the two adjacent primes C1 and C2 (L&lt;=C1&lt; C2&lt;=U) that are closest (i.e. C2-C1 is the minimum). If there are other pairs that are the same distance apart, use the first pair. You are also to find the two adjacent primes D1 and D2 (L&lt;=D1&lt; D2&lt;=U) where D1 and D2 are as distant from each other as possible (again choosing the first pair if there is a tie).Input 给定两个整数 L,R，求闭区间 [L,R]中相邻两个质数差值最小的数对与差值最大的数对。当存在多个时，输出靠前的素数对。 输入格式Each line of input will contain two positive integers, L and U, with L &lt; U. The difference between L and U will not exceed 1,000,000. 输出格式For each L and U, the output will either be the statement that there are no adjacent primes (because there are less than two primes between the two given numbers) or a line giving the two pairs of adjacent primes. 输入样例122 1714 17 输出样例122,3 are closest, 7,11 are most distant.There are no adjacent primes. 题解部分内容来自李煜东所著《算法进阶指南》 暴力是不可能的，R的范围太大了。但是我们发现，R-L的范围很小，有什么办法可以求出R-L之间的质数呢？显然： 定理：如果n是一个合数， 那么n一定有一个不超过$\sqrt{n}$的素数因子推论：任意一个合数n必定包含一个不超过$\sqrt{n}$的质因子 用质因数分解定理可以简单证明。所以，我们只要用筛法求出$2$~$\sqrt{R}$之间所有的质数，对于每个质数p，把$[L,R]$中能被p整除的数标记，即标记$i*p\left(\Big\lceil\dfrac{L}{P}\Big\rceil\le\Big\lceil\dfrac{R}{P}\Big\rceil\right)$为合数。最终所有还没有被标记的数就是$\left[L,R\right]$中的质数。对相邻质数两两比较，找出差最大的即可。时间复杂度为$O\left(\sum_{质数p\le\sqrt{R}}\frac{R-L}{p}\right)=O\left(\sqrt{R}loglog\sqrt{R}+(R-L)loglogR\right)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int MAXN = 46345;typedef long long ll;int p[MAXN],cnt,l,r,m;bool v[1000001];int b[1000001];void prime() &#123; memset(v, 1, sizeof(v)); for (int i = 2; i &lt;= MAXN; i++) if (v[i])&#123; p[++cnt] = i; for (int j = 2; j &lt;= 46340 / i; j++) v[i*j] = false; &#125;&#125;int main() &#123; prime(); while (cin &gt;&gt; l &gt;&gt; r) &#123; memset(v, 1, sizeof(v)); if (l == 1) v[0] = false; for (ll i = 1; i &lt;= cnt; i++) for (ll j = l / p[i]; j &lt;= r / p[i]; j++) &#123; if (p[i] * j - l &lt; 0)continue;//这里不加，poj过不了 if (j &gt; 1) v[p[i] * j - l] = false; &#125; m = 0; for (ll i = l; i &lt;= r; i++)&#123;//这里一定要开ll的i，要不然溢出了就会死循环 if (v[i - l]) b[++m] = i; &#125; ll t1 = 2147483647; ll t2 = 0; ll x1, x2, y1, y2; for (ll i = 1; i&lt;m; i++)&#123; ll cha = b[i + 1] - b[i]; if (cha&lt;t1) &#123; t1 = cha; x1 = b[i]; y1 = b[i + 1]; &#125; if (cha&gt;t2) &#123; t2 = cha; x2 = b[i]; y2 = b[i + 1]; &#125; &#125; if (!t2) cout &lt;&lt; "There are no adjacent primes.\n"; else cout &lt;&lt; x1 &lt;&lt; ',' &lt;&lt; y1 &lt;&lt; " are closest, " &lt;&lt; x2 &lt;&lt; ',' &lt;&lt; y2 &lt;&lt; " are most distant.\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1445][Violet]樱花]]></title>
    <url>%2F2018%2F08%2F13%2F%5B%E6%B4%9B%E8%B0%B7P1445%5D%5BViolet%5D%E6%A8%B1%E8%8A%B1%2F</url>
    <content type="text"><![CDATA[题目题目描述求方程$$ \frac{1}{X}+\frac{1}{Y}=\frac{1}{N!} $$的正整数解的组数，其中N≤10^6。解的组数，应模1e9+7。 输入格式输入一个整数N 输出格式输出答案 题解 部分内容参考自这篇文章 $$ \frac{1}{x}+\frac{1}{y}=\frac{1}{n!} $$ 先通分 $$ \frac{(x+y)}{xy}=\frac{1}{n!} $$ 再化整数 $$ xy-(x+y)*n!=0 $$ 然后配平 $$ (n!)^2-(x+y)*n!+xy=(n!)^2 $$ 最后 $$ (x-n!)*(y-n!)=(n!)^2 $$ 然后我们发现$x，y$都要是正整数； 所以原题可以变为 $$ A*B=(n!)^2 $$ 当$A*B$为正整数的时候$x,y$显然也是正整数；$x,y$可以是任意正整数，即$A,B$可以为任意正整数，我们就可以对$x$单独进行讨论我们考虑$x$的取值，显然，若一个质数$p$有$k$个，那么$x$可以取$p^0,p^1….p^k$ 共$(k+1)$种情况乘法原理乘起来就可以了,而且显然，x确定后，y必然也会被确定那么我们先可以筛出质数（这里是埃氏筛法）；求出每个数的最小质因数然后暴力就好了； 代码12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=1000005;const int mod=1e9+7;int n;long long v[MAXN],phi[MAXN],p[MAXN],cnt;int c[MAXN];int main()&#123; cin&gt;&gt;n; for(int i=2;i&lt;=n;i++)&#123; if(v[i])continue; p[++cnt]=i; for(int j=1;j*i&lt;=n;j++)v[i*j]=1; &#125; long long k=0,ans=1; for(int i=1;i&lt;=cnt;i++)&#123; int pri=p[i],c1=0; for(int j=n;j;j/=pri)&#123; c1+=j/pri; &#125; c[++k]=c1; &#125; for(int i=1;i&lt;=cnt;i++)ans=ans*(c[i]*2+1)%mod; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[洛谷UVA540]Team Queue]]></title>
    <url>%2F2018%2F08%2F05%2F%5B%E6%B4%9B%E8%B0%B7UVA540%5DTeam%20Queue%2F</url>
    <content type="text"><![CDATA[题目题目描述Queues and Priority Queues are data structures which are known to most computer scientists. TheTeam Queue, however, is not so well known, though it occurs often in everyday life. At lunch time thequeue in front of the Mensa is a team queue, for example.In a team queue each element belongs to a team. If an element enters the queue, it first searchesthe queue from head to tail to check if some of its teammates (elements of the same team) are alreadyin the queue. If yes, it enters the queue right behind them. If not, it enters the queue at the tailand becomes the new last element (bad luck). Dequeuing is done like in normal queues: elements areprocessed from head to tail in the order they appear in the team queue.Your task is to write a program that simulates such a team queue. 输入格式The input file will contain one or more test cases. Each test case begins with the number of teamst (1 ≤ t ≤ 1000). Then t team descriptions follow, each one consisting of the number of elementsbelonging to the team and the elements themselves. Elements are integers in the range 0..999999. Ateam may consist of up to 1000 elements.Finally, a list of commands follows. There are three different kinds of commands:• ENQUEUE x — enter element x into the team queue• DEQUEUE — process the first element and remove it from the queue• STOP — end of test caseThe input will be terminated by a value of 0 for t.Warning: A test case may contain up to 200000 (two hundred thousand) commands, so the implementationof the team queue should be efficient: both enqueing and dequeuing of an element shouldonly take constant time. 输出格式For each test case, first print a line saying ‘Scenario #k’, where k is the number of the test case. Then,for each ‘DEQUEUE’ command, print the element which is dequeued on a single line. Print a blank lineafter each test case, even after the last one. 样例输入123456789101112131415161718192021222324252627282930313233343523 101 102 1033 201 202 203ENQUEUE 101ENQUEUE 201ENQUEUE 102ENQUEUE 202ENQUEUE 103ENQUEUE 203DEQUEUEDEQUEUEDEQUEUEDEQUEUEDEQUEUEDEQUEUESTOP25 259001 259002 259003 259004 2590056 260001 260002 260003 260004 260005 260006ENQUEUE 259001ENQUEUE 260001ENQUEUE 259002ENQUEUE 259003ENQUEUE 259004ENQUEUE 259005DEQUEUEDEQUEUEENQUEUE 260002ENQUEUE 260003DEQUEUEDEQUEUEDEQUEUEDEQUEUESTOP0 样例输出1234567891011121314Scenario #1101102103201202203Scenario #2259001259002259003259004259005260001 题解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;int team[1000002],cnt;string s;int t;int main()&#123; while(scanf("%d",&amp;t)!=EOF)&#123; cnt++; queue&lt;int&gt;tque[1001]; queue&lt;int&gt;mque; int flag=0; for(int i=1;i&lt;=t;i++)&#123; int num; scanf("%d",&amp;num); for(int j=1;j&lt;=num;j++)&#123; int tmp; scanf("%d",&amp;tmp); team[tmp]=i; &#125; &#125; while(cin&gt;&gt;s)&#123; if(s=="STOP")&#123; printf("\n"); break; &#125; if(s=="ENQUEUE")&#123; int num; scanf("%d",&amp;num); if(tque[team[num]].empty())&#123; mque.push(team[num]); tque[team[num]].push(num); &#125; else tque[team[num]].push(num); &#125; if(s=="DEQUEUE")&#123; if(flag==0)&#123; printf("Scenario #%d\n",cnt); flag=1; &#125; while(tque[mque.front()].empty())&#123; mque.pop(); &#125; printf("%d\n",tque[mque.front()].front()); tque[mque.front()].pop(); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>基础数据结构</category>
        <category>队列</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[洛谷UVA1330]City Game]]></title>
    <url>%2F2018%2F08%2F05%2F%5B%E6%B4%9B%E8%B0%B7UVA1330%5DCity%20Game%2F</url>
    <content type="text"><![CDATA[题目题目描述Bob爱上了一个策略游戏（Simcity？）游戏中一个城市由k个地区组成，每个地区都是一块长N×宽M大小的网格矩形,其中可能有些网格已被占用，用R表示;有些则是空地，用F表示。 游戏中可以在空着的空间上建一个矩形的建筑，同时每个建筑按它所占的空地网格数来收租，每占用一个网格可收租金3美元。Bob想知道每个地区中最大面积建筑物能收多少租金。 输入格式第一行是地区个数k。然后接下给出k个地区的相关信息。 相关信息用以下方式输入： 第一行有两个整数n,m (n,m&lt;= 1000),表示这个地区长n宽m 然后接下来有n行，每行m个字符表示网格的信息，相邻的两个用空格隔开。R表示该网格被占用；F表示该网格是空地，可使用。 输出格式对于每一个地区，输出一行一个整数表示该地区中最大面积建筑物能收到的租金。 注意POJ dicuss中有人反映数据输出可能不严格按照要求（例如：两个字符间有多个空格），建议使用cin等读入。 感谢@Rye_Catcher 提供的翻译 英文题面输入样例12345678910111213141516171833 3R R FF F FF R F5 6R F F F F FF R F F F FF F R F F FF F F R F FF F F F R R4 5R R R R RR R F R RR R R R RR R F R R 输出样例1239273 题解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int n,m,ans;int city[1001][1001];int solve(int r)&#123; int s[1002],len[1002],p=0,ans=0; city[n+1][r]=0; for(int i=1;i&lt;=n+1;i++)&#123; if(city[i][r]&gt;s[p])s[++p]=city[i][r],len[p]=1; else &#123; int lenth=0; while(s[p]&gt;city[i][r])&#123; lenth+=len[p]; ans=max(ans,lenth*s[p]); p--; &#125; if(city[i][r])s[++p]=city[i][r],len[p]=lenth+1; &#125; &#125; return ans;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; ans=0; memset(city,0,sizeof(city)); scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; int last=0; for(int j=1;j&lt;=m;j++)&#123; char op; cin&gt;&gt;op; if(op=='R')&#123; for(int k=last+1;k&lt;j;k++)city[i][k]=j-k; last=j; &#125; else if(j==m)&#123; for(int k=last+1;k&lt;=j;k++)city[i][k]=j-k+1; &#125; &#125; &#125; for(int i=1;i&lt;=m;i++)&#123; ans=max(ans,solve(i)); &#125; cout&lt;&lt;ans*3&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>基础数据结构</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1312]Mayan游戏]]></title>
    <url>%2F2018%2F08%2F04%2F%5B%E6%B4%9B%E8%B0%B7P1312%5DMayan%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题目题目描述Mayan puzzle是最近流行起来的一个游戏。游戏界面是一个 7 行 ×5 列的棋盘，上面堆放着一些方块，方块不能悬空堆放，即方块必须放在最下面一行，或者放在其他方块之上。游戏通关是指在规定的步数内消除所有的方块，消除方块的规则如下： 1 、每步移动可以且仅可以沿横向（即向左或向右）拖动某一方块一格：当拖动这一方块时，如果拖动后到达的位置（以下称目标位置）也有方块，那么这两个方块将交换位置（参见输入输出样例说明中的图 6 到图 7 ）；如果目标位置上没有方块，那么被拖动的方块将从原来的竖列中抽出，并从目标位置上掉落（直到不悬空，参见下面图1 和图2）；2 、任一时刻，如果在一横行或者竖列上有连续三个或者三个以上相同颜色的方块，则它们将立即被消除（参见图1 到图3）。注意： a) 如果同时有多组方块满足消除条件，几组方块会同时被消除（例如下面图 4 ，三个颜色为 1 的方块和三个颜色为 2 的方块会同时被消除，最后剩下一个颜色为 2 的方块）。 b) 当出现行和列都满足消除条件且行列共享某个方块时，行和列上满足消除条件的所有方块会被同时消除（例如下面图5 所示的情形，5 个方块会同时被消除）。 3 、方块消除之后，消除位置之上的方块将掉落，掉落后可能会引起新的方块消除。注意：掉落的过程中将不会有方块的消除。 上面图1 到图 3 给出了在棋盘上移动一块方块之后棋盘的变化。棋盘的左下角方块的坐标为（0, 0 ），将位于（3, 3 ）的方块向左移动之后，游戏界面从图 1 变成图 2 所示的状态，此时在一竖列上有连续三块颜色为4 的方块，满足消除条件，消除连续3 块颜色为4 的方块后，上方的颜色为3 的方块掉落，形成图 3 所示的局面。 输入格式共 6 行。 第一行为一个正整数 n，表示要求游戏通关的步数。 接下来的 5行，描述7×5 的游戏界面。每行若干个整数，每两个整数之间用一个空格隔开，每行以一个 0 结束，自下向上表示每竖列方块的颜色编号（颜色不多于 10 种，从 1 开始顺序编号，相同数字表示相同颜色）。 输入数据保证初始棋盘中没有可以消除的方块。 输出格式如果有解决方案，输出 n 行，每行包含 3 个整数 x,y,g，表示一次移动，每两个整数之间用一个空格隔开，其中 (x ,y)表示要移动的方块的坐标， g 表示移动的方向， 1 表示向右移动， −1 表示向左移动。注意：多组解时，按照 x 为第一关健字， y 为第二关健字， 1 优先于 −1 ，给出一组字典序最小的解。游戏界面左下角的坐标为 (0 ,0) 。 如果没有解决方案，输出一行，包含一个整数 -1 。 样例输入12345631 02 1 02 3 4 03 1 02 4 3 4 0 样例输出1232 1 13 1 13 0 1 说明【输入输出样例说明】 按箭头方向的顺序分别为图 6 到图 11样例输入的游戏局面如上面第一个图片所示，依次移动的三步是：(2,1) 处的方格向右移动，(3,1) 处的方格向右移动,(3,0)处的方格向右移动，最后可以将棋盘上所有方块消除。 【数据范围】 对于 30% 的数据，初始棋盘上的方块都在棋盘的最下面一行； 对于 100% 的数据，0&lt;n≤5。 noip2011提高组day1第3题 题解代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;stack&gt;#define scanf scanf_susing namespace std;int a[5][7],tag[5][7],cnt[10];int n;struct Node&#123; int x,y,z;&#125;;stack&lt;Node&gt;ans;bool emp(void)&#123; for(int i=0;i&lt;5;++i) for(int j=0;j&lt;7;++j) if(a[i][j])return 0; return 1;&#125;void drop(int x,int y)&#123; int p=y-1; while(p&gt;=0&amp;&amp;!a[x][p])--p; swap(a[x][y],a[x][p+1]);&#125;bool check()&#123;//消去 memset(tag,0,sizeof(tag));//先把要消的标记起来，不能直接删除 bool flag=0;//有没有消去 for(int i=0;i&lt;5;i++)&#123; for(int j=0;j&lt;7;j++)&#123; if(!a[i][j])continue; if(i+2&lt;5&amp;&amp;a[i][j]==a[i+1][j]&amp;&amp;a[i+1][j]==a[i+2][j])//横着消 tag[i][j]=tag[i+1][j]=tag[i+2][j]=1; if(j+2&lt;7&amp;&amp;a[i][j]==a[i][j+1]&amp;&amp;a[i][j+1]==a[i][j+2])//竖着消 tag[i][j]=tag[i][j+1]=tag[i][j+2]=1; &#125; &#125; for(int i=0;i&lt;5;++i)//消除 for(int j=0;j&lt;7;++j) if(tag[i][j])&#123; flag=1; a[i][j]=0; &#125; for(int i=0;i&lt;5;++i)//下落 for(int j=1;j&lt;7;++j) if(a[i][j]&amp;&amp;(!a[i][j-1])) drop(i,j); return flag;&#125;void move(int x,int y,int z)&#123;//移动 int nx=x+z,ny=y; swap(a[x][y],a[nx][ny]); drop(nx,ny); while(++y&lt;7&amp;&amp;a[x][y])drop(x,y); while(check());&#125;bool dfs(int p)&#123; int tmp[5][7]; bool ok=emp(); if(ok&amp;&amp;p==n+1)return 1; else if(ok||p==n+1)return 0; memcpy(tmp,a,sizeof(a)); for(int i=0;i&lt;5;i++)&#123; for(int j=0;j&lt;7;j++)&#123; if(a[i][j])&#123; if(i!=4&amp;&amp;a[i][j]!=a[i+1][j])&#123;//不在最右边并且和右边的颜色不同 move(i,j,1); if(dfs(p+1))&#123; Node o=&#123;i,j,1&#125;; ans.push(o); return 1; &#125; memcpy(a,tmp,sizeof(a));//回溯 &#125; if(i!=0&amp;&amp;a[i][j]!=a[i-1][j]&amp;&amp;a[i-1][j]==0)&#123; move(i,j,-1); if(dfs(p+1))&#123; Node o=&#123;i,j,-1&#125;; ans.push(o); return 1; &#125; memcpy(a,tmp,sizeof(a)); &#125; &#125; &#125; &#125; return 0;&#125;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;5;i++)&#123; int b=1; int cnt=0; while(b!=0)&#123; scanf("%d",&amp;b); a[i][cnt++]=b; &#125; &#125; check(); dfs(1); Node t; int cnt=0; if(ans.empty())cout&lt;&lt;"-1"; while(!ans.empty())&#123; t=ans.top(); ans.pop(); printf("%d %d %d\n",t.x,t.y,t.z); &#125; return 0;&#125;]]></content>
      <categories>
        <category>搜索</category>
        <category>深度优先搜索</category>
      </categories>
      <tags>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ4195][Noi2015]程序自动分析]]></title>
    <url>%2F2018%2F08%2F04%2F%5BBZOJ4195%5D%5BNoi2015%5D%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[题目题目描述在实现程序自动分析的过程中,常常需要判定一些约束条件是否能被同时满足。 考虑一个约束满足问题的简化版本：假设x1,x2,x3,…代表程序中出现的变量，给定n个形如xi=xj或xi≠xj的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：x1=x2，x2=x3，x3=x4，x1≠x4，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。现在给出一些约束满足问题，请分别对它们进行判定。 输入格式输入文件的第1行包含1个正整数t，表示需要判定的问题个数。注意这些问题之间是相互独立的。 对于每个问题，包含若干行：第1行包含1个正整数n，表示该问题中需要被满足的约束条件个数。接下来n行，每行包括3个整数i,j,e，描述1个相等/不等的约束条件，相邻整数之间用单个空格隔开。若e=1，则该约束条件为xi=xj；若e=0，则该约束条件为xi≠xj。 输出格式输出文件包括t行。 输出文件的第k行输出一个字符串“YES”或者“NO”（不包含引号，字母全部大写），“YES”表示输入中的第k个问题判定为可以被满足，“NO”表示不可被满足。 样例输入1234567221 2 11 2 021 2 12 1 1 样例输出12NOYES 说明在第一个问题中，约束条件为：x1=x2,x1≠x2。这两个约束条件互相矛盾，因此不可被同时满足。在第二个问题中，约束条件为：x1=x2,x2=x1。这两个约束条件是等价的，可以被同时满足。1≤n≤10000001≤i,j≤1000000000 题解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int t,n;const int MAXN =10000005;struct node&#123; int x,y,e;&#125;a[MAXN];int b[MAXN],c[MAXN*2],f[MAXN];int cnt=0;int tot=0;int fla;int ask(int x)&#123; return lower_bound(b+1,b+tot,x)-b;&#125;void lisan()&#123; sort(c+1,c+cnt); for(int i=1;i&lt;=cnt;i++)&#123; if(i==1||c[i]!=c[i-1])b[++tot]=c[i]; &#125;&#125;int find(int x)&#123; if(f[x]==x) return x; return f[x]=find(f[x]);&#125;bool cmp(node a,node b)&#123; return a.e&gt;b.e;&#125;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; fla=0; tot=0,cnt=0; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d%d",&amp;a[i].x,&amp;a[i].y,&amp;a[i].e); c[++cnt]=a[i].x,c[++cnt]=a[i].y; &#125; lisan(); sort(a+1,a+n+1,cmp); for(int i=1;i&lt;=tot;i++)f[i]=i; for(int i=1;i&lt;=n;i++)&#123; a[i].x=ask(a[i].x); a[i].y=ask(a[i].y); if(a[i].e)&#123; f[find(a[i].x)]=find(a[i].y); &#125; else&#123; if(find(a[i].x)==find(a[i].y))&#123; fla=1;break; &#125; &#125; &#125; if(fla) printf("NO\n"); else printf("YES\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>离散化</tag>
        <tag>并查集</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[poj2559]Largest Rectangle in a Histogram]]></title>
    <url>%2F2018%2F08%2F04%2F%5Bpoj2559%5DLargest%20Rectangle%20in%20a%20Histogram%2F</url>
    <content type="text"><![CDATA[题目题目描述A histogram is a polygon composed of a sequence of rectangles aligned at a common base line. The rectangles have equal widths but may have different heights. For example, the figure on the left shows the histogram that consists of rectangles with the heights 2, 1, 4, 5, 1, 3, 3, measured in units where 1 is the width of the rectangles:Usually, histograms are used to represent discrete distributions, e.g., the frequencies of characters in texts. Note that the order of the rectangles, i.e., their heights, is important. Calculate the area of the largest rectangle in a histogram that is aligned at the common base line, too. The figure on the right shows the largest aligned rectangle for the depicted histogram. 输入格式The input contains several test cases. Each test case describes a histogram and starts with an integer n, denoting the number of rectangles it is composed of. You may assume that 1 &lt;= n &lt;= 100000. Then follow n integers h1, …, hn, where 0 &lt;= hi &lt;= 1000000000. These numbers denote the heights of the rectangles of the histogram in left-to-right order. The width of each rectangle is 1. A zero follows the input for the last test case. 输出格式For each test case output on a single line the area of the largest rectangle in the specified histogram. Remember that this rectangle must be aligned at the common base line. 输入样例1237 2 1 4 5 1 3 34 1000 1000 1000 10000 输出样例1284000 题解 部分内容来自李煜东所著《算法竞赛进阶指南》 如果说这道题矩形的高度是递增的，估计就是一道普及难度的题了吧。我们可以尝试以每个矩形的高度作为最终矩形的高度，并将宽度扩展到右边界，答案取最大值。 简单归简单，不过这也给了我们一个启发，如果是递增的我们就放着不管，以后来处理。如果说下一个高度更小，那么用它所构成的矩形的高度不可能超过它自己，而后面的矩形想要和前面的矩形拼接的话，高度也不能超过它。这样子的话，我们就可以用上面的方法更新比当前矩形高的矩形的答案再将它们合并。 这就是单调栈算法，时间复杂度 $ O(N) $借助单调性处理问题的思想在于及时排除不可能的选项，保持策略集合的高度有效性和秩序性 就这拿道题举例，我们建立一个栈，用来保存若干个矩形，这些矩形的高度是单调递增的，或者说，我们期望他是单调递增的。我们从左到右读入矩形：如果当前矩形比栈顶矩形高，即满足单调递增，进栈。否则不断去除栈顶，直至栈空或栈顶高度低于当前矩形。在此过程中，我们累计被弹出的矩形的宽度和（用于计算答案与合并），用高度×累计宽度更新答案。而后，将一个宽度为累计宽度，高度为当前矩形的矩形入栈。结束，将剩余矩形弹出，和上面一样更新答案； 代码12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt; #include&lt;algorithm&gt;using namespace std;int n,p;int a[100010];int s[100010],w[100010];long long ans;int main()&#123; while(cin&gt;&gt;n&amp;&amp;n) &#123; ans=0; p=0; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); a[n+1]=0; for(int i=1;i&lt;=n+1;i++) &#123; if(a[i]&gt;s[p]) s[++p]=a[i],w[p]=1; else&#123; int width=0; while(s[p]&gt;a[i]) &#123; width+=w[p]; ans=max(ans,(long long)width*s[p]); p--; &#125; s[++p]=a[i],w[p]=width+1; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>基本数据结构</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宜春中学团委招新啦！！]]></title>
    <url>%2F2018%2F07%2F26%2F%E5%9B%A2%E5%A7%94%E6%8B%9B%E6%96%B0%2F</url>
    <content type="text"><![CDATA[在一众宜中学子中，有这样一群人他们是众多校园活动的策划者，他们协助宜春中学各个社团管理社团事务，他们能带着小牌子穿梭于各项活动，他们常年以学生身份出现于行政楼、科技楼之中他们是谁！ ——宜春中学团委学生干部可爱的新高一学弟学妹们：加入朝气蓬勃的宜春中学团委吧！在这里，你能培养、锻炼管理能力、组织能力、应变能力；在这里，你能得到展现自我，提升自我的机会；在这里，你能感受到组织浓浓的凝聚力；在这里，你能参与组织诗歌朗诵大赛，大型校园义卖，主持人大赛等等精彩的活动；在这里，你能第一时间了解各大活动的第一消息，观看各种精彩活动；在这里，有不定时聚餐，下乡活动等诸多福利在这里，还有高颜值高智商高情商的学长学姐做你们的师父手把手带你成长带你飞！ 你还在等什么？加入我们，就是最好的选择！ 让我们一起飞上天，与太阳肩并肩！让我们策马扬鞭，青春年华一起成长！ 报名安排：8月21、22日下午教学楼旁边摆摊8月23日晚自习初试（具体时间地点另行通知）8月24日晚自习复试（具体时间地点另行通知） 另附： 关注我们 Q&amp;A你可以通过QQ，微信，微博，评论等方式向我们提出问题，这里将集中公示大家的疑问，方便查询。 Q：团委是社团还是什么？A：中国共产主义青年团委员会的简称是团委，是中国共青团的组织之一，是广大青年在实践中学习中国特色社会主义和共产主义的学校，是中国共产党的助手和后备军。 总而言之不是社团是一个组织。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ISLAND一周目通关感想]]></title>
    <url>%2F2018%2F07%2F26%2FISLAND%E4%B8%80%E5%91%A8%E7%9B%AE%E9%80%9A%E5%85%B3%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[可能包含严重剧透本来有很多游戏内部短片可以通过B站外链嵌入这里的，但奈何全被封了 序言这里要先感谢夜鸮的树洞汉化组带来的汉化，真的是很棒了，ISLAND最近也会上架steam，到时候会补票。本来是在同学的推荐下看了一集ISLAND，一开始我是抵触的，后面发现凛音的人设不错，声优是田村大魔王，于是就打算试试游戏。然后就被震撼到了，不亏是岛学，那种给人带来的沉浸感，是其他galgame难以做到了。 接下来会从流程，人物等方面展开讨论ISLAND 虽说在暑假，但是时间比较少（网上大佬二周目用了80个小时），所以夏莲和纱罗线基本是跳着过的，所以流程的话就会少掉夏莲和纱罗线。 序言就写这么多，要不然就要变成后记了233 流程序章有这样一个传说，传说的主人公叫切那，他爱着一个女性，女性的名字叫凛音，凛音也不为人知的爱着切那，但是他们二人有着永远无法结合的命运，因为他们是兄妹，有一个叫夏莲的女孩子对这二人的关系感到不高兴，因为夏莲也爱上了切那，于是她请求魔女无论怎样也要分离二人，于是魔女向二人下了诅咒，魔女把凛音的脸变成谁也不会爱上的怪物的模样，承受如此痛苦的凛音，自己结束了生命，被留下孤身一人的切那，切那也被放逐了，切那与魔女进行了契约，魔女约定，凛音会在这个世界再次重生，然后，二人结合之时诅咒将会解除。但是需要几十年，甚至几百年，并没有和魔女约定好。切那为了停止自己的时间而在冰中沉眠，为了等待着那一天的到来。浦岛上的人信奉这一个传说，并时不时的用传说中的人名给自己的孩子命名，浦岛上的御三家，御原家，珈蓝堂家，枢都家，就是贯彻这一传统的家庭，时至1999年8月，一名男子被冲上浦岛的沙滩，男子被警察发现后，因为枢都镇长的要求，准备将其遣返本土，这是男子在船上邂逅了镇长的女儿枢都夏莲，在逃跑时在海滩上遇见了御原凛音，而凛音收留了他，并给他取了三千界切那这个名字，这场旅行正式拉开了序幕。 然而没那么简单orz 夏篇 注：Flowchart中，白色描边灰点代表一节（可能有分支也可能没有），黑色点代表BE，蓝色点代表下一章，灰色无描边点代表No retrun,橙色点代表除了BE的其他结局 夏篇才是ISLAND里面最像一个galgame的地方，你有三条路（虽然凛音线是被锁住的），三个女主对你似乎都有好感。它同时也是ISLAND埋伏笔的地方。游戏一开始就将你引入到男主是从未来来的误区，也让玩家以为切那就是凛音5年前遇到的切那。（结果都不是）在夏篇中就已经提到切那是为了拯救人而“回到过去”，做法是“杀死切那”。而要拯救的那个人就是凛音（吗？）但是这样是说不通的，有一个cg是切那脑中闪过的模糊的凛音穿婚纱的样子，对象肯定是切那（切那视角） 总之，打完夏篇，你要在意的是：1.凛音没有患煤纹病。2.凛音说她也是时空旅行者。3.BE未来预想图只是切那的脑补。4.夏莲和纱罗线和主线有着关系，要认真打（虽然我是跳着打的orz）。5.凛音的房间很整洁。6.浦岛太郎和玉手箱。 夏莲篇不过多介绍，但是这里出现了一个之后对主线有着重要作用的人——桃香。 纱罗篇需要在意地方：1.玖音的房间很乱。2.纱罗的母亲万里爱。3.少儿不宜的全年龄向内容（下面是玖音说的） 凛音篇这篇前面在发糖，后面就很难受，概括来讲就是： 岛上盛行一种疾病——煤纹病。凛音表面是很害怕自己也得煤纹病，所以一直闭门不出，但真实原因是因为害怕自己和传说中的凛音一样，所以凛音也将setsuna当成了真正的切那，二人相爱了。但是在纱罗的推理下，认为这个世界存在平行世界，他们认为setsuna为了拯救凛音重复了无数次，推理的结果是凛音认为眼前的setsuna杀掉了五年前的切那，于是自己到达了暴龙岛，想要杀掉5年前的凛音。但是这是不可能的，其实并没有平行宇宙这种事情，setsuna也追随到了暴龙岛，最后二人和解，二人坐着一条船回来的时候，切那因为脱力沉入海中，而凛音为了救他丧命。而后，setsuna登上了冷冻睡眠装置，打算到了造出时间机器的年代，乘坐时间机器拯救凛音。 是不是很晕呐233， 重回标题，标题变为never island 冬篇冬篇才是这个游戏最最最最最最最最最最最最最最最最最最最最1while(1)printf("最"); 厉害的地方，本在是为了凛音而来，却喜欢上了Rinne（这里指的是我） 下面为了输入方便，会把片假名直接打成英文字母，如リンネ=Rinne 概括来讲就是：20000年后，切那再次醒来发现自己身处雪原，有一个年幼的女孩救了昏迷的自己，模糊的样子让人容易想起谁。女孩的名字叫Rinne（Rinne，这里用的是片假名，夏篇的那个凛音用的是平假名），他们生活在一个叫IslandEurasia的避难所，生活的很艰难，Rinne很不会整理东西，不但自己房间很乱，还把之前哥哥的房间当成杂货间，setsuna在这里找到了工作，拿到了Rinne哥哥的名环，作为setsunaOhara在这个避难所生活。 但是因为有很多孩子没有名环，所以有暗势力组织暴动，KarenKruz就是他们的老大。setsuna作为反叛军和教会的纽带，也想让教会理解没有名环的孩子的痛苦，但因为这样，想要让大家和平生活的SarahGarland被当做魔女烧死了， KarenKruz也因为被太阳照射而病发煤纹病，去医院的时候带上了Rinne的名环最后只剩下setsuna和Rinne两个人在山洞中过活，可好景不长，食物越来越少，两人渐渐撑不下去了，有一天setsuna到island外的雪地里发现了冷冻睡眠装置，那是自己乘坐的那一个。 “重要的东西原来近在咫尺啊”setsuna意识到自己真正要拯救的人是眼前的Rinne，他很坚定的告诉Rinne自己一定要回到他们相遇的时候，杀死自己，来拯救Rinne，Rinne最后只能妥协，setsuna把自己的名环当做戒指交给了Rinne，但是Rinne却把时间设定在了1999年——切那的时代。 真夏篇真夏篇揭露了煤纹病其实是伴X显性遗传病，分急性和非急性。setsuna再次在浦岛醒来，他明白了自己究竟该拯救谁，就像开挂一样的快速培养自己与身边的人的关系，完成了在夏篇中没能够做到的很多事。 关于凛音END他对玖音表达了自己想让凛音幸福，玖音幸福地答应了,想要让setsuna给凛音幸福setsuna和凛音的关系发展得很顺利，大家都在为他们祝福，就在这样一个环境下，setsuna与凛音步入了婚姻的殿堂 关于re：END他对玖音表达了自己想让Rinne幸福，但是，自己却将玖音惹火了，玖音质问他，当自己生下凛音的时候他在哪里，自己和凛音这么多年来是怎么熬过来的，setsuna完全不知道，就这样，玖音跑走了。setsuna在小镇上遇到了纱罗的母亲万里爱，她把setsuna来岛上的一切都告诉了他: 在浦岛上有御三家，御原家，枢都家，伽蓝堂家。在御原家有一个没有名字，不知道出身的女孩子，大家都叫她「小空」，同时御原家也有一个小婴儿——凛音，凛音实际上是小空的亲生女儿，但是却寄养在御原家中，御原家的女主人御原玖音对凛音和小空太过亲近，而感到非常不高兴，不久就开始了对她们的虐待，随后在1988年的夏天，凛音在海边的断崖上坠落，三天后漂流到了附近的海滨，而在一个月后，御原玖音的遗体在本土的港口被发现了，后来小空被迫只得冒充御原玖音生活。而凛音被发现时，有一个男孩子在海滩上救了她，男孩是御原切那，御原家的长子，之后凛音就和切那成了好友，切那自己一个人住在海滨的小屋里，和凛音一起抓虫子，辅导数学题目，直到1993年，凛音想要给切那过生日的时候，脚滑坠海，切那去救了她，并带凛音到了海边的小屋中，二人发生了关系，但在天亮时被父亲御原典正发现了，切那遭受了典正的一顿暴打，被扔进了海里，而后凛音被阳光下身患煤纹病的御原典正吓到了，听到了切那的呼救，跑去救切那，二人失去平衡坠入海中，一起漂流到了暴龙岛，在岛上切那为她寻找到了逃生的船，其实就是冷冻睡眠装置，于是凛音在其中被冷冻了5年，直到1998年6月才漂回浦岛，而报纸对外界宣称遭受神隐的少女回归了，2个月之后，setsuna便到了这座岛上。 似乎明白了什么的他进入玖音的房间，打算好好谈谈。门没锁，玖音就这样躺在地上睡着了， “这是追逐梦想的人的房间”setsuna知道，玖音实际上就是Rinne，setsuna坐上去的不是时空机器，而是，冷冻睡眠装置，Rinne知道了这一点，也坐上了根据蓝图开发的冷冻装置。他和Rinne所在的那个避难所，实际上是20000年前的时间，他做出了决定，打算和她一起完成他们二人的梦想，切那决定再次坐上冷冻装置，他要再次前往neverisland拯救真正应该拯救的少女。 真冬篇（序章）FW欠我一个真冬篇！！ “Rin、ne——”嘴里自然地发出了声音,那刻在记忆深处的话语,到现在还没能拯救的，最后的少女的名字 “Rin、ne！！！！”————就在那时。沙沙地踏雪的声音。“……谁？……”抬起头。映入眼帘的是，担心地看着我的那张脸。那张脸令人十分怀念。让人不禁落泪一般地惹人怜爱，“为什么……”啊，你是……“为什么你知道我的名字？”你,是——…… 人物上面的内容是不是看得云里雾里？那就对了！要想真正体验ISLAND还是要自己去玩一下啊。 御原 凛音 （おはら りんね）看上去是女主，然而确实女主的女儿2333当初就是为了凛音的人设才开始游戏的，结果冬篇最后喜欢上了Rinne。凛音一直喜欢说「因为――我也是个时间旅行者啊」,一开始以为只是为了附和setsuna，结果从某种意义上来说还真的是。这个孩子也受够了苦，从小受虐待，喜欢的人死了，记忆也是缺失的。setsuna出现后，与他玩上了过家家的游戏，setsuna不是那个御原切那，这一点凛音比谁都清楚。一开始分不清Rinne和凛音，冬篇后才发现这完全是两个人，从房间和性格各个方面都可以感受得到。 伽蓝堂 纱罗 （がらんどう さら）原以为是全作的智商担当，结果是胡乱瞎猜素质巫女。动不动就要杀了setsuna凛音篇的时候更是助攻送了凛音一程难受QAQ 不过冬篇里的Sarah还是很不错的。 枢都 夏莲 （くるつけ かれん）可以从夏莲身上看到自己的影子，努力地想要出岛，与父亲作对，因该是本作中最正常的女生了吧（虽然在冬篇里是靠那啥吃饭的） 三千界 刹那 （さんぜんかい せつな）我至今都没弄懂setsuna到底是哪里来的……13岁到37岁通吃，正好是冬篇Rinne的岁数和真夏篇玖音的岁数。单曲大小（&lt;=8cm） RinneOhara （リンネオハラ）/ 御原 玖音什么都不说，先唱岛歌 ランランララン～♪アイランジャ～♪戦え爱を守るため～♪今だ！合体だ！セツナ！リンネ！ 本作的灵魂，充满活力的少女特别喜欢Rinne说过的一句话：“一直呆在一起的话，就会慢慢喜欢上的吧” QAQ 我现在后悔死了 这里留白就好，要不然会写到明天。 BGM一开始觉得不是很好听，有一首还挺像《桑坦路奇亚》。直到打完后，重新听OST，才发现这是天籁😭最顶上的网易云音乐外链就是整个OST推荐第2、20、35、38首 乱七八糟想说的要说我打通的galgame，ISLAND是第一部，打完的那一天，停在标题画面久久无法释怀。完全被作者牵着鼻子走了，夏篇的时候只想着凛音却把很多伏笔漏了。凛音篇的时候总以为自己就是那个切那，能让凛音幸福，结果还是假面。冬篇的时候总想着回去救凛音，甚至对和Rinne在一起的日常感到厌烦，结果到了最后才发现自己想拯救的是Rinne而不是凛音😭一直都是这样，整个游戏下来我一直都很难受。这个游戏玩下来不但烧脑，虐心，伤眼睛，还疯狂打脸，但即便如此，我仍然觉得这是个好游戏，欠我真冬篇啦！烂人杰！哦 对，这里有一篇超厉害的伏笔回收还有这个标签什么鬼啊，性和犯罪，难道只要擦到了边算吗？还是说本来可以不加，官方为了销量故意加的？]]></content>
  </entry>
  <entry>
    <title><![CDATA[2018NOI导刊被虐记]]></title>
    <url>%2F2018%2F07%2F18%2F2018NOI%E5%AF%BC%E5%88%8A%E8%A2%AB%E8%99%90%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[序言结束以来已经过了很久了，终于有时间填坑，写这篇博客的目的就是想要保存这份回忆，无论今后怎么也好，当下才是最重要的。 过程Day0好像我是比较晚和大家在火车站集合的，为了一个舒适的路程，特意买的是高铁票（为此还放弃了直达票）路程大概是宜春-&gt;杭州-&gt;常州-&gt;嘉兴-&gt;宜春正好宜春这边有暴雨，赶紧逃！高铁上还是比较舒适的，有电有网有吃，十几个人把电脑打开，俨然一个高档网吧（误） 然而只有到杭州的那段路是这样的，后面就十分无聊了（杭州的火车站是真的大） 在杭州站捐了50元给一个关爱听障组织，一个同学还笑我，受不了。不过也确实如他所说，万一是骗子怎么办？要是我没有看过《声之形》的话我还会不会给他捐钱呢？说实话我也不清楚。 杭州-&gt;常州的那段遇到了一位日本女士，带着一对小孩（兄妹），为什么这两个小孩会这么乖啊！上车的时候被堵在车厢走廊，别的小孩都在闹，但那对兄妹也没有吵（也许是身在国外？这对小孩只会日语，但母亲会中文） 到了之后已经很晚了，于是老师带我们去吃饭，好甜，我指的是菜。。。 这7天住酒店，两个人一间房，但是因为我们这边男生个数是奇数，所以我就和另一个参加培训的常州本地学生一间房，嘛，感觉还是可以的，他也一直在玩手机，对话完了之后两个人都在做自己的事。也幸亏我和他住一间房，才知道培训的地方临时换了，通知了我们学校的人。（常州高级中学-&gt;常州外国语学校，据说前者被举报暑假补课）总之远了多，每天坐大巴一个小时好难受。 Day1早上到了常州外国语学校（私立）就觉得这学校不一般，特别气派就连机房里都装了Ubuntu（NOILinux） 正式开始上课！！上午曹文老师讲课，年纪比较大，讲了些基本算法（枚举，模拟，递推和递归），第一次发现原来基本算法也不简单。中午在学校食堂吃饭，不得不说15元一餐就是不一样，三荤一素有水果有汤，菜多的吃不完。下午的老师是堵君懿，NOI金牌（之后给我们授课的老师基本都是这种“怪物”），完全跟不上节奏，大概也是讲了些基本算法，还有点数学内容。 在和旁边同学闲聊的时候了解到他们基本是从初中开始学的，还有很多从小学开始学的，如果就按学习oi的时间来讲，我们可能他们所有人的学弟学妹吧。 还有就是在提高组的学生里面有挺多学习态度不端正的（尤其是我旁边的），交了这么多钱，结果就是下课打游戏，上课讲话，摸鱼，睡觉的态度。 晚自习后回酒店，第一次用浴缸洗澡，有点不习惯，洗完衣服就睡了，第一天实在是太累了。 Day2第二天一整天都是蔡昊源老师讲课，讲着讲着看我们觉得太难了就开始讲语文，如果觉得这两个都很难的怎么办😂。 一整天讲的都是动态规划，主要是优化，什么前缀和，矩阵乘法，四边形不等式，斜率优化，单调队列，凸包（有些是day7才讲的） 主要是晚上的考试，差点爆零，结果有两道是codeforces上的……其实我觉得这7天3次考试题目基本和讲的内容没关系。 最后一次用浴缸洗，之后就没有这么享受了。 Day3第三天讲课老师的名字忘了，总之也很厉害，一天的搜索，特别精彩。 上午是深搜和广搜，然后拓展了一下迭代加深深搜和双向广搜，然后讲了下剪枝。 下午的随机化搜索令人影响深刻，由爬山推广到模拟退火，玄的不能再玄的算法，在某些时候还真的很管用。 晚上给我们重新讲了些前些天的内容，各种数学知识orz，在这些人面前自己真的就是⑨。 Day4第四天和第五天由毕克——毕大爷（codeforces红名）给我们讲课，说实话还是挺喜欢的，就是身上很臭。这一天就是讲数据结构。 上午讲了堆，并查集，字符串hash（这东西贼神奇）。讲字符串hash的时候讲了好久关于hack的内容，明明我们NOI和NOIP用不到，但是听着很有趣。 下午讲树状数组，差分，线段树。 晚上考试很难过，有一个要求组合数的题目，结果要用一个我听都没听过的方法——逆元，还要用到费马小定理，我太弱了orz Day5上午对昨天的考试做了讲评，讲了逆元，以及 $ 方差=平方的平均数-平均数的平方 $ 然后就是乱七八糟的听不懂的东西，什么积性函数，欧拉函数，莫比乌斯函数。 下午讲了概率与期望，又是一些乱七八糟颠覆尝试的东西。比如说：如果一个房间里有23个或23个以上的人，那么至少有两个人的生日相同的概率要大于50%。 Day6后面两天都是李煜东讲课，（毕克说BZOJ网址lydsy是李煜东刷牙的意思233） 他是《算法竞赛进阶指南》的作者，可以看得出他写这本书特别用心，而且也确实很优秀，推荐！他的个人网站 这一天讲的是图论，树的直径，树的中心，图的直径，树网的核……总之还有一大堆神奇算法。 晚上考试第二题太暴力了!拉出去续一秒！ Day7这一天详细地讲了下动态规划的各种方法，讲了下昨天考试的题目。下午发了点奖品，我这种蒟蒻当然是没有的，不过我有些同学还是拿到了的李煜东的亲笔签名书晚上没有晚自习，老师带我们去川菜馆吃，然而也不是很辣。因为那个本地人今晚回家，为了省钱我就和另外两个同学一起住，打了一下cs1.6（真的是打了“一下”） 后记感觉这次培训收获到最多的东西就是很多新名词（雾）一开始还是挺兴奋的，但后面还是在三点一线的日常。从每个Day的长度就能看出来。很感谢一路走来有同学们和老师的陪伴，如果没有他们，这场培训我估计会撑不住。这次培训之后感觉自己还是有很多不懂，无论是没学过的，还是已经学过的，听这些大佬讲课，总有新的收获，但是这7天课程安排太紧，想要消化是不可能的，所以回来过后还是要多练。 NOIP2018加油！]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[2018NOI导刊]B君的病症]]></title>
    <url>%2F2018%2F07%2F17%2F%5B2018NOI%E5%AF%BC%E5%88%8A%5DB%E5%90%9B%E7%9A%84%E7%97%85%E7%97%87%2F</url>
    <content type="text"><![CDATA[题目题目描述享国之日浅，国家无事。B 君看到了 Z 君的第二题，觉得很难。 于是自己出了一个简单题。 大 A 是一名强迫症患者，现在他要给一群带颜色的珠子排成一列，现在有 n 种颜色，其中第 i 种颜色的珠子有 ai 个。要求排列中第 i 种颜色珠子的所有珠子，一定要排在第 i + 1 种颜色的第一个和最后一个珠子之间。问有多少种排列珠子的方案，因为方案数会很大，所以请输出答案对1000000007 取模之后的结果。 输入格式第一行一个整数 n。 以下 n 行，每行一个整数 ai。 输出格式一行一个整数表示答案。 输入样例12343244 输出样例1168 说明对于 100% 的数据，满足 1 ≤ n ≤ 10^4 , 2 ≤ ai ≤ 15。 对于 70% 的数据，满足 1 ≤ n ≤ 10^2。 题解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;#define MOD 1000000007#define MAXN 100001long long fact[MAXN],inv[MAXN];long long pow(long long a,long long b)&#123; long long ans=1; while(b)&#123; if(b&amp;1)ans=a*ans%MOD; a=a*a%MOD; b&gt;&gt;=1; &#125; return ans%MOD;&#125;long long c(long long m,long long n)&#123; return fact[m]*inv[n]%MOD*inv[m-n]%MOD;&#125;void pre()&#123; fact[0]=1; inv[0]=1; for(int i=1;i&lt;MAXN;i++)&#123; fact[i]=fact[i-1]*i%MOD; inv[i]=pow(fact[i],MOD-2); &#125;&#125;int main()&#123; long long x,y; pre(); cin&gt;&gt;x; long long z=1; int s=0; for(int i=1;i&lt;=x;i++)&#123; scanf("%lld",&amp;y); z=z*c(s+y-2,y-2)%MOD; s+=y; &#125; cout&lt;&lt;z; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>逆元</tag>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[poj1845]Sumdiv]]></title>
    <url>%2F2018%2F07%2F09%2F%5Bpoj1845%5DSumdiv%2F</url>
    <content type="text"><![CDATA[题目题目描述Consider two natural numbers A and B. Let S be the sum of all natural divisors of A^B. Determine S modulo 9901 (the rest of the division of S by 9901). 输入The only line contains the two natural numbers A and B, (0 &lt;= A,B &lt;= 50000000)separated by blanks. 输出The only line of the output will contain S modulo 9901. 样例输入12 3 样例输出115 提示$ 2^3 = 8. $The natural divisors of 8 are: 1,2,4,8. Their sum is 15.15 modulo 9901 is 15 (that should be output). 来源Romania OI 2002 传送门Sumdiv 题解问题分析刚一看到这个题，一股浓浓的数论感就扑面而来，求$ A^B $的约数和，暴力当然是不可取的，我们不妨换个角度如果我们把$ A $分解质因数，表示为 $$ A=p_1^(c_1)p_2^(c_2)p_3^(c_3)…p_n^(c_n) $$ 那么$ A^B $可表示为$$ A=p_1^(Bc_1)p_2^(Bc_2)p_3^(Bc_3)…p_n^(Bc_n) $$则$ A^B $所有约数和为$$ (1+p_1+p_1^2+…+p_1^(Bc_1)) $$ 质因数分解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;#define MAXN 50001const int MOD=9901;long long a,b;long long p[MAXN],c[MAXN];long long m;long long ans; long long pow(long long p,long long n)&#123; long long sq=1; while(n)&#123; if(n&amp;1)sq=(sq*p)%MOD; n&gt;&gt;=1; p=(p*p)%MOD; &#125; return sq;&#125; bool prime(int n)&#123; if(n&lt;2)return 0; for(int i=2;i&lt;=sqrt(n);i++)&#123; if(n%i==0)return 0; &#125; return 1;&#125; void divide(int n)&#123; m=0; for(int i=2;i&lt;=sqrt(n);i++)&#123; if(n%i==0&amp;&amp;prime(i))&#123; p[++m]=i,c[m]=0; while(n%i==0)n/=i,c[m]++; &#125; &#125; if(n&gt;1&amp;&amp;prime(n))p[++m]=n,c[m]=1; return;&#125; long long sum(long long p,long long c)&#123; if(c==0)return 1; if(c%2==0)return (sum(p,c/2-1)*(1+pow(p,c/2+1))+pow(p,c/2))%MOD; else return (sum(p,c/2)*(1+pow(p,c/2+1)))%MOD;&#125; void work()&#123; ans=1; for(int i=1;i&lt;=m;i++)&#123; ans=(ans*sum(p[i],c[i]*b)%MOD)%MOD; &#125;&#125; int main()&#123; cin&gt;&gt;a&gt;&gt;b; divide(a); work(); printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[poj3263]Tallest Cow]]></title>
    <url>%2F2018%2F07%2F09%2F%5Bpoj3263%5DTallest%20Cow%2F</url>
    <content type="text"><![CDATA[题目题目描述FJ’s N (1 ≤ N ≤ 10,000) cows conveniently indexed 1..N are standing in a line. Each cow has a positive integer height (which is a bit of secret). You are told only the height H (1 ≤ H ≤ 1,000,000) of the tallest cow along with the index I of that cow. FJ has made a list of R (0 ≤ R ≤ 10,000) lines of the form “cow 17 sees cow 34”. This means that cow 34 is at least as tall as cow 17, and that every cow between 17 and 34 has a height that is strictly smaller than that of cow 17. For each cow from 1..N, determine its maximum possible height, such that all of the information given is still correct. It is guaranteed that it is possible to satisfy all the constraints. 输入Line 1: Four space-separated integers: N, I, H and RLines 2..R+1: Two distinct space-separated integers A and B (1 ≤ A, B ≤ N), indicating that cow A can see cow B. 输出Lines 1..N: Line i contains the maximum possible height of cow i. 输入样例1234569 3 5 51 35 34 33 79 8 输出样例123456789545344555 来源USACO 2007 January Silver 传送门Tallest Cow 题解代码12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;map&gt;using namespace std;int d[100001];unsigned int s[100001];int n,i,h,r;int x,y;map&lt;pair&lt;int,int&gt;,bool&gt; judge; int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;i,&amp;h,&amp;r); d[1]=h; for(int i=1;i&lt;=r;i++)&#123; scanf("%d%d",&amp;x,&amp;y); if(x&gt;y)swap(x,y); if(judge[make_pair(x,y)])continue; d[x+1]--,d[y]++; judge[make_pair(x,y)]=1; &#125; for(int i=1;i&lt;=n;i++)&#123; s[i]=s[i-1]+d[i]; &#125; for(int i=1;i&lt;=n;i++)&#123; printf("%d\n",s[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2003]激光炸弹]]></title>
    <url>%2F2018%2F07%2F09%2F%5BHNOI2003%5D%E6%BF%80%E5%85%89%E7%82%B8%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[题目题目描述一种新型的激光炸弹，可以摧毁一个边长为R的正方形内的所有的目标。现在地图上有n(N&lt;=10000)个目标，用整数Xi,Yi(其值在[0,5000])表示目标在地图上的位置，每个目标都有一个价值。激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆破范围，即那个边长为R的正方形的边必须和x，y轴平行。若目标位于爆破正方形的边上，该目标将不会被摧毁。 输入输入文件的第一行为正整数n和正整数R，接下来的n行每行有3个正整数，分别表示xi,yi,vi 输出输出文件仅有一个正整数，表示一颗炸弹最多能炸掉地图上总价值为多少的目标（结果不会超过32767）。 输入样例1232 10 0 11 1 1 输出样例11 题解代码12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n,R;int a[5002][5002];int ans; int main()&#123; cin&gt;&gt;n&gt;&gt;R; for(int i=1;i&lt;=n;i++)&#123; int x,y,num; scanf("%d%d%d",&amp;x,&amp;y,&amp;num); a[y+1][x+1]=num; &#125; for(int i=1;i&lt;=5001;i++)&#123; for(int j=1;j&lt;=5001;j++)&#123; a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1]; &#125; &#125; for(int i=R;i&lt;=5001;i++)&#123; for(int j=R;j&lt;=5001;j++)&#123; int tmp=a[i][j]-a[i-R][j]-a[i][j-R]+a[i-R][j-R]; if(ans&lt;tmp)ans=tmp; &#125; &#125; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1880][NOI1995]石子合并]]></title>
    <url>%2F2018%2F07%2F05%2F%5B%E6%B4%9B%E8%B0%B7P1880%5D%5BNOI1995%5D%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[题目题目描述在一个圆形操场的四周摆放N堆石子,现要将石子有次序地合并成一堆.规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。 试设计出1个算法,计算出将N堆石子合并成1堆的最小得分和最大得分. 输入格式数据的第1行试正整数N,1≤N≤100,表示有N堆石子.第2行有N个数,分别表示每堆石子的个数. 输出格式输出共2行,第1行为最小得分,第2行为最大得分. 样例输入1244 5 9 4 样例输出124354 题解代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#define MAXN 402using namespace std;int fmin[MAXN][MAXN];int sum[MAXN];int fmax[MAXN][MAXN];int n;int main()&#123; memset(fmin,0x3f,sizeof(fmin)); memset(fmax,0,sizeof(fmax)); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; int a; scanf("%d",&amp;a); fmin[i][i]=0; fmin[i+n][i+n]=0; sum[i]=sum[i-1]+a; &#125; for(int i=1;i&lt;=n;i++)&#123; sum[i+n]=sum[n]+sum[i]; &#125; for(int len=2;len&lt;=n;len++)&#123; for(int i=1;i&lt;=n+n-len+1;i++)&#123; int j=i+len-1; for(int k=i;k&lt;j;k++)&#123; fmax[i][j]=max(fmax[i][j],fmax[i][k]+fmax[k+1][j]+sum[j]-sum[i-1]); fmin[i][j]=min(fmin[i][j],fmin[i][k]+fmin[k+1][j]+sum[j]-sum[i-1]); &#125; &#125; &#125; int minn=1&lt;&lt;30; int maxx=0; for(int i=1;i&lt;=n;i++)&#123; minn=min(minn,fmin[i][i+n-1]); maxx=max(maxx,fmax[i][i+n-1]); &#125; printf("%d\n%d",minn,maxx); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>环状dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1049]装箱问题]]></title>
    <url>%2F2018%2F07%2F04%2F%5B%E6%B4%9B%E8%B0%B7P1049%5D%E8%A3%85%E7%AE%B1%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目题目描述有一个箱子容量为 V （正整数，$ 0 &lt;= V &lt;=20000 $），同时有 n 个物品（ $ 0&lt;n&lt;=30 $ ，每个物品有一个体积（正整数）。 要求 nn 个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。注：此问题区分大小写 输入格式1 个整数，表示箱子容量 1 个整数，表示有 n 个物品 接下来 n 行，分别表示这 n 个物品的各自体积 输出格式1个整数，表示箱子剩余空间。 样例输入123456782468312797 样例输出10 来源NOIp2001普及组 第4题 题解代码1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n,v;int w[31];int f[20001];int main()&#123; scanf("%d%d",&amp;v,&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;w[i]); &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=v;j&gt;=w[i];j--)&#123; f[j]=max(f[j],f[j-w[i]]+w[i]); &#125; &#125; printf("%d",v-f[v]); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>背包</category>
      </categories>
      <tags>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1435]回文字串]]></title>
    <url>%2F2018%2F07%2F04%2F%5B%E6%B4%9B%E8%B0%B7P1435%5D%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目题目描述回文词是一种对称的字符串。任意给定一个字符串，通过插入若干字符，都可以变成回文词。此题的任务是，求出将给定字符串变成回文词所需要插入的最少字符数。 比如 “Ab3bd”插入2个字符后可以变成回文词“dAb3bAd”或“Adb3bdA”，但是插入少于2个的字符无法变成回文词。 注：此问题区分大小写 输入格式一个字符串(0&lt;strlen&lt;=1000) 输出格式有且只有一个整数，即最少插入字符数 样例输入1Ab3bd 样例输出12 来源IOI2000第一题 题解这里有个易错点，关于strlen函数的。 strlen()函数其实就是个计数器，它会从字符串开头，到终止符结束，最后返回结果。 但是，有些时候我们为了方便，会在读入字符串的时候使用scanf(“%s”,a+1)这时候，strlen(a)的返回值一定是0，因为a字符串的开头就是终止符，正确做法strlen(a+1) 代码123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;char str[5001];int n;int f[5001][5001];int main()&#123; cin&gt;&gt;str+1; n=strlen(str+1); for(int len=1;len&lt;=n;len++)&#123; for(int i=1;i&lt;=n-len+1;i++)&#123; int j=i+len-1; if(str[i]==str[j])f[i][j]=f[i+1][j-1]; else f[i][j]=min(f[i+1][j],f[i][j-1])+1; &#125; &#125; printf("%d",f[1][n]); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[hdu1114]猪猪储蓄罐]]></title>
    <url>%2F2018%2F07%2F03%2F%5BYZOJ1582%5D%E7%8C%AA%E7%8C%AA%E5%82%A8%E8%93%84%E7%BD%90%2F</url>
    <content type="text"><![CDATA[我写的是单输入版本，改一下应该不会超时 题目题目描述Before ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig. After a sufficiently long time, there should be enough cash in the piggy-bank to pay everything that needs to be paid. But there is a big problem with piggy-banks. It is not possible to determine how much money is inside. So we might break the pig into pieces only to find out that there is not enough money. Clearly, we want to avoid this unpleasant situation. The only possibility is to weigh the piggy-bank and try to guess how many coins are inside. Assume that we are able to determine the weight of the pig exactly and that we know the weights of all coins of a given currency. Then there is some minimum amount of money in the piggy-bank that we can guarantee. Your task is to find out this worst case and determine the minimum amount of cash inside the piggy-bank. We need your help. No more prematurely broken pigs! 输入格式The input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers E and F. They indicate the weight of an empty pig and of the pig filled with coins. Both weights are given in grams. No pig will weigh more than 10 kg, that means 1 &lt;= E &lt;= F &lt;= 10000. On the second line of each test case, there is an integer number N (1 &lt;= N &lt;= 500) that gives the number of various coins used in the given currency. Following this are exactly N lines, each specifying one coin type. These lines contain two integers each, Pand W (1 &lt;= P &lt;= 50000, 1 &lt;= W &lt;=10000). P is the value of the coin in monetary units, W is it’s weight in grams. 输出格式Print exactly one line of output for each test case. The line must contain the sentence “The minimum amount of money in the piggy-bank is X.” where X is the minimum amount of money that can be achieved using coins with the given total weight. If the weight cannot be reached exactly, print a line “This is impossible.”. 样例输入12345678910111213310 11021 130 5010 11021 150 301 6210 320 4 样例输出123The minimum amount of money in the piggy-bank is 60.The minimum amount of money in the piggy-bank is 100.This is impossible. 来源Central Europe 1999 题解代码12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int e,F,s;int n;int p[10001],w[10001];int f[10001];const int inf=0x3f3f3f3f;int main()&#123; scanf("%d%d",&amp;e,&amp;F); s=F-e; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d",&amp;p[i],&amp;w[i]); f[i]=inf; &#125; f[0]=0; for(int i=1;i&lt;=s;i++)f[i]=inf; for(int i=1;i&lt;=n;i++)&#123; for(int v=w[i];v&lt;=s;v++)&#123; f[v]=min(f[v],f[v-w[i]]+p[i]); &#125; &#125; if(f[s]==inf)printf("This is impossible."); else printf("The minimum amount of money in the piggy-bank is %d.",f[s]); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>背包</category>
      </categories>
      <tags>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HAOI2006]受欢迎的牛]]></title>
    <url>%2F2018%2F06%2F21%2F%5BHAOI2006%5D%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E7%89%9B%2F</url>
    <content type="text"><![CDATA[题目题目描述每一头牛的愿望就是变成一头最受欢迎的牛。现在有N头牛，给你M对整数(A,B)，表示牛A认为牛B受欢迎。 这种关系是具有传递性的，如果A认为B受欢迎，B认为C受欢迎，那么牛A也认为牛C受欢迎。你的任务是求出有多少头牛被所有的牛认为是受欢迎的。 输入第一行两个数N,M。 接下来M行，每行两个数A,B，意思是A认为B是受欢迎的（给出的信息有可能重复，即有可能出现多个A,B） 输出一个数，即有多少头牛被所有的牛认为是受欢迎的。 样例输入12343 31 22 12 3 样例输出11 提示100%的数据N&lt;=10000,M&lt;=50000 题解虽然网上有不少题解，但我觉得还是自己写下，毕竟题解这东西首先是写给自己的。 缩点 分析假如你已经完全搞懂了tarjan的话可以直接看这里。当我们把所有的强连通分量分别合并到一个点里（每次标记出栈的点，这些点就在同一个强连通分量里），不难发现，统计每一个点的出度，如果有1个点出度为0，那么这个点里的所有牛就是最受欢迎的了，其他情况则没有最受欢迎的牛，如图： tarjan算法tarjan算法用来寻找有向图的强连通分量的算法，它可以在$ O(|V|+|E|) $ 的时间内得出结果。下面内容大部分来源于这篇文章。 为了更好地理解tarjan算法是如何通过dfs来求强连通分量的，我们这里不妨先了解下搜索树。比如这是一个有向图： 而他的搜索树长这样： 从图中我们可以看到3种边（实际上有4种，但是其实第四种只要和第一种一样处理就可以了） 1.实线画出来的是树边，每次搜索找到一个还没有访问过的结点的时候就形成了一条树边。2.用长虚线画出来的是反祖边，也被叫做回边,它主要是在搜索的时候遇到了一个已经访问过的结点，而且这个结点是当前节点的祖先时形成的。3.用短虚线画出来的是横叉边，它主要是在搜索的时候遇到了一个已经访问过的结点，但是这个结点不是当前节点的祖先时形成的。 现在我们来看看在 DFS 的过程中强连通分量有什么性质。 很重要的一点是如果结点 u 是某个强连通分量在搜索树中遇到的第一个结点（这通常被称为这个强连通分量的根），那么这个强连通分量的其余结点肯定是在搜索树中以 u 为根的子树中。如果有个结点 v 在该强连通分量中但是不在以 u 为根的子树中，那么 u 到 v 的路径中肯定有一条离开子树的边。但是这样的边只可能是横叉边或者反祖边，然而这两条边都要求指向的结点已经被访问过了，这就和 u 是第一个访问的结点矛盾了。 Tarjan 算法主要是在 DFS 的过程中维护了一些信息：dfn、low 和一个栈。 栈里的元素表示的是当前已经访问过但是没有被归类到任一强连通分量的结点。 dfn[u] 表示结点 u 在 DFS 中第一次搜索到的次序，通常被叫做时间戳。 low[u] 稍微有些复杂，它表示从 u 或者以 u 为根的子树中的结点，再通过一条反祖边或者横叉边可以到达的时间戳最小的结点 v 的时间戳，并且要求 v 有一些额外的性质：v 还要能够到达 u。显然通过反祖边到达的结点 v 满足 low 的性质，但是通过横叉边到达的却不一定。可以证明，结点 u 是某个强连通分量的根等价于 dfn[u] 和 low[u] 相等。简单可以理解成当它们相等的时候就不可能从 u 通过子树再经过其它时间戳比它小的结点回到 u。 当通过 u 搜索到一个新节点 v 的时候可以有多种情况： $ 1° $ 结点 u 通过树边到达结点 v$$ low[u]=min(low[u],low[v]) $$ $ 2° $ 结点 u 通过反祖边到达结点 v，或者通过横叉边到达结点 v 并且满足 low 定义中 v 的性质$$ low[u]=min(low[u],dfn[v]) $$ 如果 dfn 和 low 相等，那么就不断退栈直到当前结点为止，这些结点就属于一个强连通分量。 至于如何更新 low，关键就在于第二种情况，当通过反祖边或者横叉边走到一个结点的时候，只需要判断这个结点是否在栈中，如果在就用它的 low 值更新当前节点的 low 值，否则就不更新。因为如果不在栈中这个结点就已经确定在某个强连通分量中了，不可能回到 u。 附：链式前向星代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;#define MAXN 50001int E[MAXN],low[MAXN],Next[MAXN],Head[MAXN],dfn[MAXN],num=0,count,out[MAXN],o,how_many[MAXN],chudu[MAXN],zhan[MAXN],top=0;bool v[MAXN],chuzhan[MAXN];void add(int x,int y,int i)&#123; E[i]=y; Next[i]=Head[x]; Head[x]=i;&#125;int find()&#123; int ans=0; for(int i=1;i&lt;=o;i++)&#123; for(int p=Head[out[i]];p;p=Next[p])&#123; if(!chuzhan[E[p]])&#123; ans++; &#125; &#125; &#125; return ans;&#125;void tarjan(int u)&#123; dfn[u]=low[u]=++num; zhan[++top]=u; v[u]=1; for(int p=Head[u];p;p=Next[p])&#123; int y=E[p]; if(!dfn[y])&#123; tarjan(y); low[u]=min(low[y],low[u]); &#125;else&#123; if(v[y])low[u]=min(low[u],dfn[y]); &#125; &#125; if(dfn[u]==low[u])&#123; int y; count++; do&#123; y=zhan[top--]; v[y]=0; out[++o]=y; chuzhan[y]=1; how_many[count]++; &#125;while(y!=u); chudu[count]=find(); o=0; memset(chuzhan,0,sizeof(chuzhan)); &#125;&#125;int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); add(x,y,i); &#125; for(int i=1;i&lt;=n;i++)&#123; if(!dfn[i])tarjan(i); &#125; int c=0,ans; for(int i=1;i&lt;=count;i++)&#123; if(!chudu[i])c++,ans=i; &#125; if(c==1)cout&lt;&lt;how_many[ans]; else cout&lt;&lt;"0"; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>图的连通</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2820]局域网]]></title>
    <url>%2F2018%2F06%2F17%2F%5B%E6%B4%9B%E8%B0%B7P2820%5D%E5%B1%80%E5%9F%9F%E7%BD%91%2F</url>
    <content type="text"><![CDATA[题目题目背景某个局域网内有n(n&lt;=100)台计算机，由于搭建局域网时工作人员的疏忽，现在局域网内的连接形成了回路，我们知道如果局域网形成回路那么数据将不停的在回路内传输，造成网络卡的现象。因为连接计算机的网线本身不同，所以有一些连线不是很畅通，我们用f(i,j)表示i,j之间连接的畅通程度，f(i,j)值越小表示i,j之间连接越通畅，f(i,j)为0表示i,j之间无网线连接。 题目描述需要解决回路问题，我们将除去一些连线，使得网络中没有回路，并且被除去网线的Σf(i,j)最大，请求出这个最大值。 输入格式第一行两个正整数n k接下来的k行每行三个正整数i j m表示i,j两台计算机之间有网线联通，通畅程度为m。 输出格式一个正整数，Σf(i,j)的最大值。 输入样例1234565 51 2 81 3 11 5 32 4 53 4 2 输出样例18 说明f(i,j)&lt;=1000 题解这里可以采用存边的方法存储图，再用克鲁斯卡尔按边求出最小生成树，把这些边标记起来，再把没有标记过的相加，这样做的好处是避免数据溢出（当然你也可以开长整型） 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;struct Tedge&#123; int from; int to; int num;&#125;edge[10001];int father[101];//并查集bool Ebook[10001];int n,k,ans;int find(int x)&#123; if(x==father[x])return x; return find(father[x]);//这里一定要有return&#125;void solve()&#123; for(int i=1;i&lt;=k;i++)&#123; int f1,f2; f1=find(edge[i].from); f2=find(edge[i].to); if(f1!=f2)&#123; father[f1]=f2; Ebook[i]=1; &#125; &#125;&#125;bool cmp(Tedge a,Tedge b)&#123; return a.num&lt;b.num;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++)father[i]=i; for(int i=1;i&lt;=k;i++)&#123; scanf("%d %d %d",&amp;edge[i].from,&amp;edge[i].to,&amp;edge[i].num); &#125; sort(edge+1,edge+k+1,cmp);//求最小生成树，边由小到大 solve(); for(int i=1;i&lt;=k;i++)if(Ebook[i]==0)ans+=edge[i].num; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>树</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1908]逆序对]]></title>
    <url>%2F2018%2F06%2F17%2F%5B%E6%B4%9B%E8%B0%B7P1908%5D%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[题目题目描述猫猫TOM和小老鼠JERRY最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。最近，TOM老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中ai&gt;aj且i&lt;j的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。 输入格式第一行，一个数n，表示序列中有n个数。第二行n个数，表示给定的序列。 输出格式给定序列中逆序对的数目。 输入样例1265 4 2 6 3 1 输出样例111 说明对于50%的数据，n≤2500对于100%的数据，n≤40000。 题解树状数组既然名字都叫树状数组，那么肯定是和数有关的咯，我们来先看一个二叉树 我们来稍微变下形 现在我们把树状数组c[]摆放到每一列的顶端 C[i]代表子树的叶子结点的权值之和我们通过这张图可以知道$$ C[1]=A[1]; $$$$ C[2]=A[1]+A[2]; $$$$ C[3]=A[3]; $$$$ C[4]=A[1]+A[2]+A[3]+A[4]; $$$$ C[5]=A[5]; $$$$ C[6]=A[5]+A[6]; $$$$ C[7]=A[7]; $$$$ C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8]; $$通过分情况讨论好像是有什么规律，那有没有更一般的规律呢？我们不妨将树状数组的编号转换成二进制看看$$ 1=(001)—C[1]=A[1]; $$$$ 2=(010)—C[2]=A[1]+A[2]; $$$$ 3=(011)—C[3]=A[3]; $$$$ 4=(100)—C[4]=A[1]+A[2]+A[3]+A[4]; $$$$ 5=(101)—C[5]=A[5]; $$$$ 6=(110)—C[6]=A[5]+A[6]; $$$$ 7=(111)—C[7]=A[7]; $$$$ 8=(1000)—C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8]; $$ 对照式子可以发现 C[i]=A[i-2^k+1]+A[i-2^k+2]+……A[i]; （k为i的二进制中从最低位到高位连续零的长度）例如i=8时，k=3。 而lowbit(x)函数的作用就是取出x的最低位。 树状数组的优点在于单点更新以及区间查询，对于求逆序对来说，知道一个数的位置x，那么1~x范围内就是比它小的数，而用已经插入的数的个数减去这个数，累加起来就是我们要算的逆序对数。 离散化上面提到我们要知道一个数的位置，可以用树状数组下标来表示$ c[x] $，但整型范围很大,不可能开这么大的数组，所以我们只需要保留它们的相对大小，用离散化处理。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define MAXN 100001using namespace std;int n;struct node&#123; int num,index;&#125;a[MAXN];int c[MAXN];//树状数组int A[MAXN];//离散化后的数组int low_bit(int i)&#123; return i&amp;(-i);&#125;void update(int i,int v)//插入&#123; while(i&lt;=n)&#123; c[i]+=v; i+=low_bit(i); &#125;&#125;int get_sum(int i)//区间查找&#123; int res=0; while(i)&#123; res+=c[i]; i-=low_bit(i); &#125; return res;&#125;bool cmp(node a,node b) &#123; return a.num&lt;b.num; &#125; int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i].num); a[i].index=i; &#125; sort(a+1,a+1+n,cmp); int p=0; for(int i=1;i&lt;=n;i++)&#123; /*if(a[i].num!=a[i-1].num)p++; A[a[i].index]=p;*///如果数据中存在重复数据才需要 A[a[i].index]=i;//离散化 &#125; long long ans=0; for(int i=1;i&lt;=n;i++)&#123; update(A[i],1);//插入 ans+=i-get_sum(A[i]); &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POJ-3264] Balanced Lineup]]></title>
    <url>%2F2018%2F06%2F16%2F%5BPOJ-3264%5D%20Balanced%20Lineup%2F</url>
    <content type="text"><![CDATA[注：数据改编自原题，输入输出略有不同 题目题目描述For the daily milking, Farmer John’s N cows (1 ≤ N ≤ 50,000) always line up in the same order. One day Farmer John decides to organize a game of Ultimate Frisbee with some of the cows. To keep things simple, he will take a contiguous range of cows from the milking lineup to play the game. However, for all the cows to have fun they should not differ too much in height. Farmer John has made a list of Q (1 ≤ Q ≤ 200,000) potential groups of cows and their heights (1 ≤ height ≤ 1,000,000). For each group, he wants your help to determine the difference in height between the shortest and the tallest cow in the group. 输入Line 1: Two space-separated integers, N and Q.Lines 2..N+1: Line i+1 contains a single integer that is the height of cow iLines N+2..N+Q+1: Two integers A and B (1 ≤ A ≤ B ≤ N), representing the range of cows from A to B inclusive. 输出Lines 1..Q: Each line contains a single integer that is a response to a reply and indicates the difference in height between the tallest and shortest cow in the range. 样例输入123456789106 31734251 54 62 2 样例输出123630 题解ST表代码1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;#define MAXN 50001int n,q;int stmin[MAXN][20];int stmax[MAXN][20];void pre_work()&#123; for(int j = 1; j &lt; 20; ++j) for(int i = 1; i &lt;= n; ++i) if(i + (1 &lt;&lt; j) - 1 &lt;= n)&#123; stmax[i][j] = max(stmax[i][j-1], stmax[i + (1 &lt;&lt; (j - 1))][j - 1]); stmin[i][j] = min(stmin[i][j-1], stmin[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++)&#123; scanf("%d", &amp;stmin[i][0]); stmax[i][0]=stmin[i][0]; &#125; pre_work(); for(int i=1;i&lt;=q;i++)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); int k=(int)(log(y - x + 1.0) / log(2.0)); int maxsum = max(stmax[x][k], stmax[y - (1 &lt;&lt; k) + 1][k]); int minsum = min(stmin[x][k], stmin[y - (1 &lt;&lt; k) + 1][k]); printf("%d\n",maxsum-minsum); &#125; return 0;&#125; 线段树代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;#define MAXN 50001int n,q;struct Ttree&#123; int maxdata,mindata;&#125;t[MAXN*4],tmp0;void push_up(int l,int r,int k)&#123; t[k].maxdata=max(t[k*2].maxdata,t[k*2+1].maxdata); t[k].mindata=min(t[k*2].mindata,t[k*2+1].mindata);&#125;void make(int l,int r,int k)&#123; if(l==r)&#123; scanf("%d",&amp;t[k].maxdata); t[k].mindata=t[k].maxdata; return; &#125; int mid=(l+r)/2; make(l,mid,k*2); make(mid+1,r,k*2+1); push_up(l,r,k); return;&#125;Ttree ask(int L,int R,int l,int r,int k)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)return t[k]; int mid=(l+r)/2; Ttree res1; if(L&lt;=mid)res1=ask(L,R,l,mid,k*2); else res1=tmp0; Ttree res2; if(R&gt;mid)res2=ask(L,R,mid+1,r,k*2+1); else res2=tmp0; Ttree res=&#123;0&#125;; res.maxdata=max(res1.maxdata,res2.maxdata); res.mindata=min(res1.mindata,res2.mindata); return res;&#125;int main()&#123; tmp0.maxdata=-1e9,tmp0.mindata=1e9; scanf("%d%d",&amp;n,&amp;q); make(1,n,1); for(int i=1;i&lt;=q;i++)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); Ttree ans; ans=ask(x,y,1,n,1); printf("%d\n",ans.maxdata-ans.mindata); &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>树</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Spoj GSS3]Can you answer these queries III]]></title>
    <url>%2F2018%2F06%2F15%2F%5BSpoj%20GSS3%5DCan%20you%20answer%20these%20queries%20III%2F</url>
    <content type="text"><![CDATA[题目题目描述给定长度为N的数列A，以及M条指令 (N≤500000, M≤100000)，每条指令可能是以下两种之一：“2 x y”，把 A[x] 改成 y。“1 x y”，查询区间 [x,y] 中的最大连续子段和，即 max(x≤l≤r≤y)⁡ { ∑(i=l~r) A[i] }。对于每个询问，输出一个整数表示答案。 输入第一行两个整数N,M 第二行N个整数Ai 接下来M行每行3个整数k,x,y，k=1表示查询（此时如果x&gt;y，请交换x,y），k=2表示修改 输出对于每个询问输出一个整数表示答案。 样例输入123455 31 2 -3 4 51 2 32 2 -11 3 2 样例输出122-1 提示数据范围与约定 对于100%的数据: N≤500000, M≤100000, |Ai|&lt;=1000 题解树存储空间大小这道题与原题略微有点区别，数据输入顺序不一样，以及范围更大了，但是稍微改一下就可以过了。第一个问题，为什么树要开到4*N？首先，我们构造的线段树有可能是完全二叉树（最好情况），叶子节点存储的就是我们每一个点的数据，而我们可以分析下完全二叉树的图。不难发现，我们设节点有n个，那么二叉树的层数为$ log_2(n+1) $而设叶子节点有k个，那么就得到一个k与n的关系：$ k(1-(1/2)^n)=2n $n随k的变化关系曲线为当k趋于无穷大，$ n=2k $ 而对于最坏情况，请参见这篇文章对于最坏的情况我们要开4n的空间来存储。 树存储方式第二个问题，我们要存树，这里可以开一个结构体，里面有四个变量| 变量名称 | 变量作用 ||-|:-:|-|| data | 储存该区间内的最大连续子段和 || ldata | 储存该区间从左端开始的最大和 || rdata | 储存该区间从右端开始的最大和 || sum | 储存该区间内的所有数的和 |这些就够了，不必纪录左子树和右子树。 建树对于每个叶子节点（r==l），我们给他们赋值，而其他节点我们就需要来分析情况了。 sum的值sum的值还用说吗，就是左子树的sum+右子树的sum data的值data是该区间内的最大连续子段和，所以对于data就有几种可能，而我们要做的就是取最大的：1.data=左子树data2.data=右子树data3.data=左子树rdata+右子树ldata ldata和rdata的值ldata储存该区间从左端开始的最大和，所以：1.ldata=左子树ldata2.ldata=左子树sum+右子树rdatardata同理 改变值改变值其实就是建树，只不过因为只改变一个值，所以分治时要么是左子树，要么是右子树，改变完后要注意重新维护其他点的值。 查询值查询值较为复杂，但我们也可以把它看成一个建树的过程。首先，对于我们要查询的范围，如果这个范围大于等于我们分治下去的范围，那么就返回这个范围的值。（实际上就是我们建树时存在这个范围的点）如果这个范围没有点满足，那么我们可以用叶子节点建树来建成我们想要的范围的点。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;#define MAXN 500000struct Ttree&#123; int data; int ldata,rdata; int sum; &#125;t[MAXN*4],tmp0;int n,m;void push_up(int l,int r,int k)&#123; t[k].sum=t[k*2].sum+t[k*2+1].sum; t[k].data=max(t[k*2].data,t[k*2+1].data); t[k].data=max(t[k*2].rdata+t[k*2+1].ldata,t[k].data); t[k].ldata=max(t[k*2].ldata,t[k*2].sum+t[k*2+1].ldata); t[k].rdata=max(t[k*2+1].rdata,t[k*2+1].sum+t[k*2].rdata); return;&#125;void make(int l,int r,int k)&#123; if(l==r)&#123; scanf("%d",&amp;t[k].data); t[k].ldata=t[k].rdata=t[k].sum=t[k].data; return; &#125; int mid=(l+r)/2; make(l,mid,k*2); make(mid+1,r,k*2+1); push_up(l,r,k); return;&#125;Ttree ask(int L,int R,int l,int r,int k)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)return t[k]; int mid=(l+r)/2; Ttree res1; if(L&lt;=mid)res1=ask(L,R,l,mid,k*2); else res1=tmp0;/*目前分治的点的左子树不包含要查询的左端范围，不参与建树，tmp0初始化很小，在取最大值的时候含有它的情况会被忽略掉，但是tmp0.sum初始化还是0*/ Ttree res2; if(R&gt;mid)res2=ask(L,R,mid+1,r,k*2+1); else res2=tmp0;//同理 Ttree res=&#123;0&#125;; res.sum=res1.sum+res2.sum; res.data=max(res1.data,res2.data); res.data=max(res1.rdata+res2.ldata,res.data); res.ldata=max(res1.ldata,res1.sum+res2.ldata); res.rdata=max(res2.rdata,res2.sum+res1.rdata); return res;&#125;void change(int x,int y,int l,int r,int k)&#123; if(l==r)&#123; t[k].data=y; t[k].ldata=t[k].rdata=t[k].sum=t[k].data; return; &#125; int mid=(r+l)/2; if(x&lt;=mid)change(x,y,l,mid,k*2); else change(x,y,mid+1,r,k*2+1); push_up(l,r,k); return;&#125;int main()&#123; tmp0.data=tmp0.ldata=tmp0.rdata=-1e9; scanf("%d%d",&amp;n,&amp;m); make(1,n,1); for(int i=1;i&lt;=m;i++)&#123; int k,x,y; scanf("%d%d%d",&amp;k,&amp;x,&amp;y); if(k==1)&#123; if(x&gt;y)swap(x,y); printf("%d\n",ask(x,y,1,n,1).data); &#125;else&#123; change(x,y,1,n,1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>树</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>区间求和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六度空间]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[题目题目描述“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如下图所示。六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。 假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。 输入格式输入第1行给出两个正整数，分别表示社交网络图的结点数N（1&lt;N≤10000，表示人数）、边数M（≤33×N，表示社交关系数）。随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到N编号）。 输出格式对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。 输入样例1234567891010 91 22 33 44 55 66 77 88 99 10 输出样例123456789101: 70.00%2: 80.00%3: 90.00%4: 100.00%5: 100.00%6: 100.00%7: 100.00%8: 90.00%9: 80.00%10: 70.00% 题解简单的一道图的遍历题，这里我用的是bfs（感觉这道题用bfs更简单），超过6次就跳出，这里有一个重点就是如何在队列里判断一轮结束，具体看代码。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;#define MAXN 10001bool a[MAXN][MAXN];//这里可以扣一点开个boolbool visited[MAXN];//用来标记访问过的点，注意重置int n,m;int bfs(int v)&#123; int que[MAXN]; int head=1,tail=1; int step=1,last=v;//last存放上一个点访问的最后一个点 int tmp; int count; visited[v]=1; count=1; que[tail++]=v; while(head&lt;tail)&#123; int out=que[head++];//出队元素 for(int i=1;i&lt;=n;i++)&#123; if(visited[i])continue; if(a[out][i])&#123; visited[i]=1; que[tail++]=i; count++; tmp=i;//不断更新，最后访问的点被tmp存到 &#125; &#125; if(out==last)&#123;//如果出队元素等于上个点最后访问的点 step++;//说明这一轮结束，step++，last更新为tmp last=tmp; &#125; if(step==7)break; &#125; return count;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); a[x][y]=a[y][x]=1;//无向图 &#125; for(int i=1;i&lt;=n;i++)&#123;//从每个点开始 memset(visited,0,sizeof(visited));//每次要重置visited double ratio; ratio=bfs(i)*1.0/n*100; printf("%d: %.2f%%\n",i,ratio);//用%%转义字符输出% &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>图的连通</category>
      </categories>
      <tags>
        <tag>bfs</tag>
        <tag>邻接矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[YZOJ1370]无聊的锤锤]]></title>
    <url>%2F2018%2F06%2F09%2F%5BYZOJ1370%5D%E6%97%A0%E8%81%8A%E7%9A%84%E9%94%A4%E9%94%A4%2F</url>
    <content type="text"><![CDATA[题目题目描述罗宏明（白客），1988年7月9日出生于中国山东省泰安市，中国内地新生代男演员，毕业于中国传媒大学南广学院。原先是配音员，《搞笑漫画日和》配音团队cucn201的主要成员之一。2013年因出演导演叫兽易小星的搞笑网剧《万万没想到》中的男一号“王大锤”，从而备受关注。 这么火的搞笑剧中，大家是否注意到这样一个剧情(没看过也没关系的)：王大锤要回家过年，上司不让，无奈之下，王大锤就发挥了自己的聪明才智，决定和上司玩个游戏，想着锤锤是个数学白痴，上司欣然答应，胜了就让他回家。游戏是这样的,开始时，白板上有两个不等的整数，他们轮流行动，每次行动必须在白板上写出任意两个已在白板上出现的整数的差且非负，而且这个数字必须是新的，谁再也写不出来就输了。 为了彰显上司魅力，上司让锤锤先开始。上司足够聪明，当然王大锤也不笨，不然会这么火吗？如果你事先知道白板上的数字，聪明的你能推理出王大锤能否回家呢？ 输入测试数据有多组，每组有两个整数，即白板上最初的数字，数据保证在int范围内。 输出每组测试数据输出一行，锤锤能回家就输出“1”，不能输出“0”。 样例输入125 34 8 样例输出1210 题解一开始还打算用暴力，写到一般就打消了这个念头。其实显而易见的是，对于正整数n,m来说,这两个数相减可以得出的所有数x,则 代码12345678910111213141516171819#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int gcd(int a,int b)&#123; return b==0?a:gcd(b,a%b);&#125;int main()&#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)!=EOF)&#123; int num=gcd(n,m); int c1=n/num;//看它最多能写几个数 int c2=m/num; if(c1&gt;c2)printf("%d\n",c1%2); else printf("%d\n",c2%2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>最小公倍数与最大公因数</category>
      </categories>
      <tags>
        <tag>欧几里得算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F09%2FHello%20World%2F</url>
    <content type="text"><![CDATA[123456#include &lt;stdio.h&gt;int main()&#123; printf(&quot;Hello, World!&quot;); return 0;&#125;]]></content>
  </entry>
</search>
