<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[P1979][NOIP2013]华容道]]></title>
    <url>%2F2018%2F10%2F16%2F%5BP1979%5D%5BNOIP2013%5D%E5%8D%8E%E5%AE%B9%E9%81%93%2F</url>
    <content type="text"><![CDATA[样例输入1234563 4 20 1 1 10 1 1 00 1 0 03 2 1 2 2 21 2 2 2 3 2 样例输出122-1 题解 算法分析摘自《2013全国信息学奥林匹克年鉴》 算法分析这道题主要考察同学们对最短路算法的理解。（我考试的时候怎么没看出来orz）本题是一个很典型的最短路模型的题目。假设我们把棋盘的局面当作结点，若A局面能通过一步变成B局面则将A局面和B局面对应的结点连上一条边权为1的边。那么问题就成了求这样建成的图中从初始局面对应的结点到达指定移动格在目标位置的局面对应的那些结点的最短路。也就是求边权都为1的途中的一个单源最短路，用BFS就可以解决这个问题了。具体做法如下： 用(EX,EY,MX,MY)表示空白格在(EX,EY)，指定移动格在(MX,MY)的局面所对应的结点。 将(EX,EY,SX,SY)进队，将Distance(EX,EY,SX,SY)设为0。 若队为空，则输出无解，算法结束。 将队首元素取出，设为(EX,EY,MX,MY)。 若(MX,MY)等于(TX,TY)，则Distance(EX,EY,MX,MY)即为所求答案，算法结束。 否则，设由(EX,EY,MX,MY)能到达的局面(EX’,EY’,MX’,MY’)，且(EX’,EY’,MX’,MY’)从未进队过，则将(EX’,EY’,MX’,MY’)进队，将Distance(EX’,EY’,MX’,MY’)设Distance(EX,EY,MX,MY)+1，然后跳至步骤2. 可以知道，一个局面由空白格的位置和指定移动格的位置唯一确定，所以局面的数量是[latex]O((nm)^2)[/latex]的，也就是说建成的图的结点数是[latex]O((nm)^2)[/latex]的。由于每个局面只可能通过空格和上下左右的移动格交换来变成另外一个局面，所以建成的图中的边数也是[latex]O((nm)^2)[/latex]的。因此求一次最短路的时间复杂度就为[latex]O(V+E)[/latex]，即[latex]O((nm)^2)[/latex]。但是询问有q次，所以总的时间复杂度为[latex]O(q(nm)^2)[/latex]。 我们发现之间bfs不能满足题目的要求，所以算法还需要优化。 进一步分析可以发现，指定移动格只有当空白格在它附近才能移动，所以游戏的过程可以看成将空白格先移动到指定移动格附近（此处不考虑初始位置和目标位置相同的情况），然后指定移动格和空白格交换，再将空白格移动到指定移动格附近，然后再将空白格移动到指定移动格附近，然后再将指定移动格和空白格交换……如此循环下去，直至指定移动格达到目标位置。 如果只考虑空白格在指定移动格附近的局面，那这样的局面数显然是[latex]O(nm)[/latex]的。而局面之间的转移我们只考虑两种，一种是交换指定移动格附近的位置（比如由上方移动到右方）。第一种转移只需要一步，而第二种转移所需的步数就等于固定指定移动格后将空白格移动所需的最小步数，这个步数可以bfs求出，且由于这样的bfs只有[latex]O(nm)[/latex]种，且每种所需的时间是[latex]O(nm)[/latex]，所以我们可以在[latex]O((nm)^2)[/latex]的时间内预处理出来(或者像标程一样采用记忆化的方法)。 两种转移总共最多能转移到5个新的局面，所以暗张这样的局面来建图，点数和边数都是[latex]O(nm)[/latex]的，但是边权就不是全为1了，所以需要用dijsktra算法来求最短路，时间复杂度为[latex]O(nm\times log(nm))[/latex]。加上预处理，总的时间复杂度为[latex]O((nm)^2+nm\times log(nm))[/latex] 至此，本题就完美地解决了。 代码代码来自@ghj1222123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include &lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3fusing namespace std;//方向数组 const int dx[] = &#123;0, 0, 1, -1&#125;, dy[] = &#123;1, -1, 0, 0&#125;;//mp是读入的地图，tt[i][j][d1][d2]是不经过(i,j)的情况下，(i,j)的d1方向转移到 (i,j)的d2方向的最短距离//d是广搜求距离用到的d数组，di是dijkstra时用到的d数组 v是dijkstra时用到的标记数组 int mp[32][32], tt[32][32][4][4], d[32][32], di[32][32][4];bool v[32][32][4];int n, m, q;//如题 //dijkstra过程中用到的状态结构体 struct st&#123; int x, y, d, dis; st(int x = 0, int y = 0, int d = 0, int dis = 0) : x(x), y(y), d(d), dis(dis) &#123; //构造函数 &#125; friend bool operator&gt;(const st &amp;a, const st &amp;b);&#125;;//获取当前方向与dir相反的方向 int rev(int dir)&#123;// printf("(%d,%d) - &gt; (%d,%d)\n", dx[dir], dy[dir], dx[dir ^ 1], dy[dir ^ 1]); return dir ^ 1;&#125;//因为要使用小根堆，所以这里重载了大于号 bool operator&gt;(const st &amp;a, const st &amp;b)&#123; return a.dis &gt; b.dis;&#125;//判断一个点是否合法(是否能够走到) bool valid(int x, int y)&#123; return x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m &amp;&amp; mp[x][y] == 1;&#125;//利用bfs算法求出(x1,y1)到(x2,y2)的距离 int dis(int x1, int y1, int x2, int y2)&#123;// printf("求出(%d,%d)到(%d,%d)的距离\n", x1, y1, x2, y2); if(x1 == x2 &amp;&amp; y1 == y2) return 0; memset(d, 0x3f, sizeof(d)); queue&lt;int&gt; qx, qy;//队列 qx.push(x1); qy.push(y1); d[x1][y1] = 0; while (!qx.empty()) &#123; int x = qx.front(), y = qy.front(); qx.pop(); qy.pop(); for (int i = 0; i &lt;= 3; i++) &#123; int nx = x + dx[i], ny = y + dy[i]; if(valid(nx, ny) &amp;&amp; d[nx][ny] &gt;= inf)//当前方块合法且没有被搜索 &#123; d[nx][ny] = d[x][y] + 1; if(nx == x2 &amp;&amp; ny == y2)//到了终点 &#123;// printf("(%d,%d)到(%d,%d)的距离为%d\n", x1, y1, x2, y2, d[nx][ny]); return d[nx][ny]; &#125; qx.push(nx); qy.push(ny); &#125; &#125; &#125; return inf;&#125;void prework()&#123; int x1, y1, x2, y2; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (mp[i][j] == 1) &#123; mp[i][j] = 0;//暂时将(i,j)标记为不可以动的方块 for (int src = 0; src &lt;= 3; src++)//枚举d1 if (valid(x1 = i + dx[src], y1 = j + dy[src]))//d1方向的块合法 for (int dest = 0; dest &lt;= 3; dest++)//枚举d2 if (valid(x2 = i + dx[dest], y2 = j + dy[dest]))//d2方向的块合法 tt[i][j][src][dest] = dis(x1, y1, x2, y2);//求两个块间的距离 mp[i][j] = 1;//还原标记 &#125;&#125;void work()&#123; int ex, ey, sx, sy, tx, ty;//如题 priority_queue&lt;st, vector&lt;st&gt;, greater&lt;st&gt; &gt;pq;//小根堆 scanf("%d%d%d%d%d%d", &amp;ex, &amp;ey, &amp;sx, &amp;sy, &amp;tx, &amp;ty); if(sx == tx &amp;&amp; sy == ty)//他本来就在目标位置 &#123; printf("0\n"); return; &#125; memset(di, 0x3f, sizeof(di));//初始化距离数组 memset(v, 0, sizeof(v));//初始化 mp[sx][sy] = 0;///注意要把指定可移动块标记为不可移动 for (int i = 0; i &lt;= 3; i++)//枚举空白格子去指定可移动块的那个方向 &#123; int nx = sx + dx[i], ny = sy + dy[i]; if (valid(nx, ny))//这个位置合法 &#123; int ds = dis(ex, ey, nx, ny);//计算距离 pq.push(st(sx, sy, i, ds));//扔进小根堆，dij用 di[sx][sy][i] = ds;//更新dijkstra的di数组 &#125; &#125; mp[sx][sy] = 1;//把指定可移动块不可移动的标记还原 while (!pq.empty())//dijkstra的套路 &#123; st now = pq.top(); pq.pop();// printf("迪杰斯特拉 %d %d (%d,%d) %d\n", now.x, now.y, dx[now.d], dy[now.d], now.dis); if (v[now.x][now.y][now.d] == 1) continue; v[now.x][now.y][now.d] = 1; int &amp;x = now.x, &amp;y = now.y; for (int i = 0; i &lt;= 3; i++) &#123; int nx = x + dx[i], ny = y + dy[i];//让空白块移动到(nx,ny)然后让指定可移动块移动到空白块位置 // printf("下一个为(%d,%d)\n", nx, ny); if (valid(nx, ny))//(nx,ny)是合法的 &#123;// printf("(%d,%d)合法\n", nx, ny); int ds = tt[x][y][now.d][i];//直接从tt数组获取空白格子移动的距离 if (v[nx][ny][rev(i)] == 0 &amp;&amp; now.dis + ds + 1 &lt; di[nx][ny][rev(i)])//dij套路，更新距离 &#123;// printf("由(%d,%d,%d,%d,%d)到(%d,%d,%d,%d,%d)\n", now.x, now.y, dx[now.d], dy[now.d], now.dis, nx, ny, dx[rev(i)], dy[rev(i)], now.dis + ds + 1); di[nx][ny][rev(i)] = now.dis + ds + 1; pq.push(st(nx, ny, rev(i), now.dis + ds + 1)); &#125; &#125; &#125; &#125; int mind = inf; for (int i = 0; i &lt;= 3; i++)//枚举目标位置的4个方向的状态更新最小值 &#123; mind = min(mind, di[tx][ty][i]);// printf("di[%d][%d][%d] = %d\n", tx, ty, i, di[tx][ty][i]); &#125; if (mind == inf)//最小值没有被更新，说明目标位置不可到达 printf("-1\n"); else printf("%d\n", mind);&#125;//主函数 int main()&#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) scanf("%d", &amp;mp[i][j]); prework(); for (int i = 1; i &lt;= q; i++) work(); return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>bfs</tag>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2012]国王游戏]]></title>
    <url>%2F2018%2F10%2F14%2F%5BNOIP2012%5D%E5%9B%BD%E7%8E%8B%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题解 内容摘自李煜东所著《算法竞赛进阶指南》由于本题输出过大，要用高进度，但是这里主要讨论贪心，请先无视高精度 按照每个大臣左、右手上的数的乘积从小到大排序，就是最优排队方案。这个贪心算法可以使用微扰（临项交换）证明。对于任意一种排序，设$n$名大臣左、右手上的数分别是$A[1]$到$A[n]$与$B[1]$到$B[n]$，国王里的数是$A[0]$和$B[0]$。如果我们交换两个相邻的大臣$i$与$i+1$，在交换前这两个大臣获得的奖励是： $\displaystyle \frac{1}{B[i]} \times \prod_{j=0}^{i-1} A[j] $与$\displaystyle \frac{1}{B[i+1]} \times \prod_{j=0}^i A[j]$ 交换之后这两个大臣获得的奖励是： $\displaystyle \frac{1}{B[i+1]} \times \prod_{j=0}^{i-1} A[j] $与$\displaystyle \frac{A[i+1]}{B[i]} \times \prod_{j=0}^{i-1} A[j]$ 其他大臣获得的奖励显然都不变，因此我们只需要比较上面两组式子最大值的变化。提取出公因式$\prod_{j=0}^{i-1}A[j]$后，实际上需要比较下面两个式子的大小关系： $max(\frac{1}{B[i]},\frac{A[i]}{B[i+1]})$ ——$max(\frac{1}{B[i+1]},\frac{A[i+1]}{B[i]})$ 两边同时乘上$B[i]\times B[i+1]$，变为比较： $max(B[i+1],A[i]\times B[i])$ ——$max(B[i],A[i+1]\times B[i+1])$注意到大臣手上的树都是正整数，故$B[i+1]\le A[i+1]\times B[i+1]$，且$B[i] \le A[i]\times B[i]$。 于是，当$A[i]\times B[i]\le A[i+1]\times B[i+1]$时，$左式\le 右式$，交换前更优。当$A[i+1]\times B[i+1]\le A[i]\times B[i]$时$ 右式\le 左式$，交换后更优。也就是说，在任何局面下，减小逆序对数都不会造成整体结果变差，而增加逆序对数则不会使整体结果变好。 最后，根据冒泡排序的知识，任何一个序列都能通过邻项交换的方式变为有序序列。故当逆序对数为0，即按上述方案排序时就是最优策略。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int MAXN=1005;const unsigned long long N=1000000000000000;int n;struct hand&#123; int l,r;&#125;h[MAXN]; #define MAXN 9999#define MAXSIZE 10000000#define DLEN 4 class BigNum&#123;private: int a[5000]; //可以控制大数的位数 int len; //大数长度public: BigNum() &#123; len = 1; memset(a, 0, sizeof(a)); &#125; //构造函数 BigNum(const int); //将一个int类型的变量转化为大数 BigNum(const char*); //将一个字符串类型的变量转化为大数 BigNum(const BigNum &amp;); //拷贝构造函数 BigNum &amp;operator=(const BigNum &amp;); //重载赋值运算符，大数之间进行赋值运算 friend istream&amp; operator&gt;&gt;(istream&amp;, BigNum&amp;); //重载输入运算符 friend ostream&amp; operator&lt;&lt;(ostream&amp;, BigNum&amp;); //重载输出运算符 BigNum operator+(const BigNum &amp;) const; //重载加法运算符，两个大数之间的相加运算 BigNum operator-(const BigNum &amp;) const; //重载减法运算符，两个大数之间的相减运算 BigNum operator*(const BigNum &amp;) const; //重载乘法运算符，两个大数之间的相乘运算 BigNum operator/(const int &amp;) const; //重载除法运算符，大数对一个整数进行相除运算 BigNum operator^(const int &amp;) const; //大数的n次方运算 int operator%(const int &amp;) const; //大数对一个int类型的变量进行取模运算 bool operator&gt;(const BigNum &amp; T)const; //大数和另一个大数的大小比较 bool operator&gt;(const int &amp; t)const; //大数和一个int类型的变量的大小比较 void print(); //输出大数&#125;;BigNum::BigNum(const int b) //将一个int类型的变量转化为大数&#123; int c, d = b; len = 0; memset(a, 0, sizeof(a)); while (d &gt; MAXN) &#123; c = d - (d / (MAXN + 1)) * (MAXN + 1); d = d / (MAXN + 1); a[len++] = c; &#125; a[len++] = d;&#125;BigNum::BigNum(const char*s) //将一个字符串类型的变量转化为大数&#123; int t, k, index, l, i; memset(a, 0, sizeof(a)); l = strlen(s); len = l / DLEN; if (l%DLEN) len++; index = 0; for (i = l - 1; i &gt;= 0; i -= DLEN) &#123; t = 0; k = i - DLEN + 1; if (k&lt;0) k = 0; for (int j = k; j &lt;= i; j++) t = t * 10 + s[j] - '0'; a[index++] = t; &#125;&#125;BigNum::BigNum(const BigNum &amp; T) : len(T.len) //拷贝构造函数&#123; int i; memset(a, 0, sizeof(a)); for (i = 0; i &lt; len; i++) a[i] = T.a[i];&#125;BigNum &amp; BigNum::operator=(const BigNum &amp; n) //重载赋值运算符，大数之间进行赋值运算&#123; int i; len = n.len; memset(a, 0, sizeof(a)); for (i = 0; i &lt; len; i++) a[i] = n.a[i]; return *this;&#125;istream&amp; operator&gt;&gt;(istream &amp; in, BigNum &amp; b) //重载输入运算符&#123; char ch[MAXSIZE * 4]; int i = -1; in &gt;&gt; ch; int l = strlen(ch); int count = 0, sum = 0; for (i = l - 1; i &gt;= 0;) &#123; sum = 0; int t = 1; for (int j = 0; j&lt;4 &amp;&amp; i &gt;= 0; j++, i--, t *= 10) &#123; sum += (ch[i] - '0')*t; &#125; b.a[count] = sum; count++; &#125; b.len = count++; return in; &#125;ostream&amp; operator&lt;&lt;(ostream&amp; out, BigNum&amp; b) //重载输出运算符&#123; int i; cout &lt;&lt; b.a[b.len - 1]; for (i = b.len - 2; i &gt;= 0; i--) &#123; cout.width(DLEN); cout.fill('0'); cout &lt;&lt; b.a[i]; &#125; return out;&#125; BigNum BigNum::operator+(const BigNum &amp; T) const //两个大数之间的相加运算&#123; BigNum t(*this); int i, big; //位数 big = T.len &gt; len ? T.len : len; for (i = 0; i &lt; big; i++) &#123; t.a[i] += T.a[i]; if (t.a[i] &gt; MAXN) &#123; t.a[i + 1]++; t.a[i] -= MAXN + 1; &#125; &#125; if (t.a[big] != 0) t.len = big + 1; else t.len = big; return t;&#125;BigNum BigNum::operator-(const BigNum &amp; T) const //两个大数之间的相减运算 &#123; int i, j, big; bool flag; BigNum t1, t2; if (*this&gt;T) &#123; t1 = *this; t2 = T; flag = 0; &#125; else &#123; t1 = T; t2 = *this; flag = 1; &#125; big = t1.len; for (i = 0; i &lt; big; i++) &#123; if (t1.a[i] &lt; t2.a[i]) &#123; j = i + 1; while (t1.a[j] == 0) j++; t1.a[j--]--; while (j &gt; i) t1.a[j--] += MAXN; t1.a[i] += MAXN + 1 - t2.a[i]; &#125; else t1.a[i] -= t2.a[i]; &#125; t1.len = big; while (t1.a[len - 1] == 0 &amp;&amp; t1.len &gt; 1) &#123; t1.len--; big--; &#125; if (flag) t1.a[big - 1] = 0 - t1.a[big - 1]; return t1;&#125; BigNum BigNum::operator*(const BigNum &amp; T) const //两个大数之间的相乘运算 &#123; BigNum ret; int i, j, up; int temp, temp1; for (i = 0; i &lt; len; i++) &#123; up = 0; for (j = 0; j &lt; T.len; j++) &#123; temp = a[i] * T.a[j] + ret.a[i + j] + up; if (temp &gt; MAXN) &#123; temp1 = temp - temp / (MAXN + 1) * (MAXN + 1); up = temp / (MAXN + 1); ret.a[i + j] = temp1; &#125; else &#123; up = 0; ret.a[i + j] = temp; &#125; &#125; if (up != 0) ret.a[i + j] = up; &#125; ret.len = i + j; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125;BigNum BigNum::operator/(const int &amp; b) const //大数对一个整数进行相除运算&#123; BigNum ret; int i, down = 0; for (i = len - 1; i &gt;= 0; i--) &#123; ret.a[i] = (a[i] + down * (MAXN + 1)) / b; down = a[i] + down * (MAXN + 1) - ret.a[i] * b; &#125; ret.len = len; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125;int BigNum::operator %(const int &amp; b) const //大数对一个int类型的变量进行取模运算 &#123; int i, d = 0; for (i = len - 1; i &gt;= 0; i--) &#123; d = ((d * (MAXN + 1)) % b + a[i]) % b; &#125; return d;&#125;BigNum BigNum::operator^(const int &amp; n) const //大数的n次方运算&#123; BigNum t, ret(1); int i; if (n&lt;0) exit(-1); if (n == 0) return 1; if (n == 1) return *this; int m = n; while (m&gt;1) &#123; t = *this; for (i = 1; i &lt;&lt; 1 &lt;= m; i &lt;&lt;= 1) &#123; t = t * t; &#125; m -= i; ret = ret * t; if (m == 1) ret = ret * (*this); &#125; return ret;&#125;bool BigNum::operator&gt;(const BigNum &amp; T) const //大数和另一个大数的大小比较&#123; int ln; if (len &gt; T.len) return true; else if (len == T.len) &#123; ln = len - 1; while (a[ln] == T.a[ln] &amp;&amp; ln &gt;= 0) ln--; if (ln &gt;= 0 &amp;&amp; a[ln] &gt; T.a[ln]) return true; else return false; &#125; else return false;&#125;bool BigNum::operator &gt;(const int &amp; t) const //大数和一个int类型的变量的大小比较&#123; BigNum b(t); return *this&gt;b;&#125;void BigNum::print() //输出大数&#123; int i; cout &lt;&lt; a[len - 1]; for (i = len - 2; i &gt;= 0; i--) &#123; cout.width(DLEN); cout.fill('0'); cout &lt;&lt; a[i]; &#125; cout &lt;&lt; endl;&#125; bool cmp(hand a,hand b)&#123; return a.r*a.l&lt;b.r*b.l;&#125; int main()&#123; cin&gt;&gt;n; int l,r; cin&gt;&gt;l&gt;&gt;r; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;h[i].l&gt;&gt;h[i].r; &#125; sort(h+1,h+1+n,cmp); BigNum ans=0; BigNum sum=l; for(int i=1;i&lt;=n;i++)&#123; if(sum/h[i].r&gt;ans)&#123; ans=sum/h[i].r; &#125; sum=sum*h[i].l; &#125; ans.print(); return 0;&#125;]]></content>
      <categories>
        <category>基本算法</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>临项交换</tag>
        <tag>微扰</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[看见统计]一个超赞的交互式学习网站]]></title>
    <url>%2F2018%2F10%2F14%2F%5B%E7%9C%8B%E8%A7%81%E7%BB%9F%E8%AE%A1%5D%E4%B8%80%E4%B8%AA%E8%B6%85%E8%B5%9E%E7%9A%84%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[我说的再好也不如大家自己去体会一下： 网站链接 支持中文！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ3680][JSOI2004]平衡点吊打xxx]]></title>
    <url>%2F2018%2F10%2F14%2F%5BBZOJ3680%5D%5BJSOI2004%5D%E5%B9%B3%E8%A1%A1%E7%82%B9%E5%90%8A%E6%89%93xxx%2F</url>
    <content type="text"><![CDATA[题目描述如图：有n个重物，每个重物系在一条足够长的绳子上。每条绳子自上而下穿过桌面上的洞，然后系在一起。图中X处就是公共的绳结。假设绳子是完全弹性的（不会造成能量损失），桌子足够高（因而重物不会垂到地上），且忽略所有的摩擦。 问绳结X最终平衡于何处。 注意：桌面上的洞都比绳结X小得多，所以即使某个重物特别重，绳结X也不可能穿过桌面上的洞掉下来，最多是卡在某个洞口处。 输入输出格式输入格式：文件的第一行为一个正整数n（1≤n≤1000），表示重物和洞的数目。接下来的n行，每行是3个整数：Xi.Yi.Wi，分别表示第i个洞的坐标以及第 i个重物的重量。(-10000≤x,y≤10000, 0&lt;w≤1000 ) 输出格式：你的程序必须输出两个浮点数（保留小数点后三位），分别表示处于最终平衡状态时绳结X的横坐标和纵坐标。两个数以一个空格隔开。 输入输出样例输入样例1：123430 0 10 2 11 1 1 输出样例1：10.577 1.000 题解一道物理题，也可以用模拟退火来瞎搞。正解要用到计算几何内容先设平衡点为x,y，然后对所有的点产生的力正交分解，然后算合力。但是也可以这样想：物重一定，绳子越短，重物越低，势能越小，势能又与物重成正比，所以，只要使得$\displaystyle \sum_{i=1}^n dis[i]\times weight[i]$也就是总的重力势能最小，就可以使系统平衡 这道题目的退火模型很典型，有些地方别的退火题目可能都用不到，模拟退火的细节看注释。值得注意的是，$\displaystyle e^{-\frac{\Delta}{t}}$是一个退火公式，不一定是必须的，但是模拟退火里面用上它能更高效一点。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cctype&gt;using namespace std;struct Node&#123;//点 int x,y,weight;&#125;node[10005];int n;double ans_x,ans_y;double ans=1e18+7,t;const double delta=0.993;//退火常数Δ，用来控制退火速率double E(double nowx,double nowy)&#123;//计算总的重力势能 double sum=0; for(int i=1;i&lt;=n;i++)&#123; double delx=nowx-node[i].x; double dely=nowy-node[i].y; sum+=(sqrt(delx*delx+dely*dely))*node[i].weight; &#125; return sum;&#125;void SA()&#123; double xx=ans_x; double yy=ans_y; double t=56;//初始温度（上界） while(t&gt;1e-14)&#123;//结束温度（下界） double tmp_x=ans_x+(rand()*2-RAND_MAX)*t;//根据温度来控制随机偏移的范围 double tmp_y=ans_y+(rand()*2-RAND_MAX)*t; double new_ans=E(tmp_x,tmp_y); double DE=new_ans-ans; if(DE&lt;0)&#123;//新的解更优，接受 xx=tmp_x; yy=tmp_y; ans_x=xx; ans_y=yy; ans=new_ans; &#125; else if(exp(-DE/t)*RAND_MAX&gt;rand())&#123;//新的解不是更优的，我们有几率接受它 xx=tmp_x; yy=tmp_y; &#125; t*=delta; &#125;&#125;int main()&#123; srand(20011112); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;node[i].x; cin&gt;&gt;node[i].y; cin&gt;&gt;node[i].weight; &#125; SA(); //SA();（BZOJ只能退1-2次，多了会超时） //SA(); printf("%.3lf %.3lf\n",ans_x,ans_y); return 0;&#125; 补充关于上面提到的退火公式有一个有趣的现象，当Δ&gt;0时（具体来说是=5），我们的不是更优的，这个函数的图像是这样的（渐进1）：而当Δ=0时，函数恒为1Δ&lt;0时（具体来说是=-5），解更优，它的函数图像是这样的（渐进1）： Δ的变化动图： 而1对于上面的程序是一个分界点，我们可以总结出规律来： 当解不是更优时，当温度越高时我们有更大的几率接受这个解，反之 当解是更优时，我们一定接受它]]></content>
      <categories>
        <category>基本算法</category>
        <category>随机算法</category>
        <category>模拟退火</category>
      </categories>
      <tags>
        <tag>模拟退火</tag>
        <tag>玄学算法</tag>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOI1999][POJ1190]生日蛋糕]]></title>
    <url>%2F2018%2F10%2F14%2F%5BNOI1999%5D%5BPOJ1190%5D%E7%94%9F%E6%97%A5%E8%9B%8B%E7%B3%95%2F</url>
    <content type="text"><![CDATA[Description7月17日是Mr.W的生日，ACM-THU为此要制作一个体积为Nπ的M层生日蛋糕，每层都是一个圆柱体。设从下往上数第i(1 &lt;= i &lt;= M)层蛋糕是半径为Ri, 高度为Hi的圆柱。当i &lt; M时，要求Ri &gt; Ri+1且Hi &gt; Hi+1。由于要在蛋糕上抹奶油，为尽可能节约经费，我们希望蛋糕外表面（最下一层的下底面除外）的面积Q最小。令Q = Sπ请编程对给出的N和M，找出蛋糕的制作方案（适当的Ri和Hi的值），使S最小。（除Q外，以上所有数据皆为正整数） Input有两行，第一行为N（N &lt;= 10000），表示待制作的蛋糕的体积为Nπ；第二行为M(1&lt;=M &lt;= 20)，表示蛋糕的层数为M。 Output仅一行，是一个正整数S（若无解则S = 0）。 Sample Input121002 Sample Output168 Hint圆柱公式体积$V = πR^2H$侧面积$A’ = 2πRH$底面积$A = πR^2$ 题解对于这种没有多项式复杂度的题目显然最好的做法是搜索。但是这可是道NOI的题目，所以我们还要进行一些剪枝，我这里可能不是所有的剪枝都用了，但足够了，POJ16ms 首先我们搜索有5个状态，剩余层数，用了的表面积，用了的体积，当前层的高度，当前层的半径。 剪枝 上下界剪枝（范围剪枝）我们在第dep层时，只需要在以下范围内枚举高度和半径即可：$R\in [dep,min(\lfloor \sqrt{N-v} \rfloor,r[dep+1]-1)]$$H\in [dep,min(\lfloor \frac{N-v}{R^2} \rfloor,h[dep+1]-1)]$ 优化搜索顺序上面的范围中，倒序枚举。 可行性剪枝/最优化剪枝（见注释） 代码12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;int n,m,ans;int mincake[30];void dfs(int last,int s,int v,int h,int r)&#123; if(last==0)&#123; if(v==n&amp;&amp;s&lt;ans)&#123; ans=s; &#125; return; &#125; if(v+mincake[last-1]&gt;n)return;//当前体积+下一层最小体积&gt;总体积，可行性剪枝 if(2*(n-v)/r+s&gt;=ans)return;//最优性剪枝 for(int i=r-1;i&gt;=last;i--)&#123; if(last==m)s=i*i; int hh=min((n-v-mincake[last-1])/(i*i),h-1); for(int j=hh;j&gt;=last;j--)&#123; dfs(last-1,s+2*i*j,v+i*i*j,j,i); &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; ans=1&lt;&lt;30; for(int i=1;i&lt;=20;i++)mincake[i]=mincake[i-1]+i*i*i;//第i层最小的蛋糕体积 dfs(m,0,0,n+1,n+1); if(ans==1&lt;&lt;30)cout&lt;&lt;0; else cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>基本算法</category>
        <category>搜索</category>
        <category>深搜</category>
        <category>剪枝</category>
      </categories>
      <tags>
        <tag>剪枝</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ2469][中山市选2010]简单数谜]]></title>
    <url>%2F2018%2F10%2F13%2F%5BBZOJ2469%5D%5B%E4%B8%AD%E5%B1%B1%E5%B8%82%E9%80%892010%5D%E7%AE%80%E5%8D%95%E6%95%B0%E8%B0%9C%2F</url>
    <content type="text"><![CDATA[Description很多人都曾经听说过数独，但你是否听说过数谜（Karuro）呢？实际上，数谜是数独的更大（且更难）的兄弟问题，而且在日本也是非常受欢迎的。数谜问题和填字游戏类似，不过它要填的不是文字而是数字。数谜游戏的目标是用1-9填满所有空格，且这些数字相加的和满足相应的要求（或者称为“提示”），且在同一栏（“栏”是指一些水平或者竖直的连续的空格，用于提示的格子不算空格）不能填重复的数字。当所有格子按要求被填满后，这个数谜就看作被解决了。图1和图2是一个可能的数谜游戏示例。当然，直接求解数谜问题的话会比较困难。所以现在我们需要解决的是一个更简单的数谜问题。简单数谜的形状是一个(n+1）行乘(m+1)列的矩形。而简单数谜也只有两种要求，就是行要求和列要求，且分别处于第一行和第一列，其他格子则是空格，而左上角是忽略不计的。coolzzz同学爱好简单数谜，他已经给一些简单数谜填好了其中的一些空格。现在，他想寻求你的帮助，来帮他完成这些简单数谜。如图3所示，2和9是coolzzz同学已经填好的空格，图4则是一个基于图3 的一个可能的解答。 Input输入包含多组测试数据。第一行包含一个正整数T，表示测试数据数目。每组数据第一行是n(n&lt;10)和m(m&lt;10)，表示数谜的形状的大小。接下来一行有n个整数，是相应的行要求；然后一行是m个整数，是相应的列要求。接下来的n行每行有m个小于10的非负整数，0表示该空格还没有被填数字，其他表示coolzzz同学已经填好的数字。输入数据保证未填数字的空格不会超过16个。 Output对于每组测试数据，输出若干行。如果基于coolzzz已填的结果，该数谜只有一个解，则输出该解；如果不止一个解，则输出一行“Not unique.”；如果没有解，则输出一行“No answer.”。 Sample Input123456789101112131415161733 36 6 66 6 60 0 00 3 00 0 02 310 175 16 62 0 00 9 02 23 54 40 00 0 Sample Output1234Not unique.2 7 13 9 5No answer. 题解一道简单的爆搜题，和数独比起来稍微复杂一点（然而代码量更少），比较坑爹的就是如果不加一句话的话全部超时，加上去了就只要32ms我们每次填只关心当前行满不满足要求，最后结束的时候再来判断是不是合法具体数组作用可以用一个表格体现 数组（变量）名称 数组（变量）作用 ans 用来存放最终的结果 num 用来统计有多少个答案 kakuro 初始状态以及之后搜索时的状态 x,y 要求的行、列和 X,Y 当前行、列有哪些数是用过的 val_x,val_y 当前状态的行、列和 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int MAXN=15;int num;int ans[MAXN][MAXN],kakuro[MAXN][MAXN];int x[MAXN],y[MAXN];bool Y[MAXN][MAXN],X[MAXN][MAXN];int val_x[MAXN],val_y[MAXN];int n,m; inline void init()&#123; cin&gt;&gt;n&gt;&gt;m; num=0; memset(ans,0,sizeof(ans)); memset(kakuro,0,sizeof(kakuro)); memset(val_x,0,sizeof(val_x)); memset(val_y,0,sizeof(val_y)); memset(X,0,sizeof(X)); memset(Y,0,sizeof(Y)); for(int i=1;i&lt;=n;i++)cin&gt;&gt;y[i]; for(int j=1;j&lt;=m;j++)cin&gt;&gt;x[j]; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; scanf("%d",&amp;kakuro[i][j]); Y[i][kakuro[i][j]]=1; X[j][kakuro[i][j]]=1; val_y[i]+=kakuro[i][j]; val_x[j]+=kakuro[i][j]; &#125; &#125;&#125; inline void dfs(int now_x,int now_y)&#123; if(num&gt;=2)return; if(now_y&gt;n)&#123; bool ok=1; for(int i=1;i&lt;=m;i++)&#123; if(val_x[i]!=x[i])&#123; ok=0; break; &#125; &#125; if(ok)&#123; num++; memcpy(ans,kakuro,sizeof(kakuro)); &#125; &#125; else if (now_x &gt; m) &#123; if (val_y[now_y] == y[now_y]) &#123;//不加全超时 dfs(1, now_y + 1); &#125; &#125; else if(kakuro[now_y][now_x]!=0)dfs(now_x+1,now_y); else &#123; for(int i=1;i&lt;=9;i++)&#123; if(!Y[now_y][i]&amp;&amp;!X[now_x][i]&amp;&amp;val_x[now_x]+i&lt;=x[now_x]&amp;&amp;val_y[now_y]+i&lt;=y[now_y])&#123; Y[now_y][i]=X[now_x][i]=1; val_x[now_x]+=i; val_y[now_y]+=i; kakuro[now_y][now_x]=i; dfs(now_x+1,now_y); Y[now_y][i]=X[now_x][i]=0; val_x[now_x]-=i; val_y[now_y]-=i; kakuro[now_y][now_x]=0; &#125; &#125; &#125;&#125; inline void out()&#123; if(num==0)printf("No answer.\n"); else if(num==1)&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; printf("%d ",ans[i][j]); &#125; printf("\n"); &#125; &#125; else &#123; printf("Not unique.\n"); &#125;&#125; int main()&#123;// freopen("poi.out","w",stdout); int t; cin&gt;&gt;t; int T=t; while(t--)&#123; // printf("Case %d:\n",T-t); init(); dfs(1,1); out(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>基本算法</category>
        <category>搜索</category>
        <category>深搜</category>
        <category>剪枝</category>
      </categories>
      <tags>
        <tag>kakuro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO17OPEN]Modern Art]]></title>
    <url>%2F2018%2F10%2F12%2F%5BUSACO17OPEN%5DModern%20Art%2F</url>
    <content type="text"><![CDATA[题目题目描述Art critics worldwide have only recently begun to recognize the creative genius behind the great bovine painter, Picowso. Picowso paints in a very particular way. She starts with an N \times NN×N blank canvas, represented by an N \times NN×N grid of zeros, where a zero indicates an empty cell of the canvas. She then draws N^2N2 rectangles on the canvas, one in each of N^2N2 colors (conveniently numbered 1 \ldots N^21…N2 ). For example, she might start by painting a rectangle in color 2, giving this intermediate canvas: 2 2 2 0 2 2 2 0 2 2 2 0 0 0 0 0 She might then paint a rectangle in color 7: 2 2 2 0 2 7 7 7 2 7 7 7 0 0 0 0 And then she might paint a small rectangle in color 3: 2 2 3 0 2 7 3 7 2 7 7 7 0 0 0 0 Each rectangle has sides parallel to the edges of the canvas, and a rectangle could be as large as the entire canvas or as small as a single cell. Each color from 1 \ldots N^21…N2 is used exactly once, although later colors might completely cover up some of the earlier colors. Given the final state of the canvas, please count how many of the N^2N2 colors could have possibly been the first to be painted. 小TY突然想画画，他有独特的艺术风格，他从N×N空白画布开始，其中0表示画布的空单元格。然后他会在画布上绘制恰好矩形，每个颜色是1到N×N中的一个。他每次可以选择任意一种未使用过的颜色进行绘画。例如，他可以从颜色2的矩形开始，画出这样的画布： 2 2 2 0 2 2 2 0 2 2 2 0 0 0 0 0 然后他可以用颜色7绘制一个矩形： 2 2 2 0 2 7 7 7 2 7 7 7 0 0 0 0 然后他可以在颜色3上绘制一个小矩形： 2 2 3 0 2 7 3 7 2 7 7 7 0 0 0 0 每个矩形都平行于画布边缘，而且矩形可以与整个画布一样大或者像一个单元一样小。每个颜色从1到正好使用一次，后来的颜色可能完全覆盖一些较早画上的颜色。 现在已知画布的最终状态，请计算有多少种颜色可能被第一个被画。 输入输出格式输入格式：The first line of input contains NN, the size of the canvas (1 \leq N \leq 10001≤N≤1000). The next NN lines describe the final picture of the canvas, each containing NN integers that are in the range 0 \ldots N^20…N2 . The input is guaranteed to have been drawn as described above, by painting successive rectangles in different colors. 输出格式：Please output a count of the number of colors that could have been drawn first. 输入输出样例输入样例#1：1234542 2 3 02 7 3 72 7 7 70 0 0 0 输出样例#1：114 说明In this example, color 2 could have been the first to be painted. Color 3 clearly had to have been painted after color 7, and color 7 clearly had to have been painted after color 2. Since we don’t see the other colors, we deduce that they also could have been painted first. 感谢@ yhf_2015 的翻译 题解似乎没人写差分的代码，我这里就稍微介绍一下。首先呢，这道题目很毒瘤，我花了好大功夫才读懂题目，无论它给你的矩阵里面有多少种颜色，它一共还是有[latex]N^2[/latex]种颜色，所以显然我们找不合法的颜色就行。观察样例我们可以发现，2颜色的矩阵显然被7的覆盖了一部分，7肯定不能第一个涂，3又把7给覆盖掉了，3也不能第一个涂。那么我们可以把问题转化成，有x个矩形（有些被覆盖了的矩形左上角右下角还是可以算到的），求重叠部分上面的矩形的颜色总数。 当然用暴力就可以莽过去，但是遇到类似的问题用二维前缀和+二维差分显然是更优的。参照一维差分的思想，我们可以在一个矩形的左上角+1，右下角+1，右边-1,下边-1样例的差分数组：1234 1 0 0 -1 0 1 0 0 0 0 -1 1-1 -1 1 0 这样子统计前缀和后，每个点的前缀和的值就是该点被覆盖的次数。细节见代码注释。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int MAXN=1005,inf=0x7fffffff;int pos[MAXN*MAXN][4],ma[MAXN][MAXN],col,ans,sum[MAXN][MAXN],cnt;bool fla[MAXN*MAXN];int main()&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;=n*n;i++)&#123;//初始化 pos[i][0]=pos[i][1]=inf,pos[i][2]=pos[i][3]=0; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; cin&gt;&gt;col; ma[i][j]=col; if(col)&#123;//非0 if(pos[col][2]==0)cnt++; if(i&lt;pos[col][0])pos[col][0]=i;//矩形上边边界 if(j&lt;pos[col][1])pos[col][1]=j;//矩形左边边界 if(i+1&gt;pos[col][2])pos[col][2]=i+1;//矩形下边边界+1 if(j+1&gt;pos[col][3])pos[col][3]=j+1;//矩形右边边界+1 &#125; &#125; &#125; for(int i=1;i&lt;=n*n;i++)&#123; if(pos[i][0]==inf||pos[i][2]==0)continue;//枚举出现过的颜色 sum[pos[i][0]][pos[i][1]]++;//上面说的 sum[pos[i][2]][pos[i][3]]++; sum[pos[i][0]][pos[i][3]]--; sum[pos[i][2]][pos[i][1]]--; &#125; //前缀和 for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; sum[i][j]+=sum[i][j-1]; &#125; &#125; for(int j=1;j&lt;=n;j++)&#123; for(int i=1;i&lt;=n;i++)&#123; sum[i][j]+=sum[i-1][j]; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(ma[i][j]&amp;&amp;sum[i][j]&gt;1&amp;&amp;fla[ma[i][j]]==0)&#123;//每种颜色只能贡献一次答案 ans++,fla[ma[i][j]]=1; &#125; &#125; &#125; if(n!=1&amp;&amp;cnt==1)ans++; printf("%d\n",n*n-ans); return 0;&#125;]]></content>
      <categories>
        <category>基本算法</category>
        <category>前缀和</category>
        <category>差分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[USACO17OPEN]Modern Art 2]]></title>
    <url>%2F2018%2F10%2F11%2F%5BUSACO17OPEN%5DModern%20Art%202%2F</url>
    <content type="text"><![CDATA[题目题目背景小TY的同学HF也想创作艺术 HF只有一块长条状的画布(画条)，所以每一次涂色只能涂上连续几个单位的颜料，同样新的颜料可以完全覆盖旧的颜料 由于他的颜料同样非常傲娇，每次涂完要等上1day才能完全干，只有旧颜料干了以后才能用新颜料覆盖 现在小HF用了2017个年头终于画出了一个大作品，自己非常满意 现在他想复制这份作品 题目描述Having become bored with standard 2-dimensional artwork (and also frustrated at others copying her work), the great bovine artist Picowso has decided to switch to a more minimalist, 1-dimensional style. Although, her paintings can now be described by a 1-dimensional array of colors of length NN (1 \leq N \leq 100,0001≤N≤100,000), her painting style remains unchanged: she starts with a blank canvas and layers upon it a sequence of “rectangles” of paint, which in this 1-dimensional case are simply intervals. She uses each of the colors 1 \ldots N1…N exactly once, although just as before, some colors might end up being completely covered up by the end. To Picowso’s great dismay, her competitor Moonet seems to have figured out how to copy even these 1-dimensional paintings, using a similar strategy to the preceding problem: Moonet will paint a set of disjoint intervals, wait for them to dry, then paint another set of disjoint intervals, and so on. Moonet can only paint at most one interval of each color over the entire process. Please compute the number of such rounds needed for Moonet to copy a given 1-dimensional Picowso painting. 现在给你一个长度为N(N≤1e5)的画条 上面有若干种颜色，每位的数字表示一种颜色，0表示没有涂色 为了快捷，每次涂色可以用一种颜色填充一个区间，同一种颜色只能使用一次 每次可以涂色好几次，但是这些区间必须分别连续切两两不能相交 然后等待1day油漆干了后再同样操作，输出创作完成并全干了后的最少时间 输入输出格式输入格式：The first line of input contains NN, and the next NN lines contain an integer in the range 0 \ldots N0…N indicating the color of each cell in the 1-dimensional painting (0 for a blank cell). 第一行为N，画条长度 一下N行每行一个数表示颜色 输出格式：Please output the minimum number of rounds needed to copy this painting, or -1 if this could not have possibly been an authentic work of Picowso (i.e., if she could not have painted it using a layered sequence of intervals, one of each color). 输出一个整数表示最少天数。数据若不合法则输出-1 输入输出样例输入样例#1：70145133 输出样例#1：2 说明In this example, the interval of color 1 must be painted in an earlier round than the intervals of colors 4 and 5, so at least two rounds are needed. 样例解释：第一次可以把1颜色和3颜色填充，变成 0 1 1 1 1 3 3 等待1Day后再填充颜色4和颜色5，变成 0 1 4 5 1 3 3 在等待一Day油漆干了后创作完成 所以答案是2 感谢 @ Night_Aurora 贡献翻译 题解一道大水题（容易想得太复杂了），一种颜色只能用一次，而且必须连续涂，那么被分开来的就一定是被其他颜色覆盖了的，而这段“其他颜色”又可以被覆盖，而且颜色块不能相交（例如0 1 2 1 2就是非法的），我们的问题就转化成了，最大有多少层嵌套的问题。我们可以从前往后扫，用栈纪录当前层的颜色。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=100005;int l[MAXN],r[MAXN];//某种颜色的开始点和结束点int zhan[MAXN],p;//当前层的颜色int a[MAXN],ans;//第i个位置的颜色int tmp;//其实可以不用它，它一直和p相等 int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; if(!l[a[i]])l[a[i]]=i; r[a[i]]=i; &#125; for(int i=1;i&lt;=n;i++)&#123; if(a[i]==0)&#123; if(p)&#123;//如果0被夹在两个相同颜色块里面，肯定不合法 cout&lt;&lt;-1; return 0; &#125; else continue; &#125; if(l[a[i]]==i)&#123;//该点是某种颜色的起始点 if(p&amp;&amp;r[a[zhan[p]]]&lt;r[a[i]])&#123;//上面说到的交叉的情况，没这段会错一个点 cout&lt;&lt;-1; return 0; &#125; zhan[++p]=i;//入栈 tmp++; ans=max(ans,tmp); //更新答案 &#125; if(r[a[i]]==i)&#123;//到了结束点，出栈 tmp--; p--; &#125; &#125; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1967][NOIP2013]货车运输]]></title>
    <url>%2F2018%2F10%2F11%2F%5B%E6%B4%9B%E8%B0%B7P1967%5D%5BNOIP2013%5D%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93%2F</url>
    <content type="text"><![CDATA[题目题目描述A国有n座城市，编号从1到n，城市之间有m条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有q 辆货车在运输货物，司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。 输入输出格式输入格式：第一行有两个用一个空格隔开的整数n,m表示A国有n座城市和m条道路。 接下来m行每行3个整数 x, y, z每两个整数之间用一个空格隔开，表示从x号城市到y号城市有一条限重为z的道路。注意：x不等于y，两座城市之间可能有多条道路 。 接下来一行有一个整数 q，表示有 q 辆货车需要运货。 接下来 q 行，每行两个整数 x、y，之间用一个空格隔开，表示一辆货车需要从 x 城市运输货物到 y 城市，注意： x 不等于 y 。 输出格式：共有q 行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。如果货车不能到达目的地，输出−1。 输入输出样例输入样例1：123456784 31 2 42 3 33 1 131 31 41 3 输出样例1：1233-13 说明对于 30%的数据，0 &lt; n &lt; 1,000,0 &lt; m &lt; 10,000,0 &lt; q&lt; 1,000； 对于 60%的数据，0 &lt; n &lt; 1,000,0 &lt; m &lt; 50,000,0 &lt; q&lt; 1,000； 对于 100%的数据，0 &lt; n &lt; 10,000,0 &lt; m &lt; 50,000,0 &lt; q&lt; 30,000,0 ≤ z ≤ 100,000 题解 部分内容摘自2013年鉴 其实这道题就是比较简单的图论题（作为最后一天的最后一题来讲）首先对图做最大生成树（方法和最小生成树一样），得到的是一个森林。对于每一辆车，设其起点、终点分别为x,y，如果x,y连通，那么x,y在一棵树上，该火车最多能运送的货物为x,y之间的路径中的最小的边c。因为如果在原图中存在一条路径连接x,y,且所有的边的边权都大于c，那么最大生成树一定求错了（因为将该路径上的边加到生成树中去，必然形成包括c边在内的一个环，此时删除c边可以得到更大的生成树）所以此题变成了求各个点对在树种路径上的最小边。 方法一：暴力就是去实现上面的步骤，求LCA的时候暴力来求，不用倍增，可以AC（具体见暴力），如果是一条链的话会被卡，然而并没有这种数据。 方法二：倍增此时我们可以用倍增的子项求某两个点的路径上的最小边。首先纪录每个点向上（向树根）走$v(v=2^0,2^1,\dots)$步所经过的路径中最小边是多少。对于一个询问x,y，可以求出其最近公共祖先z，然后求x，z之间的最小边和y，z之间的最小边。时间复杂度为$O(mlogm+n+logn)$ 方法三：标称用的方法并不是倍增法，只需要在最大生成树的里面加一个求解的询问就行。首先用一个数组ans表示最终的答案，ans[i]表示第i个询问最多能运的货物数量。再用kruskal算法中，每将一条边加到最大生成树里面，那么这条边会将连个点集合并到一起。如果某个询问i，他的两个点x，y分别属于这两个点集，那么这个询问的答案就是新加入的这条边的边权（因为此时x,y已经在一棵树中，所以x,y之间有路径。由于Kruskal求最大生成树时是由边权从大到小加入的，所以当前边是路径上边权最小的边）我们只需要在每个电商挂一个询问的链，每次询问时将两个询问的链合并到一起，合并的时候选取询问较少的那个链进行扫描并更新答案。所以对链的操作的时间复杂度为[合并次数+每次合并时扫描的询问个数和]。时间的小号主要在扫描，但是我们可以发现，每次扫描都只扫描了较少的那一部分，设长度为L，并且合并后询问的长度增长到2L以上。所以总的时间复杂度为$O(mlogm+qlogq)$ 代码LCA暴力，代码来自本校神犇yanyu1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=11000;const int maxm=51000;int head[maxn],Next[maxm&lt;&lt;1],ver[maxm&lt;&lt;1],weigh[maxm&lt;&lt;1];int f[maxn],fa[maxn],dis[maxn],deep[maxn];int n,m,q,tot;struct node&#123; int x,y,weigh;&#125;edge[maxm&lt;&lt;1]; inline void add(int x,int y,int w)&#123; ver[++tot]=y;weigh[tot]=w;Next[tot]=head[x];head[x]=tot;&#125; bool cmp(node a,node b)&#123; return a.weigh &gt; b.weigh; &#125; int find(int x)&#123; return fa[x]==x?x:fa[x]=find(fa[x]);&#125; void dfs(int x)&#123; for(int i=head[x];i;i=Next[i])&#123; int y=ver[i]; if(deep[y]==0)&#123; dis[y]=weigh[i]; deep[y]=deep[x]+1; f[y]=x; dfs(y); &#125; &#125;&#125; int lca(int x,int y)&#123; int ans=1&lt;&lt;30; if(deep[x]&gt;deep[y]) swap(x,y); while(deep[x]!=deep[y])&#123; ans=min(ans,dis[y]); y=f[y]; &#125; while(x!=y)&#123; ans=min(ans,min(dis[x],dis[y])); x=f[x],y=f[y]; &#125; return ans;&#125; int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;=m;i++) scanf("%d%d%d",&amp;edge[i].x,&amp;edge[i].y,&amp;edge[i].weigh); sort(edge+1,edge+m+1,cmp); for(int i=1;i&lt;=m;i++)&#123; int fx=find(edge[i].x); int fy=find(edge[i].y); if(fx!=fy)&#123; fa[fx]=fy; add(edge[i].x,edge[i].y,edge[i].weigh); add(edge[i].y,edge[i].x,edge[i].weigh); &#125; &#125; for(int i=1;i&lt;=n;i++) if(deep[i]==0) dfs(i); scanf("%d",&amp;q); for(int i=1,x,y;i&lt;=q;i++)&#123; scanf("%d%d",&amp;x,&amp;y); if(find(x)!=find(y)) printf("-1\n"); else printf("%d\n",lca(x,y)); &#125; return 0;&#125; 倍增123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN =50005;int dep[MAXN];int n,m;struct node&#123; int x,y,w;&#125;edge[MAXN];int fa[MAXN];int Nt[MAXN],Head[MAXN],wight[MAXN],to[MAXN],tot;int f[20005][21],w[20005][21];void add(int x,int y,int v)&#123; Nt[++tot]=Head[x]; to[tot]=y; wight[tot]=v; Head[x]=tot;&#125;int Find(int x)&#123; if(fa[x]!=x)fa[x]=Find(fa[x]); return fa[x]; &#125;bool cmp(node a,node b)&#123; return a.w&gt;b.w;&#125;void dfs(int x)&#123; for(int i=Head[x];i;i=Nt[i])&#123; int y=to[i]; if(dep[y])continue; dep[y]=dep[x]+1; f[y][0]=x; w[y][0]=wight[i]; dfs(y); &#125;&#125;void kruskal()&#123; sort(edge+1,edge+m+1,cmp); for(int i=1;i&lt;=n;i++)fa[i]=i; for(int i=1;i&lt;=m;i++)&#123; int fa_x=Find(edge[i].x),fa_y=Find(edge[i].y); if(fa_x==fa_y)continue; fa[fa_x]=fa_y; add(edge[i].x,edge[i].y,edge[i].w); add(edge[i].y,edge[i].x,edge[i].w); &#125;&#125;int lca(int x,int y)&#123; if(Find(x)!=Find(y)) return -1; int ans=1&lt;&lt;30; if(dep[x]&gt;dep[y])swap(x,y); for(int i=20;i&gt;=0;i--)&#123; if(dep[f[y][i]]&gt;=dep[x])&#123; ans=min(ans,w[y][i]); y=f[y][i]; &#125; &#125; if(x==y)return ans; for(int i=20;i&gt;=0;i--)&#123; if(f[x][i]!=f[y][i])&#123; ans=min(ans,min(w[x][i],w[y][i])); y=f[y][i]; x=f[x][i]; &#125; &#125; ans=min(ans, min(w[x][0], w[y][0])); return ans;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d%d",&amp;edge[i].x,&amp;edge[i].y,&amp;edge[i].w); &#125; kruskal(); int q; cin&gt;&gt;q; for(int i=1;i&lt;=n;i++)&#123; if(!dep[i])&#123; dep[i]=1; dfs(i); f[i][0]=i; w[i][0]=1&lt;&lt;30; &#125; &#125; for(int i=1;i&lt;=20;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; f[j][i]=f[f[j][i-1]][i-1]; w[j][i]=min(w[j][i-1],w[f[j][i-1]][i-1]); &#125; &#125; for(int i=1;i&lt;=q;i++)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); printf("%d\n",lca(x,y)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[vijos1056]图形面积]]></title>
    <url>%2F2018%2F10%2F09%2F%5Bvijos1056%5D%E5%9B%BE%E5%BD%A2%E9%9D%A2%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[题目描述桌面上放了N个平行于坐标轴的矩形，这N个矩形可能有互相覆盖的部分，求它们组成的图形的面积。 格式输入格式输入第一行为一个数N（1≤N≤100），表示矩形的数量。下面N行，每行四个整数，分别表示每个矩形的左下角和右上角的坐标，坐标范围为–10^8到10^8之间的整数。 输出格式输出只有一行，一个整数，表示图形的面积。 样例1样例输入1123431 1 4 32 -1 3 24 0 5 2 样例输出1110 题解这里有篇很好的文章，对于深入理解有帮助对于这道题目，第一想法就是用bool数组标记，最后统和，但是奈何数据范围不允许。可以用扫描线+线段树维护，但是总觉得有点大动干戈。而“离散化”这一奇妙的思想能帮我们优雅地解决这道题（然而样例不能很好体现） 我们首先来看看样例其中一样的颜色的点为一对输入（一个矩形），我们取出它们的横纵坐标，去重，排序，然后再去枚举，就得到了那些黑色的点。（有些和有颜色的点重复了）其实到了这一步我们已经离散化了（还没明白?别急，先往下看）于是我们枚举每一个黑色的点，让它和它右上方的黑点构成一个矩形，如果这个矩形在任意输入矩形内部，则对答案有贡献这样子我们就做到了不重不漏(黑点枚举出来的矩形不重复，并且黑点构成的全部矩形肯定把输入矩形囊括在内) 到这里貌似就结束了，但是这种方法看上去还是在数格子？让我们把输入改成123431 1 4 42 -1 3 34 0 5 3 再看看图像我们的枚举量并没有随着坐标范围变大而变大，并且还是做到了不重不漏，其原因就是我们在枚举黑点的时候，本来是2的距离，转化成了该点与上个点相差2，而空间上这两个点还是相邻的，这就是离散化。 上面已经解释得很清楚了，代码就不写注释了。 代码12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=203;long long x[MAXN],y[MAXN],x1[MAXN],x2[MAXN],y1[MAXN],y2[MAXN];long long S,ans;int n;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%lld%lld%lld%lld",&amp;x1[i],&amp;y1[i],&amp;x2[i],&amp;y2[i]); x[2*i-1]=x1[i]; y[2*i-1]=y1[i]; x[2*i]=x2[i]; y[2*i]=y2[i]; &#125; sort(x+1,x+2*n+1); sort(y+1,y+2*n+1);//这里忘了去重，如果有重复的，(x[i+1]-x[i])*(y[j+1]-y[j])必定有一项为0，对答案没贡献 for(int i=1;i&lt;=2*n-1;i++)&#123; for(int j=1;j&lt;=2*n-1;j++)&#123; S=(x[i+1]-x[i])*(y[j+1]-y[j]); for(int k=1;k&lt;=n;k++)&#123; if(x[i]&gt;=x1[k]&amp;&amp;y[j]&gt;=y1[k]&amp;&amp;x[i+1]&lt;=x2[k]&amp;&amp;y[j+1]&lt;=y2[k])&#123; ans+=S; break; &#125; &#125; &#125; &#125; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POJ3191] The Moronic Cowmpouter]]></title>
    <url>%2F2018%2F10%2F08%2F%5BPOJ3191%5D%20The%20Moronic%20Cowmpouter%2F</url>
    <content type="text"><![CDATA[题目题目描述Inexperienced in the digital arts, the cows tried to build a calculating engine (yes, it’s a cowmpouter) using binary numbers (base 2) but instead built one based on base negative 2! They were quite pleased since numbers expressed in base -2 do not have a sign bit. You know number bases have place values that start at 1 (base to the 0 power) and proceed right-to-left to base^1, base^2, and so on. In base -2, the place values are 1, -2, 4, -8, 16, -32, … (reading from right to left). Thus, counting from 1 goes like this: 1, 110, 111, 100, 101, 11010, 11011, 11000, 11001, and so on. Eerily, negative numbers are also represented with 1’s and 0’s but no sign. Consider counting from -1 downward: 11, 10, 1101, 1100, 1111, and so on. Please help the cows convert ordinary decimal integers (range -2,000,000,000 .. 2,000,000,000) to their counterpart representation in base -2. 输入输出格式输入格式：A single integer to be converted to base -2 输出格式：A single integer with no leading zeroes that is the input integer converted to base -2. The value 0 is expressed as 0, with exactly one 0. 输入输出样例输入样例1:1-13 输出样例1：1110111 提示HintExplanation of the sample:Reading from right-to-left:1*1 + 1*-2 + 1*4 + 0*-8 +1*16 + 1*-32 = -13 题目大意输入一个十进制[latex]N(−2,000,000,000≤N≤2,000,000,000)[/latex]，输出它的[latex]−2[/latex]进制数 题解平常我们很少会涉及到负进制，按照提示所给内容，我们应该很快能想到第一种做法，第一种想法，我们去枚举每一个负二进制数，对于每一个负二进制数，我们将它转换成十进制数，看看是不是一样。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n;long long p[32]; void init()&#123; cin&gt;&gt;n; p[0]=1; for(int i=1;i&lt;=31;i++)&#123; p[i]=p[i-1]*-2; &#125;&#125; inline bool jud(int num)&#123; int res=0,cnt=0; while(num)&#123; if(num&amp;1)res+=p[cnt]; ++cnt; num&gt;&gt;=1; &#125; if(res==n)return 1; return 0;&#125; void out(int num)&#123; int tmp[200],t=0; while(num)&#123; if(num&amp;1)tmp[++t]=1; else tmp[++t]=0; num&gt;&gt;=1; &#125; for(int i=t;i&gt;=1;i--)printf("%d",tmp[i]);&#125; int main()&#123; init(); for(long long i=1;i&lt;=2000000000LL;i++)&#123; if(jud(i))&#123; // cout&lt;&lt;"!!"&lt;&lt;i&lt;&lt;endl; out(i); break; &#125; &#125; return 0;&#125; 然而上面的做法会T，那么我们能不能直接从十进制算到负二进制呢？这个需要好好观察一下提示，我们发现如果要确定当前位是0还是1，只要对下一个为1时取余就知道了，如果余数为0，那么当前这个数自然是后面位的倍数了，取0，否则就取1. 然后减去当前还剩的数，继续往后走。 最后减到0就可以了。 代码123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int MAXN=1e5+7;const int inf =1e9;int ans[1000];long long n;long long pw(int a,int b)&#123;//很普通的快速幂 long long sum=1; long long base=a; while(b)&#123; if(b&amp;1)sum*=base; base*=base; b&gt;&gt;=1; &#125; return sum;&#125;int main()&#123; scanf("%lld",&amp;n); int top=0; if(!n)ans[top++]=0;//0的时候特判 while(n)&#123; if(n%(pw(-2,top+1)))ans[top]=1; else ans[top]=0; n-=ans[top]*pw(-2,top);//相当于不断把n这个10进制数拆分成-2进制数 top++; &#125; while(top)printf("%d",ans[--top]); return 0;&#125; 另外，这里还有一道题和这个几乎一样UVA11121 Base -2]]></content>
      <categories>
        <category>数学</category>
        <category>进制</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[LOJ10022]埃及分数]]></title>
    <url>%2F2018%2F10%2F08%2F%5BLOJ10022%5D%E5%9F%83%E5%8F%8A%E5%88%86%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目题目描述在古埃及，人们使用单位分数的和（形如1/a的，a是自然数）表示一切有理数。如：2/3=1/2+1/6，但不允许2/3=1/3+1/3，因为加数中有相同的。对于一个分数a/b，表示方法有很多种，但是哪种最好呢？首先，加数少的比加数多的好，其次，加数个数相同的，最小的分数值越大越好。 如： 19/45=1/3+1/12+1/180 19/45=1/3+1/15+1/45 19/45=1/3+1/18+1/30 19/45=1/4+1/6+1/180 19/45=1/5+1/6+1/18 最好的是最后一种，因为1/18比1/180,1/45,1/30,1/180都大。给出a,b（0&lt;a&lt;b&lt;1000），编程计算最好的表达方式。 输入只有一行，为a,b。（0&lt;a&lt;b&lt;1000） 输出若干个数，自小到大排列，依次是单位分数的分母，每个数字以空格隔开。 样例输入119 45 样例输出15 6 18 题解埃及分数真的是一个神奇的东西，网上很多题解直接就将IDA*算法，但是为什么拿到这道题就会想到IDA*呢？ 我们可以发现，本题的特别之处在于它的状态空间是无限大的。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#define MAXN 5100typedef long long ll;using namespace std;ll a,b;ll dep=0;ll ans[MAXN],v[MAXN];inline ll gcd(ll x,ll y)&#123; return y==0? x : gcd(y,x%y);&#125;inline ll G_first(ll xx,ll yy) &#123;//满足1/c&lt;=xx/yy的最小c return yy/xx+1;&#125;inline bool better() &#123; for(int i=dep;i&gt;=1;i--) if(ans[i]!=v[i]) return ans[i]==0||v[i]&lt;ans[i]; return false; &#125;inline bool dfs(ll now,ll from,ll xx,ll yy)&#123; if(now==dep) &#123; if(yy%xx) return false;//保证最后一个的xx为1（约分后 v[now]=yy/xx; if(better()) for(ll i=1;i&lt;=dep;i++) ans[i]=v[i]; return true; &#125; bool ok=false; from=max(from,G_first(xx,yy)); for(ll i=from; ;i++)&#123; // (dep-now+1)/i &lt;= xx/yy 移项得 if(yy*(dep-now+1)&lt;=i*xx) break;//如果剩下的分数全是1/i加起来也无法超过xx/yy ,则剪去 v[now]=i; ll y2=yy*i,x2=xx*i-yy; ll g=gcd(x2,y2); if(dfs(now+1,i+1,x2/g,y2/g)) ok=true; &#125; return ok;&#125;int main()&#123; scanf("%lld%lld",&amp;a,&amp;b); else &#123; bool ok=false; for(dep=1;;dep++)&#123; memset(ans,0,sizeof(ans)); if(dfs(1,G_first(a,b),a,b))&#123; ok=true; break; &#125; &#125; if(ok) for(int i=1;i&lt;=dep;i++) printf("%d ",ans[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>基本算法</category>
        <category>搜索</category>
        <category>深搜</category>
        <category>A*和IDA*</category>
      </categories>
      <tags>
        <tag>最大公约数</tag>
        <tag>迭代加深</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ10181]绿色通道]]></title>
    <url>%2F2018%2F10%2F07%2F%5BLOJ10181%5D%E7%BB%BF%E8%89%B2%E9%80%9A%E9%81%93%2F</url>
    <content type="text"><![CDATA[传送门 一看到求什么“最大的最小值”，“最小的最大值”就马上想到二分（还有可能是单调队列）再仔细看看题目，貌似没什么头绪，但答案似乎存在单调性，果断二分。答案肯定在0到n范围内。设$f[i]$为做到第$i$个作业时所需要花的最短时间。假如我们可以空$k$道题（二分出来的）$f[i]=min(f[i],f[j]+a[i])$其中 $$i-k+1 \le j &lt; i$$123456789101112131415161718192021222324252627282930313233343536//90分，超时#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int MAXN=50004;int n,t;int a[MAXN],f[MAXN]; bool check(int k)&#123; memset(f,0x3f,sizeof(f)); f[0]=0; for(int i=1;i&lt;=k;i++)f[i]=a[i]; for(int i=k+1;i&lt;=n;i++)&#123; for(int j=i-k-1;j&lt;i;j++)&#123; f[i]=min(f[i],f[j]+a[i]); &#125; &#125; int ans=1&lt;&lt;30; for(int i=n-k;i&lt;=n;i++)ans=min(f[i],ans); if(ans&lt;=t)return 1; return 0;&#125; int main()&#123; cin&gt;&gt;n&gt;&gt;t; for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); int l=0,r=n,ans=0; while(l&lt;=r)&#123; int mid=(l+r)/2; if(check(mid))r=mid-1,ans=mid; else l=mid+1; &#125; cout&lt;&lt;ans; return 0;&#125; 如果你想要满分，就要减少枚举量，就是减少枚举j的次数。我们要维护一个区间最小数，可以用线段树来写，我这里采用的是优先队列。采用优先队列有一个原则，那就是队列里的元素要单调，并且还要有另一个条件限制它们，我比较喜欢叫做“保质期”（因为保质期是不变的但是时间在变）这个题目单调队列里的元素的保质期就是下标，如果他的下表不满足上面的枚举j的条件，这个元素就“过期”了123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;deque&gt;using namespace std;const int MAXN=50004;int n,t;int a[MAXN],f[MAXN];deque&lt;pair&lt;int,int&gt; &gt;q; bool check(int k)&#123; memset(f,0x3f,sizeof(f)); while(q.size())q.pop_front(); f[0]=0; //q.push_back(make_pair(0,0));加上这句话就不用分开处理 for(int i=1;i&lt;=k+1;i++)&#123; f[i]=a[i]; while(q.size()&amp;&amp;q.back().first&gt;=a[i])q.pop_back(); q.push_back(make_pair(a[i],i)); &#125; for(int i=k+2;i&lt;=n;i++)&#123; // cout&lt;&lt;q.front().first&lt;&lt;" "&lt;&lt;q.front().second&lt;&lt;" "&lt;&lt;i-k-1&lt;&lt;endl; while(q.size()&amp;&amp;q.front().second&lt;i-k-1)q.pop_front(); f[i]=min(f[i],q.front().first+a[i]); while(q.size()&amp;&amp;q.back().first&gt;=f[i])q.pop_back(); q.push_back(make_pair(f[i],i)); &#125; int ans=1&lt;&lt;30; for(int i=n-k;i&lt;=n;i++)ans=min(f[i],ans); if(ans&lt;=t)return 1; return 0;&#125; int main()&#123; cin&gt;&gt;n&gt;&gt;t; for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); int l=0,r=n,ans=0; while(l&lt;=r)&#123; int mid=(l+r)/2; if(check(mid))r=mid-1,ans=mid; else l=mid+1; &#125; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>单调队列优化</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ10159]旅游规划]]></title>
    <url>%2F2018%2F10%2F07%2F%5BLOJ10159%5D%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[传送门 题解树的直径不止一条，而题目要求我们把所有直径上的点给输出来。 数组名 数组作用 d1 i点到叶子节点的最长距离 d2 i点到叶子节点的次长距离 d3 i点向除子树外的最远距离 就拿样例来说，下面这个图应该很清楚了（红色的是树的直径） 显然，如果一个点满足d1+d2=树的直径或者d1+d3=树的直径，那么这个点肯定是树的直径上的点 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=200005;int n;int Nt[MAXN&lt;&lt;1],Head[MAXN&lt;&lt;1],to[MAXN&lt;&lt;1],tot;int d1[MAXN],d2[MAXN],d3[MAXN],maxx; inline int read()&#123; char ch;ch=getchar(); int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125; void add(int x,int y)&#123; Nt[++tot]=Head[x]; to[tot]=y; Head[x]=tot;&#125; void dfs(int x,int fa)&#123; for(int i=Head[x];i;i=Nt[i])&#123; int y=to[i]; if(y==fa) continue; dfs(y,x); if(d1[y]+1&gt;d1[x])&#123; d2[x]=d1[x]; d1[x]=d1[y]+1; &#125; else if(d1[y]+1&gt;d2[x]) d2[x]=d1[y]+1; &#125; if(d1[x]+d2[x]&gt;maxx) maxx=d1[x]+d2[x];&#125; void dfs2(int x,int fa)&#123; for(int i=Head[x];i;i=Nt[i])&#123; int y=to[i]; if(y==fa) continue; if(d1[y]+1==d1[x]) d3[y]=max(d3[x],d2[x])+1;//如果子节点是d1更新的方向，那么就在父节点的d2,d3中取最大值 else d3[y]=max(d3[x],d1[x])+1; dfs2(y,x); &#125;&#125; int main()&#123; n=read(); int x,y; for(int i=1;i&lt;n;i++)&#123; x=read(),y=read(); add(x,y); add(y,x); &#125; dfs(0,0); dfs2(0,0); for(int i=0;i&lt;n;++i) if(d3[i]+d1[i]==maxx||d1[i]+d2[i]==maxx) printf("%d\n",i); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[LOJ10220]Fibonacci 第 n 项]]></title>
    <url>%2F2018%2F10%2F06%2F%5BLOJ10220%5DFibonacci%20%E7%AC%AC%20n%20%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[题目题目描述大家都知道Fibonacci数列把，$f_1=1,f_2=1,f_3=2,f_4=3,f_n=f_{n-1}+f_{n-2}$现在问题很简单，输入$n$和$m$，求$f_n mod m$ 输入格式输入$n,m$ 输出格式输出$f_n mod m$ 样例输入15 1000 样例输出15 数据范围与提示对于$100\%$的数据，$1\le n \le 2\times 10^9,1\le m\le 10^9 + 10$ 题解看到这个数据范围，就知道这肯定不能够一般地递推了。于是我们要介绍一个工具来帮助我们计算这个数列——矩阵乘法两个矩阵的乘法仅当第一个矩阵A的列数和第二个矩阵B的行数相等的时候才能定义就举个例子好了 $\begin{bmatrix}1&amp;0&amp;2\ -1&amp;3&amp;1\end{bmatrix} \times \begin{bmatrix} 3&amp;1 \ 2&amp;1\ 1&amp;0\end{bmatrix}=\begin{bmatrix}(1\times3+0\times2+2\times0)&amp;(1\times1+0\times1+2\times0) \ (-1\times3+3\times2+1\times1)&amp;(-1\times1+3\times1+1\times0)\end{bmatrix}$ 那么我们根据这个性质，可以定义两个矩阵，一个是数值矩阵用来存贮递推时的数据，需要有一个初始值，还有一个是递推矩阵用来定义如何递推。在这道里，我们可以初始化数值矩阵为： $\begin{bmatrix}f_2&amp;0\f_1&amp;0\end{bmatrix}$而我们定义递推矩阵为：$\begin{bmatrix}1&amp;1\1&amp;0\end{bmatrix}$ 每次用数值矩阵乘递推矩阵，得到的新矩阵中，数列的下标正好是原来的下标+1，递推得以进行。（请读者自己动手体会一下，不然你永远只为停留在“哇，这个算法好神奇”这个层面）而对于乘法的递推，我们很容易就想到快速幂，于是这道题就完美解决。至于如何定义数值矩阵和递推矩阵，我认为还是要多自己思考，多做几次就会了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int n,mod;long long res[3][3],mul[3][3]; void mul_res()&#123; long long tmp[3][3]; memset(tmp,0,sizeof(tmp)); for(int i=1;i&lt;=2;i++)&#123; for(int j=1;j&lt;=2;j++)&#123; for(int k=1;k&lt;=2;k++)&#123; tmp[i][j]=(tmp[i][j]+mul[i][k]*res[k][j])%mod; &#125; &#125; &#125; memcpy(res,tmp,sizeof(tmp));&#125; void mul_mul()&#123; long long tmp[3][3]; memset(tmp,0,sizeof(tmp)); for(int i=1;i&lt;=2;i++)&#123; for(int j=1;j&lt;=2;j++)&#123; for(int k=1;k&lt;=2;k++)&#123; tmp[i][j]=(tmp[i][j]+mul[i][k]*mul[k][j])%mod; &#125; &#125; &#125; memcpy(mul,tmp,sizeof(tmp));&#125; int main()&#123; cin&gt;&gt;n&gt;&gt;mod; if(n&lt;=2)&#123;cout&lt;&lt;1;return 0;&#125; res[1][1]=res[2][1]=1; mul[1][1]=mul[2][1]=mul[1][2]=1; n-=2;//初始状态我们可以认为已经是f2的时候了 while(n)&#123; if(n&amp;1)mul_res(); mul_mul(); n&gt;&gt;=1; &#125; cout&lt;&lt;res[1][1]; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>矩阵</category>
      </categories>
      <tags>
        <tag>斐波那契数列</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ1041]HAOI2008圆上的整点]]></title>
    <url>%2F2018%2F10%2F05%2F%5BBZOJ1041%5DHAOI2008%E5%9C%86%E4%B8%8A%E7%9A%84%E6%95%B4%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目题目描述求一个给定的圆($x^2+y^2=r^2$)，在圆周上有多少个点的坐标是整数。 输入格式r 输出格式整点个数 样例输入14 样例输出14 说明$n\le2000000000$ 题解转自这篇文章这里先只考虑x，y都大于0的情况 如果$x^2+y^2=r^2$，则$(r-x)(r+x)=y^2$ 令$d=gcd(r-x,r+x)$ 则$(r-x)/d$与$(r+x)/d$一定互质，二者相乘为完全平方数，则二者一定都为完全平方数 令$r-x=d\times a^2$,$r+x=d\times b^2$ 则显然有a,b互质，a&lt;b 其中$$x=\frac{d(b^2-a^2)}{2}$$$$y=d\times a\times b$$$$r=\frac{d\times (a^2+b^2)}{2}$$ 枚举$2r$的因数$d$，对于每个d我们用$O(\sqrt{\frac{r}{d}})$的时间枚举$a$ 代入$r$的计算式得出$b^2$ 计算$b^2$是否为完全平方数及$a^2$与$b^2$是否互质 这样可以枚举出一个象限内的整点个数 然后输出$(ans+1)\times 4$即可 代码1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;ll r,ans;ll gcd(ll a,ll b)&#123; return b? gcd(b,a%b):a;&#125;void solve(ll x)&#123; ll top=(ll)sqrt(x/2); for(int a=1;a&lt;=top;a++)&#123; ll A=a*a; ll B=x-A; ll b=(ll)sqrt(B); if(gcd(A,B)==1&amp;&amp;B==b*b&amp;&amp;A!=B)&#123; ans++; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;r; ll top=(ll)sqrt(2*r); for(int i=1;i&lt;=top;i++)&#123; if(2*r%i==0)&#123; solve(i); solve(2*r/i); &#125; &#125; cout&lt;&lt;ans*4+4;//+4个坐标轴上的点 return 0;&#125; 附这题还有一个更美妙的解法，0msAC，具体就是下面这个视频如果你不想花时间看的话也可以看这篇文章，基本上就是整个视频对我们有用的知识的提炼 代码如下:12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long long r; int ans=1; cin&gt;&gt;r; for(int i=2;i&lt;=sqrt(r);i++)&#123; int p=0; while(r%i==0)&#123; if(i%4!=3)&#123; p+=2; &#125; r/=i; &#125; if(i!=2) ans*=(p+1); &#125; if(r!=1)&#123; if(r%4!=3)&#123; ans*=3; &#125; &#125; cout&lt;&lt;ans*4&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[LOJ10172]涂抹果酱]]></title>
    <url>%2F2018%2F10%2F04%2F%5BLOJ10172%5D%E6%B6%82%E6%8A%B9%E6%9E%9C%E9%85%B1%2F</url>
    <content type="text"><![CDATA[题目题目描述Tyvj 两周年庆典要到了，Sam 想为 Tyvj 做一个大蛋糕。蛋糕俯视图是一个 N×M的矩形，它被划分成 N×M个边长为 1×1的小正方形区域（可以把蛋糕当成 N 行 M 列的矩阵）。蛋糕很快做好了，但光秃秃的蛋糕肯定不好看！所以，Sam 要在蛋糕的上表面涂抹果酱。果酱有三种，分别是红果酱、绿果酱、蓝果酱，三种果酱的编号分别为 1,2,3。为了保证蛋糕的视觉效果，Admin 下达了死命令：相邻的区域严禁使用同种果酱。但 Sam 在接到这条命令之前，已经涂好了蛋糕第 K 行的果酱，且无法修改。现在 Sam 想知道：能令 Admin 满意的涂果酱方案有多少种。请输出方案数 $ mod 10^6$若不存在满足条件的方案，请输出 0。 输入格式输入共三行。第一行：N,M；第二行：K；第三行：M 个整数，表示第 K 行的方案。字母的详细含义见题目描述，其他参见样例。 输出格式输出仅一行，为可行的方案总数。 样例输入样例1232 2 1 2 3 输出样例13 样例说明 数据范围和提示对于 30% 的数据，1≤N×M≤20；对于 60% 的数据，1≤N≤1000,1≤M≤3；对于 100% 的数据，1≤N≤10000,1≤M≤5。 题解一开始拿到这道题目发现不就是状态压缩嘛，而且是相邻不重复的计数问题，这种题目早就已经轻车熟路了。但是仔细看了才发现不简单，不是普通的二进制状压，而是三进制状压。 但是进制本质上都是一样的，我们一边参照二进制状压，一边实现三进制状压。 首先是左移右移，实际上二进制的左移右移就是$\times 2$还有/2，既然是三进制，当然是*3还有/3 还有就是实现状态合法判定，具体的在check函数和judge函数的注释里，这两个函数稍微有点不同。 状态转移的话就是上一行的所有合法状态之和（这个和二进制状压是一样的） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=10004,mod=1000000;int n,m,k,pos;int ban,ans=0;int can[1005],tot=0;int f[MAXN][1005];inline bool check(int x)&#123;//自身合法性判断，每次弹出最末尾的一个数，存起来，看看和下一个数是不是一样 int tmp=0x3f; for(int i=1;i&lt;=m;++i)&#123; if(tmp==x%3)return false; tmp=x%3,x/=3; &#125; return true;&#125;inline bool judge(int a,int b)&#123;//相互合法性判断，就是按位比对 for(int i=1;i&lt;=m;++i)&#123; if(a%3==b%3)return false; a/=3,b/=3; &#125; return true;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; int in=1; for(int i=0;i&lt;m;i++)in*=3; for(int i=0;i&lt;in;++i)if(check(i))can[++tot]=i; for(int i=1;i&lt;=m;++i)&#123; int tmp; scanf("%d",&amp;tmp); ban=ban*3+tmp-1; &#125; for(int i=1;i&lt;=tot;++i)if(ban==can[i])&#123;pos=i;break;&#125; if(!pos)&#123;cout&lt;&lt;0;return 0;&#125; for(int i=1;i&lt;=n;++i)&#123; if(i==k)&#123; if(i==1)f[i][pos]=1; else for(int j=1;j&lt;=tot;++j)if(judge(can[pos],can[j]))(f[i][pos]+=f[i-1][j])%=mod; &#125; else for(int j=1;j&lt;=tot;++j)&#123; if(i==1)f[i][j]=1; else for(int k=1;k&lt;=tot;++k)if(judge(can[j],can[k]))(f[i][j]+=f[i-1][k])%=mod; &#125; &#125; for(int i=1;i&lt;=tot;++i)(ans+=f[n][i])%=mod; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>状压dp</category>
      </categories>
      <tags>
        <tag>状态压缩</tag>
        <tag>三进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF776B]Sherlock and his girlfriend]]></title>
    <url>%2F2018%2F10%2F03%2F%5BCF776B%5DSherlock%20and%20his%20girlfriend%2F</url>
    <content type="text"><![CDATA[题目题目描述Sherlock has a new girlfriend (so unlike him!). Valentine’s day is coming and he wants to gift her some jewelry. He bought n pieces of jewelry. The i-th piece has price equal to i + 1, that is, the prices of the jewelry are 2, 3, 4, … n + 1. Watson gave Sherlock a challenge to color these jewelry pieces such that two pieces don’t have the same color if the price of one piece is a prime divisor of the price of the other piece. Also, Watson asked him to minimize the number of different colors used. Help Sherlock complete this trivial task. 输入The only line contains single integer n (1 ≤ n ≤ 100000) — the number of jewelry pieces. 输出The first line of output should contain a single integer k, the minimum number of colors that can be used to color the pieces of jewelry with the given constraints. The next line should consist of n space-separated integers (between 1 and k) that specify the color of each piece in the order of increasing price. If there are multiple ways to color the pieces using k colors, you can output any of them. 样例输入输出样例1输入13 输出1221 1 2 样例2输入14 输出1222 1 1 2 解释In the first input, the colors for first, second and third pieces of jewelry having respective prices 2, 3 and 4 are 1, 1 and 2 respectively. In this case, as 2 is a prime divisor of 4, colors of jewelry having prices 2 and 4 must be distinct. 题解显然如果$i + 1$是一个质数，那么只有价格为$i + 1$的倍数的珠宝必须具有不同的颜色所以我们枚举$2$到$n+1$，并且如果枚举到的珠宝没涂色，说明是个质数，让他的倍数涂色最后我们留下来的就是质数和非质数，而质数之间不可能互为质因数，非质数之间也不能为质因数，所以只要你将他们分别输出不同的数字就行 代码123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;bool s[100005];int main()&#123; int n; cin&gt;&gt;n; for(int i=2;i&lt;=n+1;i++)&#123; if(!s[i])&#123; for(int j=i&lt;&lt;1;j&lt;=n+1;j+=i)s[j]=1; &#125; &#125; if(n&gt;2)cout&lt;&lt;"2\n"; else cout&lt;&lt;"1\n"; for(int i=2;i&lt;=n+1;i++)&#123; if(!s[i])cout&lt;&lt;"1 "; else cout&lt;&lt;"2 "; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1896][SCOI2005]互不侵犯]]></title>
    <url>%2F2018%2F09%2F20%2F%5B%E6%B4%9B%E8%B0%B7P1896%5D%5BSCOI2005%5D%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AF%2F</url>
    <content type="text"><![CDATA[题目题目描述在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。 注：数据有加强（2018/4/25） 输入输出格式输入格式只有一行，包含两个数N，K （ 1 &lt;=N &lt;=9, 0 &lt;= K &lt;= N * N） 输出格式所得的方案数 输入样例13 2 输出样例116 题解建议先食用这道题这道题，其实也是一道模板题，只不过情况稍微复杂了一点，状态稍微难转移一点。 函数\变量名 作用 $f[i][j][m]$ 第$i$行，第$j$个状态，放了$m$个国王 $get_one(x)$ 返回二进制数$x$的1的个数 $can[i]$ 预处理合法状态 $num[i]$ $i$状态有多少个1 和玉米田不同的是，这里$f$的第二维是第$j$个状态而不是状态$j$ 预处理$can$以及$f[1]$：不能有相邻的国王，左移后若没有重叠则合法顺便将当前状态的第一行赋值为1 后面就和玉米田差不多了，注释里只有与玉米田不同的注释 代码12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n,k,cnt;long long f[10][1000][100];//第i行，第j个状态，放了m个国王int can[1000],num[1000];int get_one(int x)&#123; int ans=0; for(;x&gt;0;x&gt;&gt;=1)ans+=x&amp;1; return num[cnt]=ans;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;k; int top=(1&lt;&lt;n)-1; for(int i=0;i&lt;=top;i++)&#123; if(((i&lt;&lt;1)&amp;i)==0)can[++cnt]=i,f[1][cnt][get_one(i)]=1; &#125; for(int i=2;i&lt;=n;i++)&#123; for(int j=1;j&lt;=cnt;j++)&#123; int x=can[j]; for(int z=1;z&lt;=cnt;z++)&#123; int y=can[z]; if ((x&amp;y)||(x&amp;(y&lt;&lt;1))||(x&amp;(y&gt;&gt;1))) continue;//左下角和右下角都不能放 for (int l=0;l&lt;=k;l++) f[i][j][num[j]+l]+=f[i-1][z][l];//l是上个状态的国王数量，而我们找到的合法状态国王数量应该是上个国王数量加上当前状态的国王数量 &#125; &#125; &#125; long long res=0;//注意long long for (int i=1;i&lt;=cnt;i++) res+=f[n][i][k]; printf("%lld",res); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>状态压缩动规</category>
      </categories>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1879][USACO06NOV]玉米田Corn Fields]]></title>
    <url>%2F2018%2F09%2F20%2F%5B%E6%B4%9B%E8%B0%B7P1879%5D%5BUSACO06NOV%5D%E7%8E%89%E7%B1%B3%E7%94%B0Corn%20Fields%2F</url>
    <content type="text"><![CDATA[题目题目描述Farmer John has purchased a lush new rectangular pasture composed of M by N (1 ≤ M ≤ 12; 1 ≤ N ≤ 12) square parcels. He wants to grow some yummy corn for the cows on a number of squares. Regrettably, some of the squares are infertile and can’t be planted. Canny FJ knows that the cows dislike eating close to each other, so when choosing which squares to plant, he avoids choosing squares that are adjacent; no two chosen squares share an edge. He has not yet made the final choice as to which squares to plant. Being a very open-minded man, Farmer John wants to consider all possible options for how to choose the squares for planting. He is so open-minded that he considers choosing no squares as a valid option! Please help Farmer John determine the number of ways he can choose the squares to plant. 农场主John新买了一块长方形的新牧场，这块牧场被划分成M行N列(1 ≤ M ≤ 12; 1 ≤ N ≤ 12)，每一格都是一块正方形的土地。John打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。 遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是John不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。 John想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案） 输入输出格式输入格式：第一行：两个整数M和N，用空格隔开。 第2到第M+1行：每行包含N个用空格隔开的整数，描述了每块土地的状态。第i+1行描述了第i行的土地，所有整数均为0或1，是1的话，表示这块土地足够肥沃，0则表示这块土地不适合种草。 输出格式：一个整数，即牧场分配总方案数除以100,000,000的余数。 输入样例1232 31 1 10 1 0 输出样例19 题解一道状态压缩入门题，也是第一道我在不看任何题解的情况下写出来的状压dp题状压dp一般会有明显的数据范围特征，即n,m一般都在20以内 状压dp的状态设计和转移是有套路的，就拿这道题来说，$f[i][j]$表示第$i$行在状态$j$的时候的方案数，其中$j$我们用一个二进制数来表示。转移的时候只要判断与当前行和上一行是否冲突即可，如果不冲突，$f[i][j]=\sum_{z为不冲突的状态} f[i-1][z]$ $\sum_{1\le i\le cnt} f[n][i]$ 就是最后的答案（$cnt$为状态总数） 至于为什么在下面的代码里先枚举本层，在枚举上一层：因为我们动态规划是靠状态转移来实现的，上一行相当于处在i-1阶段，我们需要不断用上一个阶段来更新下一个阶段（逆推），因此本层循环在外侧。 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int mod=100000000;int f[13][5000];int ok[13];//纪录每一行输入的数据，也是用二进制保存int n,m;int can[5000],cnt;//预处理出所有合法状态int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; int a; cin&gt;&gt;a; ok[i]&lt;&lt;=1;//这里的顺序一定要注意 ok[i]|=a; &#125; &#125; int MAXN=(1&lt;&lt;m)-1;//假设m为5最大的状态显然为1 1 1 1 1 for(int i=0;i&lt;=MAXN;i++)if((i&amp;(i&lt;&lt;1))==0)can[++cnt]=i;//自己如果和自己左移重叠了，说明有相邻的，不合法，只有不重叠才合法，注意从0开始 for(int i=1;i&lt;=cnt;i++)&#123; if(can[i]&amp;(~ok[1]))continue;//第一行单独处理，~按位取反 f[1][i]=1; &#125; for(int i=2;i&lt;=n;i++)&#123; for(int j=1;j&lt;=cnt;j++)&#123;//枚举当前行 int x=can[j]; for(int z=1;z&lt;=cnt;z++)&#123;//枚举上一行 int y=can[z]; if(x&amp;y||x&amp;(~ok[i])||y&amp;(~ok[i-1]))continue; f[i][j]=(f[i][j]+f[i-1][z])%mod; &#125; &#125; &#125; int ans=0; for(int i=1;i&lt;=cnt;i++)ans=(ans+f[n][i])%mod; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>状态压缩动规</category>
      </categories>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[开学考试]最大平方数]]></title>
    <url>%2F2018%2F09%2F08%2F%5B%E5%BC%80%E5%AD%A6%E8%80%83%E8%AF%95%5D%E6%9C%80%E5%A4%A7%E5%B9%B3%E6%96%B9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目题目描述给出 $N$ ,求 $1$ 到 $N$ 个数中选出任意个数相乘能组成的最大平方数,由于此数可能很大,你只需要输出此数除 $100000007$ 的余数即可。 样例输入17 样例输出1144 样例解释$2\times 3 \times 4\times 6=144$ 数据下载由于各大oj可能没有，故在此提供测试数据 题解题目就是这么简单，然而考试并没有想到$QAQ$因为是任意个数相乘，我们可以将$N!$进行质因数分解然后因为$A^2\times B^2=(A\times B)^2$我们就可以把所有的2的整数倍次方全部乘入答案里，就是最大的平方数。 而普通的方法分解$N!$需要$O(N\sqrt{N})$的时间复杂度，我们可以考虑一种新方法。 显然，$N!$的每个质因子都不会超过$N$，我们可以先筛选出$1-N$的每个质数$p$，然后考虑阶乘中一共包含多少个质因子$p$ $N!$中质因子$p$的个数就等于$1-N$每个数包含的质因子$p$的个数之和。在$1-N$中，$p$的倍数，即至少包含1个质因子$p$的显然有$\lfloor N/p \rfloor$个。而$p^2$的倍数，即至少包含2个质因子$p$的有$\lfloor N/p^2 \rfloor$个。不过其中的一个质因子已经在$\lfloor N/p \rfloor$中统计过，所以只需要再统计第2个质因子，即累加上$\lfloor N/p^2 \rfloor$，而不是$2\times \lfloor N/p^2 \rfloor$ 综上所述，$N!$中质因子$p$的个数为： $$ \left\lfloor \dfrac{N}{P} \right\rfloor+\left\lfloor \dfrac{N}{P^2} \right\rfloor+\left\lfloor \dfrac{N}{P^3} \right\rfloor+\dots+\left\lfloor \frac{N}{P^{\lfloor log_p N \rfloor}} \right\rfloor=\sum_{p^k\le N}\left\lfloor \dfrac{N}{P^k} \right\rfloor $$ 上面的计算只需要$O(logN)$的时间整个过程只需要$O(NlogN)$的时间 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int mod=100000007;int n,ans=1;bool v[10000010];vector&lt;int&gt; prime;void get_prime(int n)&#123; for(int i=2;i&lt;=n;i++)&#123; if(v[i])continue; prime.push_back(i); for(int j=i;j&lt;=n/i;j++)v[i*j]=1; &#125;&#125;int main()&#123; cin&gt;&gt;n; get_prime(n); for(int i=0;i&lt;prime.size();i++)&#123; int p=prime[i],c=0; for(int j=n;j;j/=p)c+=j/p; if(c==0)continue; if(c&amp;1)&#123; for(int i=1;i&lt;c;i++)ans=(long long)ans*p%mod;//这里要么取两次mod，要么用long long，后者快一点，当然可以用快速幂，更快（我懒orz &#125; else for(int i=1;i&lt;=c;i++)ans=(long long)ans*p%mod;//这里要么取两次mod，要么用long long，后者快一点，当然可以用快速幂，更快 &#125; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[国际信息学奥赛]官方视频搬运]]></title>
    <url>%2F2018%2F09%2F08%2F%5B%E5%9B%BD%E9%99%85%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%A5%A5%E8%B5%9B%5D%E5%AE%98%E6%96%B9%E8%A7%86%E9%A2%91%E6%90%AC%E8%BF%90%2F</url>
    <content type="text"><![CDATA[今年的国际信息学奥赛的比赛已经告一段落，官网也发布了一些视频，蒟蒻看没人搬就搬过来了。 【国际信息学奥赛】IOI 2018 JAPAN Arrival Sep.1 【国际信息学奥赛】IOI 2018 JAPAN Opening Ceremony Sep.2 【国际信息学奥赛】IOI 2018 JAPAN Contest Day 1 Sep.3 【国际信息学奥赛】IOI 2018 JAPAN Excursion 1 Sep.4 【国际信息学奥赛】IOI 2018 JAPAN Contest Day 2 Sep.5 【国际信息学奥赛】IOI 2018 JAPAN Excursion 2 Sep.6 【国际信息学奥赛】IOI 2018 JAPAN Closing Ceremony Sep.7 这些视频都是一些剪辑，至于比赛，开幕式等完整过程，在ioi官网有，不过是在NicoNico以直播的形式放送的，搬运难度大，而且费时间，NOIP前并没有搬运的打算。]]></content>
  </entry>
  <entry>
    <title><![CDATA[个人dp小结]]></title>
    <url>%2F2018%2F08%2F29%2F%E4%B8%AA%E4%BA%BAdp%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言：最近做了很多动态规划题，但是每次遇到新的题目的时候还是做不出来，于是就像做一个小结，梳理下近些天做的题目，从中获取经验。 第零节：DP的基础概念动态规划和其他某些算法具有一定的相似度，都是利用问题的可划分性以及子问题的相似性来进行归纳，降低时间复杂度。来说说动态规划的几个基本条件： 条件 解释 无后效性 已求解的子问题不受后续阶段的影响$^{[1]}$ 最优子结构 下一个阶段的最优解应该能够由前面各阶段子问题的最优解导出 子问题重叠 动态规划通过对每个子问题只解一次，把解保存在一个需要时就可以查看的表中$^{[2]}$ [1]：在《算法竞赛进阶指南》中有一个很好的说法，“动态规划对状态空间的遍历构成一张有向无环图，遍历顺序就是该图的一个拓扑序。”[2]：其实就是动态规划会用查询的方式解决重复出现的子问题，而不是像递归那样每次算一遍。 构成动态规划的三要素： 要素 解释 状态 即我们通常所说的f或dp数组，他们用来表示什么 阶段 即各个状态在不同时刻的表示 决策 状态如何转移到 下一个状态 知道了这些并没有什么用，重要的还是在题目中体会。 第一节：线性DP我们在解决一些线性区间上的最优化问题的时候，往往也能够利用到动态规划的思想，这种问题可以叫做线性dp。 线性空间 在有关线性dp问题中，有着几个比较经典而基础的模型，例如最长上升子序列(LIS)、最长公共子序列(LCS)、最大子序列和等，那么首先我们从这几个经典的问题出发开始对线性dp的探索。 注：下表引用自《算法竞赛进阶指南》P258表 LIS问题 问题描述 最长上升子序列。给定一个长度为$N$的数列$A$，求数值单调递增的子序列的长度是多少。$A$的任意子序列$B$可表示为$B={A_{k1},A_{k2},…,A_{kp}}$，其中$k_1&lt;k_2&lt;…&lt;k_p$ 状态表示 $F[i]$表示以$A[i]$为结尾的“最长上升子序列”的长度 阶段划分 子序列的位置（数列$A$中的位置，从前到后） 转移方程 $F[i]=max{F[j]+1},0\le j&lt;i,A[j]&lt;A[i]$ 边界 $F[0]=0$ 目标 $max{F[i]},1\le i \le N$ 还有两个大家自行看书~（打这个太累啦）通过这三个问题，我们可以了解到，线性DP无论是多维还是一维，“线性”都体现在“作用在空间上的递推”————DP的阶段沿着各个维度线性增长，从一个或多个“边界点”开始有方向地向整个状态空间转移、扩展，最后每个状态上都保留了以自身为目标子问题的最优解。下面我们开始线性DP的进阶，我们从例题开始。 【例1】Mr. Young’s Picture Permutations$^{poj2279}$这是一个五维的线性DP，从该题给出的解法中我们发现，设计动态规划的状态转移方程，不一定要以“如何计算出一个状态”的形式给出，也可以考虑“一个已知状态应该更新哪些后续阶段的未知状态”。 第二节：背包其实我们OIer很多时候都是靠眼睛学习的，偶尔通过听觉也是不错的。 ⭐0/1背包⭐完全背包⭐多重背包⭐分组背包区间DP树形DP⭐背包类树形DP推荐个视频]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SP15637][POJ2279]GNYR04H - Mr Youngs Picture Permutations]]></title>
    <url>%2F2018%2F08%2F26%2F%5BSP15637%5D%5BPOJ2279%5DGNYR04H%20-%20Mr%20Youngs%20Picture%20Permutations%2F</url>
    <content type="text"><![CDATA[题目题目描述杨先生希望为他的班级拍照。学生将排成一行，每行不超过后面的行，并且行的左端对齐。例如，可以安排12名学生排列（从后到前）5,3,3和1名学生。1234X X X X XX X XX X XX 此外，杨先生希望每排学生安排高度从左到右减少。此外，学生身高应从后向前减少。想想看，杨先生看到，对于这个12人的例子，至少有两种安排学生的方式（数字代表高度，其中1代表最高）：12341 2 3 4 5 1 5 8 11 126 7 8 2 6 99 10 11 3 7 1012 4 杨先生想知道，对于给定排列的排列，可能有多少不同的学生安排。他尝试用长度为3,2和1的行开始计数，并计数16个排列：123123 123 124 124 125 125 126 126 134 134 135 135 136 136 145 14645 46 35 36 34 36 34 35 25 26 24 26 24 25 26 256 5 6 5 6 4 5 4 6 5 6 4 5 4 3 3 杨先生认为，手动点数对于任何合理数量的学生来说都不会很有效。他通过编写计算机程序来帮助你确定一组给定行的学生的不同安排数量。 输入格式输入描述了一系列测试，每个测试分两行描述。第一行将行数k作为十进制整数。第二行包含从后到前的行的长度（n {1} 1 ，n {2} 2 ，…，n _ {K} ķ ）作为由单个空格分隔的十进制整数。问题集以行计数为0的行结束。最多不会超过5行，学生总数N（行长度总和）最多不超过30行。 输出格式对于每个测试用例输出一个整数：N个学生排列在给定行中的数量，以便高度从左到右沿着每行减少，并且从后到前沿着每列减小（假定所有高度都不同）。结果应该分开。输入数据将被选择，以便结果总是适合一个无符号的32位整数。 输入样例1234567891011121313051 1 1 1 133 2 145 3 3 156 5 4 3 2215 150 输出样例123456111641581418926089694845 翻译by@_UMR_ 题解看到网上很多人说《算法竞赛进阶指南》上的方法不行，会MLE那动态开空间不就是了……在合法的方案中，每一行，每一列都是单调的，也就是说我们要确保每一次放的时候，放的人要小于左边的，上面的。其实这也很好办，假设我们放的人的高度是递减的，第一行我们只要放得去，就能满足单调，而下面几行，只要各自人数小于等于上面一行的人数就OK了。让我们来看看这一题的“动态规划信息表” 信息 表示方式 解释 状态 $F_{a_1,a_2,a_3,a_4,a_5}$ 表示各排从左端起，分别占了$a_1,a_2,a_3,a_4,a_5$个人时，合影方案数量 边界 $F_{0,0,0,0,0}=1$ 其余为0 目标 $F_{N_1,N_2,N_3,N_4,N_5}$ 无 转移 无 若$a_1&lt;N_1$,则令$F_{a_1+1,a_2,a_3,a_4,a_5}+=F_{a_1,a_2,a_3,a_4,a_5}$。若$a_2&lt;N_2\&amp;\&amp;a_1&gt;a_2$则令$F_{a_1,a_2+1,a_3,a_4,a_5}+=F_{a_1,a_2,a_3,a_4,a_5}$ 第3~5同理 至于杨氏矩阵和钩长公式，还请大家自行了解。 代码1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int k,a[6],n[6];int main()&#123; while(scanf("%d",&amp;k))&#123; if(k==0)break; memset(n,0,sizeof(n)); for(int i=1;i&lt;=k;i++) scanf("%d",&amp;n[i]); int f[n[1]+1][n[2]+1][n[3]+1][n[4]+1][n[5]+1]; memset(f,0,sizeof(f)); f[0][0][0][0][0]=1; for(a[1]=0;a[1]&lt;=n[1];a[1]++) for(a[2]=0;a[2]&lt;=n[2];a[2]++) for(a[3]=0;a[3]&lt;=n[3];a[3]++) for(a[4]=0;a[4]&lt;=n[4];a[4]++) for(a[5]=0;a[5]&lt;=n[5];a[5]++)&#123; int t=f[a[1]][a[2]][a[3]][a[4]][a[5]]; if(a[1]&lt;n[1]) f[a[1]+1][a[2]][a[3]][a[4]][a[5]]+=t; if(a[2]&lt;n[2]&amp;&amp;a[1]&gt;a[2]) f[a[1]][a[2]+1][a[3]][a[4]][a[5]]+=t; if(a[3]&lt;n[3]&amp;&amp;a[2]&gt;a[3]) f[a[1]][a[2]][a[3]+1][a[4]][a[5]]+=t; if(a[4]&lt;n[4]&amp;&amp;a[3]&gt;a[4]) f[a[1]][a[2]][a[3]][a[4]+1][a[5]]+=t; if(a[5]&lt;n[5]&amp;&amp;a[4]&gt;a[5]) f[a[1]][a[2]][a[3]][a[4]][a[5]+1]+=t; &#125; printf("%d\n",f[n[1]][n[2]][n[3]][n[4]][n[5]]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>线性dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2014]联合权值]]></title>
    <url>%2F2018%2F08%2F25%2F%5BNOIP2014%5D%E8%81%94%E5%90%88%E6%9D%83%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目题目描述无向连通图G 有n 个点，n – 1 条边。点从1 到n 依次编号，编号为 i 的点的权值为W i ，每条边的长度均为1 。图上两点( u , v ) 的距离定义为u 点到v 点的最短距离。对于图G 上的点对( u, v) ，若它们的距离为2 ，则它们之间会产生Wu×Wv 的联合权值。请问图G 上所有可产生联合权值的有序点对中，联合权值最大的是多少？所有联合权值之和是多少？ 输入格式输入文件名为link .in。第一行包含1 个整数n 。接下来n – 1 行，每行包含 2 个用空格隔开的正整数u 、v ，表示编号为 u 和编号为v 的点之间有边相连。最后1 行，包含 n 个正整数，每两个正整数之间用一个空格隔开，其中第 i 个整数表示图G 上编号为i 的点的权值为W i 。 输出格式输出文件名为link .out 。输出共1 行，包含2 个整数，之间用一个空格隔开，依次为图G 上联合权值的最大值和所有联合权值之和。由于所有联合权值之和可能很大，输出它时要对10007 取余。「数据说明」对于30% 的数据，1 &lt; n≤ 100 ；对于60% 的数据，1 &lt; n≤ 2000；对于100%的数据，1 &lt; n≤ 200 , 000 ，0 &lt; wi≤ 10, 000 。 输入样例1234565 1 2 2 33 4 4 5 1 5 2 3 10 输出样例120 74 题解这道题其实是道水题（逃ε=ε=ε=┏(゜ロ゜;)┛我们首先要发现的一点就是如果我们确定了一个点，他所遍历到的所有点它们互相的距离就是$2$。所以我们就可以枚举每一个点，枚举它每一个可通往的点，最大值取$$Mx=max(Mx,该点遍历的最大值\times该点遍历到的次大值)$$而总和我们就取$$Ans=\sum V[遍历过的边] \times V[当前边]$$注意要最后答案要乘2，因为(1,3)(3,1)要算两次 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN = 200004, mod = 10007;int Head[MAXN], Nt[MAXN * 2], to[MAXN * 2];int tot, n;int v[MAXN];int mx, ans;void add(int a, int b) &#123; Nt[++tot] = Head[a]; to[tot] = b; Head[a] = tot;&#125;void get(int x) &#123; int sum = 0, ma = 0, m = 0;//当前总和，最大值，次大值 for (int i = Head[x]; i; i = Nt[i]) &#123; if (v[to[i]]&gt;ma) &#123; m = ma; ma = v[to[i]]; &#125; else if (v[to[i]]&gt;m)m = v[to[i]]; ans = (ans + sum * v[to[i]]) % mod; sum = (sum + v[to[i]]) % mod; &#125; mx= max(mx, ma*m);&#125;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt; n; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); add(a, b); add(b, a); &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;v[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; get(i); &#125; cout &lt;&lt; mx &lt;&lt; " " &lt;&lt; ans*2%mod &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>树的遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P4011]孤岛营救问题]]></title>
    <url>%2F2018%2F08%2F25%2F%5B%E6%B4%9B%E8%B0%B7P4011%5D%E5%AD%A4%E5%B2%9B%E8%90%A5%E6%95%91%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目题目描述$1944$ 年，特种兵麦克接到国防部的命令，要求立即赶赴太平洋上的一个孤岛，营救被敌军俘虏的大兵瑞恩。瑞恩被关押在一个迷宫里，迷宫地形复杂，但幸好麦克得到了迷宫的地形图。迷宫的外形是一个长方形，其南北方向被划分为 $N$ 行，东西方向被划分为 $M$ 列，于是整个迷宫被划分为 $N\times M$ 个单元。每一个单元的位置可用一个有序数对(单元的行号，单元的列号)来表示。南北或东西方向相邻的 $2$ 个单元之间可能互通，也可能有一扇锁着的门，或者是一堵不可逾越的墙。迷宫中有一些单元存放着钥匙，并且所有的门被分成 $P$ 类，打开同一类的门的钥匙相同，不同类门的钥匙不同。 大兵瑞恩被关押在迷宫的东南角，即 $(N,M)$ 单元里，并已经昏迷。迷宫只有一个入口，在西北角。也就是说，麦克可以直接进入 $(1,1)$ 单元。另外，麦克从一个单元移动到另一个相邻单元的时间为$1$ ，拿取所在单元的钥匙的时间以及用钥匙开门的时间可忽略不计。 试设计一个算法，帮助麦克以最快的方式到达瑞恩所在单元，营救大兵瑞恩。 输入格式 输出格式将麦克营救到大兵瑞恩的最短时间的值输出。如果问题无解，则输出 -1 。 输入样例12345678910111213144 4 991 2 1 3 21 2 2 2 02 1 2 2 02 1 3 1 02 3 3 3 02 4 3 4 13 2 3 3 03 3 4 3 04 3 4 4 022 1 24 2 1 输出样例114 说明 题解基本方法虽然它是网络流24题，但是其实根本不用网络流做。首先我们来看看这个题目的数据范围，挺有意思的。$N,M,P\le10$钥匙种类和地图大小都很小，嗯，感觉可以广搜，置于钥匙，我们就可以状态压缩一下 变量名 变量作用 $vis_{i,j,k}$ 记录你是否揣着$k$这个集合的钥匙到过$(i,j)$处 $map_{x1,y1,x2,y2}$ 表示$(x1,y1)$到$(x2,y2)$是个什么情况 $key_{i,j,k}$ 表示$(i,j)$存放的第$k$把钥匙 $num_{i,j}$ 表示在$(i,j)$处有几把钥匙 $tt$ 当前携带的钥匙集合 状态压缩至于状态压缩的话，假设现在有5种钥匙，我们用1表示现在身上有，0没有。初始情况： 0 0 0 0 0 现在，我们来了第二把钥匙（从右往左） 0 0 0 1 0 这东西是不是很像二进制？所以我们就可以用二进制来进行状压。每次我们得到钥匙时，$tt|=1&lt;&lt;(key[i][j][k]-1)$每次查询是否有第i把钥匙时，只要$tt\&amp;(1&lt;&lt;(i-1))$为真，我们就可以认为有这把钥匙。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int dx[4] = &#123; -1,1,0,0 &#125;;const int dy[4] = &#123; 0,0,-1,1 &#125;;struct node &#123; int x, y, step, key;&#125;;queue&lt;node&gt;q;bool v[11][11][1 &lt;&lt; 11];//v[x][y][tt]表示点(x,y)带有这么多的钥匙是否来过int n, m, p, k;int mp[11][11][11][11];//mp[x1][y1][x2][y2]表示两个点直接是否有墙或者是门，0表示可以直接通过int key[11][11][11];//key[x][y][i]表示点（x,y）放的第i把钥匙int num[11][11];//num[x][y]表示点（x,y)有多少把钥匙int bfs() &#123; int tt = 0; for (int i = 1; i &lt;= num[1][1]; i++) &#123; tt |= (1 &lt;&lt; (key[1][1][i] - 1));//初始点可以放钥匙 &#125; v[1][1][tt] = 1; q.push((node) &#123; 1, 1, 0, tt &#125;); while (!q.empty()) &#123; node x = q.front(); q.pop(); if (x.x == n &amp;&amp; x.y == m) return x.step; for (int i = 0; i &lt;= 3; i++) &#123; int xx = x.x + dx[i]; int yy = x.y + dy[i]; if (1 &lt;= xx &amp;&amp; xx &lt;= n &amp;&amp; 1 &lt;= yy &amp;&amp; yy &lt;= m) &#123;//是否合法 if (mp[x.x][x.y][xx][yy] == -1) continue;//墙，不能 int t; if ((t = mp[x.x][x.y][xx][yy]) != 0)//门 if ((x.key&amp;(1 &lt;&lt; (t - 1))) == 0) continue;//没有钥匙 int tt = x.key; for (int j = 1; j &lt;= num[xx][yy]; j++) tt = tt | (1 &lt;&lt; (key[xx][yy][j] - 1));//带上钥匙 if (v[xx][yy][tt]) continue;//同样的地点带着同样的钥匙，我们就认为状态重复了 v[xx][yy][tt] = 1; q.push((node) &#123; xx, yy, x.step + 1, tt &#125;); &#125; &#125; &#125; return -1;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; k; for (int i = 1; i &lt;= k; i++) &#123; int x1, x2, y1, y2, g; scanf("%d%d%d%d%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;g); if (g == 0)mp[x1][y1][x2][y2] = mp[x2][y2][x1][y1] = -1; else mp[x1][y1][x2][y2] = mp[x2][y2][x1][y1] = g; &#125; int s; scanf("%d", &amp;s); for (int i = 1; i &lt;= s; i++) &#123; int x, y, p; scanf("%d%d%d", &amp;x, &amp;y, &amp;p); key[x][y][++num[x][y]] = p; &#125; printf("%d\n", bfs()); return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>广搜</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVA11362]Phone List]]></title>
    <url>%2F2018%2F08%2F22%2F%5BUVA11362%5DPhone%20List%2F</url>
    <content type="text"><![CDATA[题目PDF 题解虽然我很想说这是一道字典树模板题，但是还是有点技巧的。对于每组输入，我们先把它存入字典树，然后再来查找（也就是所谓的离线）为了说明方便，用表格说明一下变量吧 变量名 变量作用 $st$ 保存读入的字符串，用于离线 $word$ 保存字典树每条边被覆盖的次数，遍历时为1说明不是前缀 $ch$ 字典树，第一维是编号，第二维是哪条边，值为指向的点 $sz$ 用来编号，类似于链式前向星里的$tot$ 关键是遍历的时候，只要word为1就返回0（就是它自己啊），能顺利的走下来就返回1 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int MAX = 1e5 + 10;int t,n;char st[10100][10];int word[MAX],ch[MAX][10],sz;void reset()&#123;//每组数据需要重置 sz = 1; memset(ch[0],0,sizeof(ch[0])); memset(word,0,sizeof(word));&#125;void insert(char *s)&#123;//插入进字典树 int nl = strlen(s),u = 0; for(int i = 0 ; i &lt; nl ;i++)&#123; int c = s[i] - '0'; if(! ch[u][c])&#123; memset(ch[sz],0,sizeof(ch[sz])); ch[u][c] = sz++; &#125; u = ch[u][c]; word[u]++; &#125;&#125;int find(char *s)&#123;//是否是前缀 int nl = strlen(s),u = 0; for(int i = 0; i &lt; nl; i++)&#123; int c = s[i] - '0'; u = ch[u][c]; if(word[u] == 1) return 0; &#125; return 1;&#125;int main()&#123; cin&gt;&gt;t; while(t--)&#123; reset(); scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n; i++)&#123; scanf("%s",st[i]); insert(st[i]); &#125; int ok = 1; for(int i = 1 ; i &lt;= n; i++) if(find(st[i]))&#123; ok = 0; break; &#125; if(ok) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>字典树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P4071][SDOI2016]排列计数]]></title>
    <url>%2F2018%2F08%2F22%2F%5B%E6%B4%9B%E8%B0%B7P4071%5D%5BSDOI2016%5D%E6%8E%92%E5%88%97%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目题目描述求有多少种长度为 n 的序列 A，满足以下条件：1 ~ n 这 n 个数在序列中各出现了一次若第 i 个数 A[i] 的值为 i，则称 i 是稳定的。序列恰好有 m 个数是稳定的满足条件的序列可能很多，序列数对 10^9+7 取模。 输入格式第一行一个数 T，表示有 T 组数据。接下来 T 行，每行两个整数 n、m。T=500000，n≤1000000，m≤1000000 输出格式输出 T 行，每行一个数，表示求出的序列数 输入样例12345651 01 15 2100 5010000 5000 输出样例12345012057802888760695423 题解没思路？我们来找规律！比如一个$n=5$的排列，我们假设$m=2$也就是说，我们其实已经确定了排列种某些位置的值，就这个例子来说： $12???$ $1?3??$ $1??4?$ $1???5$ $?23??$ $?2?4?$ $?2??5$ $??34?$ $??3?5$ $???45$ 共10种，很容易发现其实就是$C_n^m$，那么其中的问号又多少种排列呢？ 没思路？我们再来找规律！我们设$D_i$为i个?的可能的排列数，显然，$D_1=0$ $D_2=1$接着我们来看下$D_3$，可以有$312$,$231$如果我们继续找下去的话，容易出错，所以我们现在来找找规律（灵魂画师）。就拿$D_4$来说，上面的是数，下面的是位置，首先，1不能放到1号位，而且放到2，3，4上对于递推是等价的，于是他别无选择地放到了其他地方（假设是2号位）然后我们假设2放到1号位上去，剩下的3，4正好是$D_2$但2怎么可能只有放在1号位上的命运呢？它还可以不放到1号位，咦？我们之前说，i不能放到i号位，那么既然2不放到1号位，那么1号位在这里是不是等价于2号位呢？没错！而之前的“万恶之源”数字1，它有$n-1$种放法，所以我们就大胆猜测：$D_n=(n-1)(D_{n-1}+D_{n-2})$严谨的证明还请大家自己百度然后我们就愉快地输出$C_n^m\times D_{n-m}$就好啦其他知识点比如说逆元求组合数（费马小定理）还请大家自行了解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;const int MAXN=1000005,mod=1000000007;ll f[MAXN],inv[MAXN],d[MAXN];int t;ll qpow(ll a,ll b)&#123; ll ans=1; while(b)&#123; if(b&amp;1)ans=a*ans%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return ans;&#125;void prework()&#123; f[0]=1; for(int i=1;i&lt;MAXN;i++)&#123; f[i]=f[i-1]*i%mod; inv[i]=qpow(f[i],mod-2); &#125; d[1]=0,d[2]=1,d[3]=2; for(int i=4;i&lt;MAXN;i++)&#123; d[i]=(i-1)*(d[i-1]+d[i-2])%mod; &#125;&#125;int main()&#123; cin&gt;&gt;t; prework(); for(int i=1;i&lt;=t;i++)&#123; ll n,m; scanf("%lld%lld",&amp;n,&amp;m); if (n - m == 1) printf("0\n"); else if (m == n) printf("1\n"); else if (m == 0) printf("%lld\n",d[n]); else &#123; printf("%lld\n",f[n] * inv[m] % mod * inv[n-m] % mod * d[n-m] % mod); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数论</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>组合数</tag>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2009]最优贸易]]></title>
    <url>%2F2018%2F08%2F22%2F%5BNOIP2009%5D%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93%2F</url>
    <content type="text"><![CDATA[题目题目描述C 国有n 个大城市和m 条道路，每条道路连接这n 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这m 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为1 条。C 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。商人阿龙来到 C 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设C 国n 个城市的标号从1~ n，阿龙决定从1 号城市出发，并最终在n 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有n 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品——水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来C 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。假设 C 国有5 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。假设 1~n 号城市的水晶球价格分别为4，3，5，6，1。阿龙可以选择如下一条线路：1-&gt;2-&gt;3-&gt;5，并在2 号城市以3 的价格买入水晶球，在3号城市以5 的价格卖出水晶球，赚取的旅费数为2。阿龙也可以选择如下一条线路 1-&gt;4-&gt;5-&gt;4-&gt;5，并在第1 次到达5 号城市时以1 的价格买入水晶球，在第2 次到达4 号城市时以6 的价格卖出水晶球，赚取的旅费数为5。 现在给出 n 个城市的水晶球价格，m 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。 输入格式第一行包含 2 个正整数n 和m，中间用一个空格隔开，分别表示城市的数目和道路的数目。第二行 n 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这n 个城市的商品价格。接下来 m 行，每行有3 个正整数，x，y，z，每两个整数之间用一个空格隔开。如果z=1，表示这条道路是城市x 到城市y 之间的单向道路；如果z=2，表示这条道路为城市x 和城市y 之间的双向道路。 输出格式包含1 个整数，表示最多能赚取的旅费。如果没有进行贸易，则输出0。 输入样例12345675 54 3 5 6 11 2 11 4 12 3 23 5 14 5 2 输出样例15 数据范围输入数据保证 1 号城市可以到达n 号城市。对于 10%的数据，1≤n≤6。对于 30%的数据，1≤n≤100。对于 50%的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。对于 100%的数据，1≤n≤100000，1≤m≤500000，1≤x，y≤n，1≤z≤2，1≤各城市水晶球价格≤100。 题解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;using namespace std;const int MAXN = 500010;int n, m;int flag = 0;int Head[MAXN / 5], Nt[MAXN * 2], to[MAXN * 2], tot;int price[MAXN / 5], f[MAXN / 5], mi[MAXN / 5];void add(int a, int b) &#123; Nt[++tot] = Head[a]; to[tot] = b; Head[a] = tot;&#125;void dfs(int x, int minn, int pre) &#123; int flag = 1; minn = min(minn, price[x]); if (mi[x]&gt;minn)mi[x] = minn, flag = 0; int maxx = max(f[pre], price[x] - mi[x]); if (f[x]&lt;maxx)f[x] = maxx, flag = 0; if (flag)return; for (int i = Head[x]; i; i = Nt[i]) &#123; int y = to[i]; dfs(y, minn, x); &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; memset(mi, 0x7f, sizeof(mi)); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;price[i]); &#125; for (int i = 1; i &lt;= m; i++) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); add(a, b); if (c == 2)add(b, a); &#125; dfs(1, 1 &lt;&lt; 30, 0); printf("%d", f[n]); return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>深搜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1040]加分二叉树]]></title>
    <url>%2F2018%2F08%2F16%2F%5B%E6%B4%9B%E8%B0%B7P1040%5D%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目题目描述设一个n个节点的二叉树tree的中序遍历为（l,2,3,…,n），其中数字1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第j个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下： subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数。若某个子树为空 ，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空 子树。 试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。要求输出； （1）tree的最高加分 （2）tree的前序遍历 输入格式第1行：一个整数n（n＜30），为节点个数。 第2行：n个用空格隔开的整数，为每个节点的分数（分数＜100）。 输出格式第1行：一个整数，为最高加分（结果不会超过4,000,000,000）。 第2行：n个用空格隔开的整数，为该树的前序遍历。 输入样例1255 7 1 2 10 输出样例121453 1 2 4 5 题解一道入门的区间dp，当然，根据写法不同你还可以把它归类为树形dp或者记忆化搜索，其实都无所谓啦。作为一道入门题，我们完全可以“显然”地做出来，但是在这里还是想和大家回顾下动态规划以及区间动规。 Q：dp特点是什么？A：dp把原问题视作若干个重叠的子问题的逐层递进，每个子问题的求解过程都会构成一个“阶段”，在完成一个阶段后，才会执行下一个阶段。Q：dp要满足无后效性，什么叫无后效性？A：已经求解的子问题不受后续阶段的影响。 有人觉得dp很抽象，那是因为没有一步一步来想，直接听别人的结论，我们在这里以这道题为例，一步一步来推导。 首先，我们要做的就是设计状态，其实就是设计dp数组的含义，它要满足无后效性。关注这个 左子树*右子树+根 我只要知道左子树分数和右子树分数和根的分数（已给出），不就可以了吗？管他子树长什么样！所以，我们$f$数组存的就是最大分数，怎么存呢？我们发现：子树是一个或多个节点的集合。那么我们可不可以开一个$f[i][j]$来表示节点i到节点j成树的最大加分呢？可以先保留这个想法（毕竟暂时也想不到更好的了）。 如果这样话，我们就来设计状态转移方程。按照刚刚的设计来说的话，我们的答案就是$f[1][n]$了，那么我们可以从小的子树开始，也就是len，区间长度。有了区间长度我们就要枚举区间起点，i为区间起点，然后就可以算出区间终点j。通过加分二叉树的式子我们可以知道，二叉树的分取决于谁是根，于是我们就在区间内枚举根k。特别的，$f[i][i]=a[i]$其中a[i]为第i个节点的分数。因为是要求最大值，所以我们就可以设计出$$f[i][j]=MAX(f[i][k-1]*f[k+1][j]+f[k][k])$$于是乎，我们就自己设计出了一个dp过程，因为是顺着来的，所以很少有不成立的。 至于输出前序遍历，我们再设计一个状态$root[i][j]$来表示节点i到节点j成树的最大加分所选的根节点。所以我们按照$根-&gt;左-&gt;右$的顺序递归输出即可。 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int MAXN = 50;typedef long long ll;ll n;ll f[MAXN][MAXN], root[MAXN][MAXN];void print(ll l, ll r) &#123; if (l &gt; r)return; printf("%lld ", root[l][r]); if (l == r)return; print(l, root[l][r] - 1); print(root[l][r]+1,r);&#125;int main() &#123; scanf("%lld", &amp;n); for (int i = 1; i &lt;= n; i++)scanf("%lld", &amp;f[i][i]),f[i][i-1]=1, root[i][i] = i; for (int len = 1; len &lt; n; ++len) &#123; for (int i = 1; i + len &lt;= n; ++i) &#123; int j = i + len; f[i][j] = f[i + 1][j] + f[i][i];//默认它的左子树为空，如果有的话，这肯定不是最优解 root[i][j] = i;//默认从起点选根 for (int k = i + 1; k &lt; j; ++k) &#123; if (f[i][j] &lt; f[i][k - 1] * f[k + 1][j] + f[k][k]) &#123; f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k]; root[i][j] = k; &#125; &#125; &#125; &#125; cout &lt;&lt; f[1][n] &lt;&lt; endl; print(1, n); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>区间dp</category>
      </categories>
      <tags>
        <tag>中序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1771] 方程的解]]></title>
    <url>%2F2018%2F08%2F15%2F%5B%E6%B4%9B%E8%B0%B7P1771%5D%20%E6%96%B9%E7%A8%8B%E7%9A%84%E8%A7%A3_NOI%E5%AF%BC%E5%88%8A2010%E6%8F%90%E9%AB%98%2F</url>
    <content type="text"><![CDATA[题目题目描述佳佳碰到了一个难题，请你来帮忙解决。 对于不定方程a1+a2+…+ak-1+ak=g(x)，其中k≥2且k∈N，x是正整数，g(x)=x^x mod 1000(即x^x除以1000的余数)，x，k是给定的数。我们要求的是这个不定方程的正整数解组数。 举例来说，当k=3，x=2时，分别为(a1,a2,a3)=(2,1,1)’(1,2,1)，(1,1,2)。 输入格式输入文件equation.in有且只有一行，为用空格隔开的两个正整数，依次为k，x。 输出格式输出文件equation.out有且只有一行，为方程的正整数解组数。 输入样例13 2 输出样例13 说明对于40%的数据，ans≤10^16；对于100%的数据，k≤100，x≤2^31-1，k≤g(x)。 题解首先呢，$g(x)$我们是可以求解的，我们设$n=g(x)$我们可以先写出$n$个1，我们发现它们之间有$n-1$个空隙，而我们的任务是寻找k个数，使k个数的和等于$n$，于是我们就可以将问题转化成在$n-1$个空隙中选出$k-1$个空隙放挡板，形成的$k$个数的和正好就是$n$。换句话说，我们要求$C_{n-1}^{k-1}$对于样例的画图辅助理解 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;const int MAXN = 100, mod = 1000, inf = 1000000;ll k, x, n;ll sum[MAXN], cnt = 1;ll qpow(ll a, ll b) &#123; ll ans = 1; while (b) &#123; if (b &amp; 1)ans = ans * a%mod; a = a * a%mod; b &gt;&gt;= 1; &#125; return ans;&#125;void c(ll n, ll m) &#123; sum[1] = 1, cnt = 1; for (int i = m; i &gt;= m - n + 1; i--) &#123;//对组合数公式进行了化简 for (int j = 1; j&lt;MAXN; j++) &#123; sum[j] *= i; &#125; for (int j = 1; j&lt;MAXN; j++) &#123; if (sum[j] &gt;= inf) &#123; sum[j + 1] += sum[j] / inf; sum[j] %= inf; &#125; &#125; &#125; for (int i = 2; i &lt;= n; i++) &#123; for (int j = MAXN-1; j &gt;= 1; j--) &#123; if (sum[j] == 0) continue; if (sum[j] &gt;= i) &#123; sum[j - 1] += sum[j] % i*inf; sum[j] /= i; &#125; else sum[j - 1] += sum[j] * inf, sum[j] = 0; &#125; &#125;&#125;int main() &#123; ll k, x; cin &gt;&gt; k &gt;&gt; x; n = qpow(x, x); if (k - 1 &lt;= 0 || n - 1 &lt;= 0) &#123; printf("0"); return 0; &#125; c(k - 1, n - 1);//总共有n-1个间隙，要插k-1个隔板； int id; for (int i = MAXN - 1; i &gt;= 1; i--) &#123; if (sum[i]) &#123; id = i; break; &#125; &#125; printf("%lld", sum[id]); for (int i = id-1; i &gt;= 1; i--) &#123; printf("%06lld", sum[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>组合数</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVA10140]Prime Distance]]></title>
    <url>%2F2018%2F08%2F15%2F%5BUVA10140%5DPrime%20Distance%2F</url>
    <content type="text"><![CDATA[题目题目描述The branch of mathematics called number theory is about properties of numbers. One of the areas that has captured the interest of number theoreticians for thousands of years is the question of primality. A prime number is a number that is has no proper factors (it is only evenly divisible by 1 and itself). The first prime numbers are 2,3,5,7 but they quickly become less frequent. One of the interesting questions is how dense they are in various ranges. Adjacent primes are two numbers that are both primes, but there are no other prime numbers between the adjacent primes. For example, 2,3 are the only adjacent primes that are also adjacent numbers.Your program is given 2 numbers: L and U (1&lt;=L&lt; U&lt;=2,147,483,647), and you are to find the two adjacent primes C1 and C2 (L&lt;=C1&lt; C2&lt;=U) that are closest (i.e. C2-C1 is the minimum). If there are other pairs that are the same distance apart, use the first pair. You are also to find the two adjacent primes D1 and D2 (L&lt;=D1&lt; D2&lt;=U) where D1 and D2 are as distant from each other as possible (again choosing the first pair if there is a tie).Input 给定两个整数 L,R，求闭区间 [L,R]中相邻两个质数差值最小的数对与差值最大的数对。当存在多个时，输出靠前的素数对。 输入格式Each line of input will contain two positive integers, L and U, with L &lt; U. The difference between L and U will not exceed 1,000,000. 输出格式For each L and U, the output will either be the statement that there are no adjacent primes (because there are less than two primes between the two given numbers) or a line giving the two pairs of adjacent primes. 输入样例122 1714 17 输出样例122,3 are closest, 7,11 are most distant.There are no adjacent primes. 题解部分内容来自李煜东所著《算法进阶指南》 暴力是不可能的，R的范围太大了。但是我们发现，R-L的范围很小，有什么办法可以求出R-L之间的质数呢？显然： 定理：如果n是一个合数， 那么n一定有一个不超过$\sqrt{n}$的素数因子推论：任意一个合数n必定包含一个不超过$\sqrt{n}$的质因子 用质因数分解定理可以简单证明。所以，我们只要用筛法求出$2$~$\sqrt{R}$之间所有的质数，对于每个质数p，把$[L,R]$中能被p整除的数标记，即标记$i*p\left(\Big\lceil\dfrac{L}{P}\Big\rceil\le\Big\lceil\dfrac{R}{P}\Big\rceil\right)$为合数。最终所有还没有被标记的数就是$\left[L,R\right]$中的质数。对相邻质数两两比较，找出差最大的即可。时间复杂度为$O\left(\sum_{质数p\le\sqrt{R}}\frac{R-L}{p}\right)=O\left(\sqrt{R}loglog\sqrt{R}+(R-L)loglogR\right)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int MAXN = 46345;typedef long long ll;int p[MAXN],cnt,l,r,m;bool v[1000001];int b[1000001];void prime() &#123; memset(v, 1, sizeof(v)); for (int i = 2; i &lt;= MAXN; i++) if (v[i])&#123; p[++cnt] = i; for (int j = 2; j &lt;= 46340 / i; j++) v[i*j] = false; &#125;&#125;int main() &#123; prime(); while (cin &gt;&gt; l &gt;&gt; r) &#123; memset(v, 1, sizeof(v)); if (l == 1) v[0] = false; for (ll i = 1; i &lt;= cnt; i++) for (ll j = l / p[i]; j &lt;= r / p[i]; j++) &#123; if (p[i] * j - l &lt; 0)continue;//这里不加，poj过不了 if (j &gt; 1) v[p[i] * j - l] = false; &#125; m = 0; for (ll i = l; i &lt;= r; i++)&#123;//这里一定要开ll的i，要不然溢出了就会死循环 if (v[i - l]) b[++m] = i; &#125; ll t1 = 2147483647; ll t2 = 0; ll x1, x2, y1, y2; for (ll i = 1; i&lt;m; i++)&#123; ll cha = b[i + 1] - b[i]; if (cha&lt;t1) &#123; t1 = cha; x1 = b[i]; y1 = b[i + 1]; &#125; if (cha&gt;t2) &#123; t2 = cha; x2 = b[i]; y2 = b[i + 1]; &#125; &#125; if (!t2) cout &lt;&lt; "There are no adjacent primes.\n"; else cout &lt;&lt; x1 &lt;&lt; ',' &lt;&lt; y1 &lt;&lt; " are closest, " &lt;&lt; x2 &lt;&lt; ',' &lt;&lt; y2 &lt;&lt; " are most distant.\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1445][Violet]樱花]]></title>
    <url>%2F2018%2F08%2F13%2F%5B%E6%B4%9B%E8%B0%B7P1445%5D%5BViolet%5D%E6%A8%B1%E8%8A%B1%2F</url>
    <content type="text"><![CDATA[题目题目描述求方程$$ \frac{1}{X}+\frac{1}{Y}=\frac{1}{N!} $$的正整数解的组数，其中N≤10^6。解的组数，应模1e9+7。 输入格式输入一个整数N 输出格式输出答案 题解 部分内容参考自这篇文章 $$ \frac{1}{x}+\frac{1}{y}=\frac{1}{n!} $$ 先通分 $$ \frac{(x+y)}{xy}=\frac{1}{n!} $$ 再化整数 $$ xy-(x+y)*n!=0 $$ 然后配平 $$ (n!)^2-(x+y)*n!+xy=(n!)^2 $$ 最后 $$ (x-n!)*(y-n!)=(n!)^2 $$ 然后我们发现$x，y$都要是正整数； 所以原题可以变为 $$ A*B=(n!)^2 $$ 当$A*B$为正整数的时候$x,y$显然也是正整数；$x,y$可以是任意正整数，即$A,B$可以为任意正整数，我们就可以对$x$单独进行讨论我们考虑$x$的取值，显然，若一个质数$p$有$k$个，那么$x$可以取$p^0,p^1….p^k$ 共$(k+1)$种情况乘法原理乘起来就可以了,而且显然，x确定后，y必然也会被确定那么我们先可以筛出质数（这里是埃氏筛法）；求出每个数的最小质因数然后暴力就好了； 代码12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=1000005;const int mod=1e9+7;int n;long long v[MAXN],phi[MAXN],p[MAXN],cnt;int c[MAXN];int main()&#123; cin&gt;&gt;n; for(int i=2;i&lt;=n;i++)&#123; if(v[i])continue; p[++cnt]=i; for(int j=1;j*i&lt;=n;j++)v[i*j]=1; &#125; long long k=0,ans=1; for(int i=1;i&lt;=cnt;i++)&#123; int pri=p[i],c1=0; for(int j=n;j;j/=pri)&#123; c1+=j/pri; &#125; c[++k]=c1; &#125; for(int i=1;i&lt;=cnt;i++)ans=ans*(c[i]*2+1)%mod; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[洛谷UVA540]Team Queue]]></title>
    <url>%2F2018%2F08%2F05%2F%5B%E6%B4%9B%E8%B0%B7UVA540%5DTeam%20Queue%2F</url>
    <content type="text"><![CDATA[题目题目描述Queues and Priority Queues are data structures which are known to most computer scientists. TheTeam Queue, however, is not so well known, though it occurs often in everyday life. At lunch time thequeue in front of the Mensa is a team queue, for example.In a team queue each element belongs to a team. If an element enters the queue, it first searchesthe queue from head to tail to check if some of its teammates (elements of the same team) are alreadyin the queue. If yes, it enters the queue right behind them. If not, it enters the queue at the tailand becomes the new last element (bad luck). Dequeuing is done like in normal queues: elements areprocessed from head to tail in the order they appear in the team queue.Your task is to write a program that simulates such a team queue. 输入格式The input file will contain one or more test cases. Each test case begins with the number of teamst (1 ≤ t ≤ 1000). Then t team descriptions follow, each one consisting of the number of elementsbelonging to the team and the elements themselves. Elements are integers in the range 0..999999. Ateam may consist of up to 1000 elements.Finally, a list of commands follows. There are three different kinds of commands:• ENQUEUE x — enter element x into the team queue• DEQUEUE — process the first element and remove it from the queue• STOP — end of test caseThe input will be terminated by a value of 0 for t.Warning: A test case may contain up to 200000 (two hundred thousand) commands, so the implementationof the team queue should be efficient: both enqueing and dequeuing of an element shouldonly take constant time. 输出格式For each test case, first print a line saying ‘Scenario #k’, where k is the number of the test case. Then,for each ‘DEQUEUE’ command, print the element which is dequeued on a single line. Print a blank lineafter each test case, even after the last one. 样例输入123456789101112131415161718192021222324252627282930313233343523 101 102 1033 201 202 203ENQUEUE 101ENQUEUE 201ENQUEUE 102ENQUEUE 202ENQUEUE 103ENQUEUE 203DEQUEUEDEQUEUEDEQUEUEDEQUEUEDEQUEUEDEQUEUESTOP25 259001 259002 259003 259004 2590056 260001 260002 260003 260004 260005 260006ENQUEUE 259001ENQUEUE 260001ENQUEUE 259002ENQUEUE 259003ENQUEUE 259004ENQUEUE 259005DEQUEUEDEQUEUEENQUEUE 260002ENQUEUE 260003DEQUEUEDEQUEUEDEQUEUEDEQUEUESTOP0 样例输出1234567891011121314Scenario #1101102103201202203Scenario #2259001259002259003259004259005260001 题解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;int team[1000002],cnt;string s;int t;int main()&#123; while(scanf("%d",&amp;t)!=EOF)&#123; cnt++; queue&lt;int&gt;tque[1001]; queue&lt;int&gt;mque; int flag=0; for(int i=1;i&lt;=t;i++)&#123; int num; scanf("%d",&amp;num); for(int j=1;j&lt;=num;j++)&#123; int tmp; scanf("%d",&amp;tmp); team[tmp]=i; &#125; &#125; while(cin&gt;&gt;s)&#123; if(s=="STOP")&#123; printf("\n"); break; &#125; if(s=="ENQUEUE")&#123; int num; scanf("%d",&amp;num); if(tque[team[num]].empty())&#123; mque.push(team[num]); tque[team[num]].push(num); &#125; else tque[team[num]].push(num); &#125; if(s=="DEQUEUE")&#123; if(flag==0)&#123; printf("Scenario #%d\n",cnt); flag=1; &#125; while(tque[mque.front()].empty())&#123; mque.pop(); &#125; printf("%d\n",tque[mque.front()].front()); tque[mque.front()].pop(); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>基础数据结构</category>
        <category>队列</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[洛谷UVA1330]City Game]]></title>
    <url>%2F2018%2F08%2F05%2F%5B%E6%B4%9B%E8%B0%B7UVA1330%5DCity%20Game%2F</url>
    <content type="text"><![CDATA[题目题目描述Bob爱上了一个策略游戏（Simcity？）游戏中一个城市由k个地区组成，每个地区都是一块长N×宽M大小的网格矩形,其中可能有些网格已被占用，用R表示;有些则是空地，用F表示。 游戏中可以在空着的空间上建一个矩形的建筑，同时每个建筑按它所占的空地网格数来收租，每占用一个网格可收租金3美元。Bob想知道每个地区中最大面积建筑物能收多少租金。 输入格式第一行是地区个数k。然后接下给出k个地区的相关信息。 相关信息用以下方式输入： 第一行有两个整数n,m (n,m&lt;= 1000),表示这个地区长n宽m 然后接下来有n行，每行m个字符表示网格的信息，相邻的两个用空格隔开。R表示该网格被占用；F表示该网格是空地，可使用。 输出格式对于每一个地区，输出一行一个整数表示该地区中最大面积建筑物能收到的租金。 注意POJ dicuss中有人反映数据输出可能不严格按照要求（例如：两个字符间有多个空格），建议使用cin等读入。 感谢@Rye_Catcher 提供的翻译 英文题面输入样例12345678910111213141516171833 3R R FF F FF R F5 6R F F F F FF R F F F FF F R F F FF F F R F FF F F F R R4 5R R R R RR R F R RR R R R RR R F R R 输出样例1239273 题解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int n,m,ans;int city[1001][1001];int solve(int r)&#123; int s[1002],len[1002],p=0,ans=0; city[n+1][r]=0; for(int i=1;i&lt;=n+1;i++)&#123; if(city[i][r]&gt;s[p])s[++p]=city[i][r],len[p]=1; else &#123; int lenth=0; while(s[p]&gt;city[i][r])&#123; lenth+=len[p]; ans=max(ans,lenth*s[p]); p--; &#125; if(city[i][r])s[++p]=city[i][r],len[p]=lenth+1; &#125; &#125; return ans;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; ans=0; memset(city,0,sizeof(city)); scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; int last=0; for(int j=1;j&lt;=m;j++)&#123; char op; cin&gt;&gt;op; if(op=='R')&#123; for(int k=last+1;k&lt;j;k++)city[i][k]=j-k; last=j; &#125; else if(j==m)&#123; for(int k=last+1;k&lt;=j;k++)city[i][k]=j-k+1; &#125; &#125; &#125; for(int i=1;i&lt;=m;i++)&#123; ans=max(ans,solve(i)); &#125; cout&lt;&lt;ans*3&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>基础数据结构</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1312]Mayan游戏]]></title>
    <url>%2F2018%2F08%2F04%2F%5B%E6%B4%9B%E8%B0%B7P1312%5DMayan%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题目题目描述Mayan puzzle是最近流行起来的一个游戏。游戏界面是一个 7 行 ×5 列的棋盘，上面堆放着一些方块，方块不能悬空堆放，即方块必须放在最下面一行，或者放在其他方块之上。游戏通关是指在规定的步数内消除所有的方块，消除方块的规则如下： 1 、每步移动可以且仅可以沿横向（即向左或向右）拖动某一方块一格：当拖动这一方块时，如果拖动后到达的位置（以下称目标位置）也有方块，那么这两个方块将交换位置（参见输入输出样例说明中的图 6 到图 7 ）；如果目标位置上没有方块，那么被拖动的方块将从原来的竖列中抽出，并从目标位置上掉落（直到不悬空，参见下面图1 和图2）；2 、任一时刻，如果在一横行或者竖列上有连续三个或者三个以上相同颜色的方块，则它们将立即被消除（参见图1 到图3）。注意： a) 如果同时有多组方块满足消除条件，几组方块会同时被消除（例如下面图 4 ，三个颜色为 1 的方块和三个颜色为 2 的方块会同时被消除，最后剩下一个颜色为 2 的方块）。 b) 当出现行和列都满足消除条件且行列共享某个方块时，行和列上满足消除条件的所有方块会被同时消除（例如下面图5 所示的情形，5 个方块会同时被消除）。 3 、方块消除之后，消除位置之上的方块将掉落，掉落后可能会引起新的方块消除。注意：掉落的过程中将不会有方块的消除。 上面图1 到图 3 给出了在棋盘上移动一块方块之后棋盘的变化。棋盘的左下角方块的坐标为（0, 0 ），将位于（3, 3 ）的方块向左移动之后，游戏界面从图 1 变成图 2 所示的状态，此时在一竖列上有连续三块颜色为4 的方块，满足消除条件，消除连续3 块颜色为4 的方块后，上方的颜色为3 的方块掉落，形成图 3 所示的局面。 输入格式共 6 行。 第一行为一个正整数 n，表示要求游戏通关的步数。 接下来的 5行，描述7×5 的游戏界面。每行若干个整数，每两个整数之间用一个空格隔开，每行以一个 0 结束，自下向上表示每竖列方块的颜色编号（颜色不多于 10 种，从 1 开始顺序编号，相同数字表示相同颜色）。 输入数据保证初始棋盘中没有可以消除的方块。 输出格式如果有解决方案，输出 n 行，每行包含 3 个整数 x,y,g，表示一次移动，每两个整数之间用一个空格隔开，其中 (x ,y)表示要移动的方块的坐标， g 表示移动的方向， 1 表示向右移动， −1 表示向左移动。注意：多组解时，按照 x 为第一关健字， y 为第二关健字， 1 优先于 −1 ，给出一组字典序最小的解。游戏界面左下角的坐标为 (0 ,0) 。 如果没有解决方案，输出一行，包含一个整数 -1 。 样例输入12345631 02 1 02 3 4 03 1 02 4 3 4 0 样例输出1232 1 13 1 13 0 1 说明【输入输出样例说明】 按箭头方向的顺序分别为图 6 到图 11样例输入的游戏局面如上面第一个图片所示，依次移动的三步是：(2,1) 处的方格向右移动，(3,1) 处的方格向右移动,(3,0)处的方格向右移动，最后可以将棋盘上所有方块消除。 【数据范围】 对于 30% 的数据，初始棋盘上的方块都在棋盘的最下面一行； 对于 100% 的数据，0&lt;n≤5。 noip2011提高组day1第3题 题解代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;stack&gt;#define scanf scanf_susing namespace std;int a[5][7],tag[5][7],cnt[10];int n;struct Node&#123; int x,y,z;&#125;;stack&lt;Node&gt;ans;bool emp(void)&#123; for(int i=0;i&lt;5;++i) for(int j=0;j&lt;7;++j) if(a[i][j])return 0; return 1;&#125;void drop(int x,int y)&#123; int p=y-1; while(p&gt;=0&amp;&amp;!a[x][p])--p; swap(a[x][y],a[x][p+1]);&#125;bool check()&#123;//消去 memset(tag,0,sizeof(tag));//先把要消的标记起来，不能直接删除 bool flag=0;//有没有消去 for(int i=0;i&lt;5;i++)&#123; for(int j=0;j&lt;7;j++)&#123; if(!a[i][j])continue; if(i+2&lt;5&amp;&amp;a[i][j]==a[i+1][j]&amp;&amp;a[i+1][j]==a[i+2][j])//横着消 tag[i][j]=tag[i+1][j]=tag[i+2][j]=1; if(j+2&lt;7&amp;&amp;a[i][j]==a[i][j+1]&amp;&amp;a[i][j+1]==a[i][j+2])//竖着消 tag[i][j]=tag[i][j+1]=tag[i][j+2]=1; &#125; &#125; for(int i=0;i&lt;5;++i)//消除 for(int j=0;j&lt;7;++j) if(tag[i][j])&#123; flag=1; a[i][j]=0; &#125; for(int i=0;i&lt;5;++i)//下落 for(int j=1;j&lt;7;++j) if(a[i][j]&amp;&amp;(!a[i][j-1])) drop(i,j); return flag;&#125;void move(int x,int y,int z)&#123;//移动 int nx=x+z,ny=y; swap(a[x][y],a[nx][ny]); drop(nx,ny); while(++y&lt;7&amp;&amp;a[x][y])drop(x,y); while(check());&#125;bool dfs(int p)&#123; int tmp[5][7]; bool ok=emp(); if(ok&amp;&amp;p==n+1)return 1; else if(ok||p==n+1)return 0; memcpy(tmp,a,sizeof(a)); for(int i=0;i&lt;5;i++)&#123; for(int j=0;j&lt;7;j++)&#123; if(a[i][j])&#123; if(i!=4&amp;&amp;a[i][j]!=a[i+1][j])&#123;//不在最右边并且和右边的颜色不同 move(i,j,1); if(dfs(p+1))&#123; Node o=&#123;i,j,1&#125;; ans.push(o); return 1; &#125; memcpy(a,tmp,sizeof(a));//回溯 &#125; if(i!=0&amp;&amp;a[i][j]!=a[i-1][j]&amp;&amp;a[i-1][j]==0)&#123; move(i,j,-1); if(dfs(p+1))&#123; Node o=&#123;i,j,-1&#125;; ans.push(o); return 1; &#125; memcpy(a,tmp,sizeof(a)); &#125; &#125; &#125; &#125; return 0;&#125;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;5;i++)&#123; int b=1; int cnt=0; while(b!=0)&#123; scanf("%d",&amp;b); a[i][cnt++]=b; &#125; &#125; check(); dfs(1); Node t; int cnt=0; if(ans.empty())cout&lt;&lt;"-1"; while(!ans.empty())&#123; t=ans.top(); ans.pop(); printf("%d %d %d\n",t.x,t.y,t.z); &#125; return 0;&#125;]]></content>
      <categories>
        <category>搜索</category>
        <category>深度优先搜索</category>
      </categories>
      <tags>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ4195][Noi2015]程序自动分析]]></title>
    <url>%2F2018%2F08%2F04%2F%5BBZOJ4195%5D%5BNoi2015%5D%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[题目题目描述在实现程序自动分析的过程中,常常需要判定一些约束条件是否能被同时满足。 考虑一个约束满足问题的简化版本：假设x1,x2,x3,…代表程序中出现的变量，给定n个形如xi=xj或xi≠xj的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：x1=x2，x2=x3，x3=x4，x1≠x4，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。现在给出一些约束满足问题，请分别对它们进行判定。 输入格式输入文件的第1行包含1个正整数t，表示需要判定的问题个数。注意这些问题之间是相互独立的。 对于每个问题，包含若干行：第1行包含1个正整数n，表示该问题中需要被满足的约束条件个数。接下来n行，每行包括3个整数i,j,e，描述1个相等/不等的约束条件，相邻整数之间用单个空格隔开。若e=1，则该约束条件为xi=xj；若e=0，则该约束条件为xi≠xj。 输出格式输出文件包括t行。 输出文件的第k行输出一个字符串“YES”或者“NO”（不包含引号，字母全部大写），“YES”表示输入中的第k个问题判定为可以被满足，“NO”表示不可被满足。 样例输入1234567221 2 11 2 021 2 12 1 1 样例输出12NOYES 说明在第一个问题中，约束条件为：x1=x2,x1≠x2。这两个约束条件互相矛盾，因此不可被同时满足。在第二个问题中，约束条件为：x1=x2,x2=x1。这两个约束条件是等价的，可以被同时满足。1≤n≤10000001≤i,j≤1000000000 题解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int t,n;const int MAXN =10000005;struct node&#123; int x,y,e;&#125;a[MAXN];int b[MAXN],c[MAXN*2],f[MAXN];int cnt=0;int tot=0;int fla;int ask(int x)&#123; return lower_bound(b+1,b+tot,x)-b;&#125;void lisan()&#123; sort(c+1,c+cnt); for(int i=1;i&lt;=cnt;i++)&#123; if(i==1||c[i]!=c[i-1])b[++tot]=c[i]; &#125;&#125;int find(int x)&#123; if(f[x]==x) return x; return f[x]=find(f[x]);&#125;bool cmp(node a,node b)&#123; return a.e&gt;b.e;&#125;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; fla=0; tot=0,cnt=0; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d%d",&amp;a[i].x,&amp;a[i].y,&amp;a[i].e); c[++cnt]=a[i].x,c[++cnt]=a[i].y; &#125; lisan(); sort(a+1,a+n+1,cmp); for(int i=1;i&lt;=tot;i++)f[i]=i; for(int i=1;i&lt;=n;i++)&#123; a[i].x=ask(a[i].x); a[i].y=ask(a[i].y); if(a[i].e)&#123; f[find(a[i].x)]=find(a[i].y); &#125; else&#123; if(find(a[i].x)==find(a[i].y))&#123; fla=1;break; &#125; &#125; &#125; if(fla) printf("NO\n"); else printf("YES\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>离散化</tag>
        <tag>并查集</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[poj2559]Largest Rectangle in a Histogram]]></title>
    <url>%2F2018%2F08%2F04%2F%5Bpoj2559%5DLargest%20Rectangle%20in%20a%20Histogram%2F</url>
    <content type="text"><![CDATA[题目题目描述A histogram is a polygon composed of a sequence of rectangles aligned at a common base line. The rectangles have equal widths but may have different heights. For example, the figure on the left shows the histogram that consists of rectangles with the heights 2, 1, 4, 5, 1, 3, 3, measured in units where 1 is the width of the rectangles:Usually, histograms are used to represent discrete distributions, e.g., the frequencies of characters in texts. Note that the order of the rectangles, i.e., their heights, is important. Calculate the area of the largest rectangle in a histogram that is aligned at the common base line, too. The figure on the right shows the largest aligned rectangle for the depicted histogram. 输入格式The input contains several test cases. Each test case describes a histogram and starts with an integer n, denoting the number of rectangles it is composed of. You may assume that 1 &lt;= n &lt;= 100000. Then follow n integers h1, …, hn, where 0 &lt;= hi &lt;= 1000000000. These numbers denote the heights of the rectangles of the histogram in left-to-right order. The width of each rectangle is 1. A zero follows the input for the last test case. 输出格式For each test case output on a single line the area of the largest rectangle in the specified histogram. Remember that this rectangle must be aligned at the common base line. 输入样例1237 2 1 4 5 1 3 34 1000 1000 1000 10000 输出样例1284000 题解 部分内容来自李煜东所著《算法竞赛进阶指南》 如果说这道题矩形的高度是递增的，估计就是一道普及难度的题了吧。我们可以尝试以每个矩形的高度作为最终矩形的高度，并将宽度扩展到右边界，答案取最大值。 简单归简单，不过这也给了我们一个启发，如果是递增的我们就放着不管，以后来处理。如果说下一个高度更小，那么用它所构成的矩形的高度不可能超过它自己，而后面的矩形想要和前面的矩形拼接的话，高度也不能超过它。这样子的话，我们就可以用上面的方法更新比当前矩形高的矩形的答案再将它们合并。 这就是单调栈算法，时间复杂度 $ O(N) $借助单调性处理问题的思想在于及时排除不可能的选项，保持策略集合的高度有效性和秩序性 就这拿道题举例，我们建立一个栈，用来保存若干个矩形，这些矩形的高度是单调递增的，或者说，我们期望他是单调递增的。我们从左到右读入矩形：如果当前矩形比栈顶矩形高，即满足单调递增，进栈。否则不断去除栈顶，直至栈空或栈顶高度低于当前矩形。在此过程中，我们累计被弹出的矩形的宽度和（用于计算答案与合并），用高度×累计宽度更新答案。而后，将一个宽度为累计宽度，高度为当前矩形的矩形入栈。结束，将剩余矩形弹出，和上面一样更新答案； 代码12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt; #include&lt;algorithm&gt;using namespace std;int n,p;int a[100010];int s[100010],w[100010];long long ans;int main()&#123; while(cin&gt;&gt;n&amp;&amp;n) &#123; ans=0; p=0; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); a[n+1]=0; for(int i=1;i&lt;=n+1;i++) &#123; if(a[i]&gt;s[p]) s[++p]=a[i],w[p]=1; else&#123; int width=0; while(s[p]&gt;a[i]) &#123; width+=w[p]; ans=max(ans,(long long)width*s[p]); p--; &#125; s[++p]=a[i],w[p]=width+1; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>基本数据结构</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ISLAND一周目通关感想]]></title>
    <url>%2F2018%2F07%2F26%2FISLAND%E4%B8%80%E5%91%A8%E7%9B%AE%E9%80%9A%E5%85%B3%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[可能包含严重剧透本来有很多游戏内部短片可以通过B站外链嵌入这里的，但奈何全被封了10.1更新：现在已经解禁，而且游戏已上架streamStream上的ISLAND 序言这里要先感谢夜鸮的树洞汉化组带来的汉化，真的是很棒了，ISLAND最近也会上架steam，到时候会补票。本来是在同学的推荐下看了一集ISLAND，一开始我是抵触的，后面发现凛音的人设不错，声优是田村大魔王，于是就打算试试游戏。然后就被震撼到了，不亏是岛学，那种给人带来的沉浸感，是其他galgame难以做到了。 接下来会从流程，人物等方面展开讨论ISLAND 虽说在暑假，但是时间比较少（网上大佬二周目用了80个小时），所以夏莲和纱罗线基本是跳着过的，所以流程的话就会少掉夏莲和纱罗线。 序言就写这么多，要不然就要变成后记了233 流程序章有这样一个传说，传说的主人公叫切那，他爱着一个女性，女性的名字叫凛音，凛音也不为人知的爱着切那，但是他们二人有着永远无法结合的命运，因为他们是兄妹，有一个叫夏莲的女孩子对这二人的关系感到不高兴，因为夏莲也爱上了切那，于是她请求魔女无论怎样也要分离二人，于是魔女向二人下了诅咒，魔女把凛音的脸变成谁也不会爱上的怪物的模样，承受如此痛苦的凛音，自己结束了生命，被留下孤身一人的切那，切那也被放逐了，切那与魔女进行了契约，魔女约定，凛音会在这个世界再次重生，然后，二人结合之时诅咒将会解除。但是需要几十年，甚至几百年，并没有和魔女约定好。切那为了停止自己的时间而在冰中沉眠，为了等待着那一天的到来。浦岛上的人信奉这一个传说，并时不时的用传说中的人名给自己的孩子命名，浦岛上的御三家，御原家，珈蓝堂家，枢都家，就是贯彻这一传统的家庭，时至1999年8月，一名男子被冲上浦岛的沙滩，男子被警察发现后，因为枢都镇长的要求，准备将其遣返本土，这是男子在船上邂逅了镇长的女儿枢都夏莲，在逃跑时在海滩上遇见了御原凛音，而凛音收留了他，并给他取了三千界切那这个名字，这场旅行正式拉开了序幕。 然而没那么简单orz 夏篇 注：Flowchart中，白色描边灰点代表一节（可能有分支也可能没有），黑色点代表BE，蓝色点代表下一章，灰色无描边点代表No retrun,橙色点代表除了BE的其他结局 夏篇才是ISLAND里面最像一个galgame的地方，你有三条路（虽然凛音线是被锁住的），三个女主对你似乎都有好感。它同时也是ISLAND埋伏笔的地方。游戏一开始就将你引入到男主是从未来来的误区，也让玩家以为切那就是凛音5年前遇到的切那。（结果都不是）在夏篇中就已经提到切那是为了拯救人而“回到过去”，做法是“杀死切那”。而要拯救的那个人就是凛音（吗？）但是这样是说不通的，有一个cg是切那脑中闪过的模糊的凛音穿婚纱的样子，对象肯定是切那（切那视角） 总之，打完夏篇，你要在意的是：1.凛音没有患煤纹病。2.凛音说她也是时空旅行者。3.BE未来预想图只是切那的脑补。4.夏莲和纱罗线和主线有着关系，要认真打（虽然我是跳着打的orz）。5.凛音的房间很整洁。6.浦岛太郎和玉手箱。 夏莲篇不过多介绍，但是这里出现了一个之后对主线有着重要作用的人——桃香。 纱罗篇需要在意地方：1.玖音的房间很乱。2.纱罗的母亲万里爱。3.少儿不宜的全年龄向内容（下面是玖音说的） 凛音篇这篇前面在发糖，后面就很难受，概括来讲就是： 岛上盛行一种疾病——煤纹病。凛音表面是很害怕自己也得煤纹病，所以一直闭门不出，但真实原因是因为害怕自己和传说中的凛音一样，所以凛音也将setsuna当成了真正的切那，二人相爱了。但是在纱罗的推理下，认为这个世界存在平行世界，他们认为setsuna为了拯救凛音重复了无数次，推理的结果是凛音认为眼前的setsuna杀掉了五年前的切那，于是自己到达了暴龙岛，想要杀掉5年前的凛音。但是这是不可能的，其实并没有平行宇宙这种事情，setsuna也追随到了暴龙岛，最后二人和解，二人坐着一条船回来的时候，切那因为脱力沉入海中，而凛音为了救他丧命。而后，setsuna登上了冷冻睡眠装置，打算到了造出时间机器的年代，乘坐时间机器拯救凛音。 是不是很晕呐233， 重回标题，标题变为never island 冬篇冬篇才是这个游戏最最最最最最最最最最最最最最最最最最最最1while(1)printf("最"); 厉害的地方，本在是为了凛音而来，却喜欢上了Rinne（这里指的是我） 下面为了输入方便，会把片假名直接打成英文字母，如リンネ=Rinne 概括来讲就是：20000年后，切那再次醒来发现自己身处雪原，有一个年幼的女孩救了昏迷的自己，模糊的样子让人容易想起谁。女孩的名字叫Rinne（Rinne，这里用的是片假名，夏篇的那个凛音用的是平假名），他们生活在一个叫IslandEurasia的避难所，生活的很艰难，Rinne很不会整理东西，不但自己房间很乱，还把之前哥哥的房间当成杂货间，setsuna在这里找到了工作，拿到了Rinne哥哥的名环，作为setsunaOhara在这个避难所生活。 但是因为有很多孩子没有名环，所以有暗势力组织暴动，KarenKruz就是他们的老大。setsuna作为反叛军和教会的纽带，也想让教会理解没有名环的孩子的痛苦，但因为这样，想要让大家和平生活的SarahGarland被当做魔女烧死了， KarenKruz也因为被太阳照射而病发煤纹病，去医院的时候带上了Rinne的名环最后只剩下setsuna和Rinne两个人在山洞中过活，可好景不长，食物越来越少，两人渐渐撑不下去了，有一天setsuna到island外的雪地里发现了冷冻睡眠装置，那是自己乘坐的那一个。 “重要的东西原来近在咫尺啊”setsuna意识到自己真正要拯救的人是眼前的Rinne，他很坚定的告诉Rinne自己一定要回到他们相遇的时候，杀死自己，来拯救Rinne，Rinne最后只能妥协，setsuna把自己的名环当做戒指交给了Rinne，但是Rinne却把时间设定在了1999年——切那的时代。 真夏篇真夏篇揭露了煤纹病其实是伴X显性遗传病，分急性和非急性。setsuna再次在浦岛醒来，他明白了自己究竟该拯救谁，就像开挂一样的快速培养自己与身边的人的关系，完成了在夏篇中没能够做到的很多事。 关于凛音END他对玖音表达了自己想让凛音幸福，玖音幸福地答应了,想要让setsuna给凛音幸福setsuna和凛音的关系发展得很顺利，大家都在为他们祝福，就在这样一个环境下，setsuna与凛音步入了婚姻的殿堂 关于re：END他对玖音表达了自己想让Rinne幸福，但是，自己却将玖音惹火了，玖音质问他，当自己生下凛音的时候他在哪里，自己和凛音这么多年来是怎么熬过来的，setsuna完全不知道，就这样，玖音跑走了。setsuna在小镇上遇到了纱罗的母亲万里爱，她把setsuna来岛上的一切都告诉了他: 在浦岛上有御三家，御原家，枢都家，伽蓝堂家。在御原家有一个没有名字，不知道出身的女孩子，大家都叫她「小空」，同时御原家也有一个小婴儿——凛音，凛音实际上是小空的亲生女儿，但是却寄养在御原家中，御原家的女主人御原玖音对凛音和小空太过亲近，而感到非常不高兴，不久就开始了对她们的虐待，随后在1988年的夏天，凛音在海边的断崖上坠落，三天后漂流到了附近的海滨，而在一个月后，御原玖音的遗体在本土的港口被发现了，后来小空被迫只得冒充御原玖音生活。而凛音被发现时，有一个男孩子在海滩上救了她，男孩是御原切那，御原家的长子，之后凛音就和切那成了好友，切那自己一个人住在海滨的小屋里，和凛音一起抓虫子，辅导数学题目，直到1993年，凛音想要给切那过生日的时候，脚滑坠海，切那去救了她，并带凛音到了海边的小屋中，二人发生了关系，但在天亮时被父亲御原典正发现了，切那遭受了典正的一顿暴打，被扔进了海里，而后凛音被阳光下身患煤纹病的御原典正吓到了，听到了切那的呼救，跑去救切那，二人失去平衡坠入海中，一起漂流到了暴龙岛，在岛上切那为她寻找到了逃生的船，其实就是冷冻睡眠装置，于是凛音在其中被冷冻了5年，直到1998年6月才漂回浦岛，而报纸对外界宣称遭受神隐的少女回归了，2个月之后，setsuna便到了这座岛上。 似乎明白了什么的他进入玖音的房间，打算好好谈谈。门没锁，玖音就这样躺在地上睡着了， “这是追逐梦想的人的房间”setsuna知道，玖音实际上就是Rinne，setsuna坐上去的不是时空机器，而是，冷冻睡眠装置，Rinne知道了这一点，也坐上了根据蓝图开发的冷冻装置。他和Rinne所在的那个避难所，实际上是20000年前的时间，他做出了决定，打算和她一起完成他们二人的梦想，切那决定再次坐上冷冻装置，他要再次前往neverisland拯救真正应该拯救的少女。 真冬篇（序章）FW欠我一个真冬篇！！ “Rin、ne——”嘴里自然地发出了声音,那刻在记忆深处的话语,到现在还没能拯救的，最后的少女的名字 “Rin、ne！！！！”————就在那时。沙沙地踏雪的声音。“……谁？……”抬起头。映入眼帘的是，担心地看着我的那张脸。那张脸令人十分怀念。让人不禁落泪一般地惹人怜爱，“为什么……”啊，你是……“为什么你知道我的名字？”你,是——…… 人物上面的内容是不是看得云里雾里？那就对了！要想真正体验ISLAND还是要自己去玩一下啊。 御原 凛音 （おはら りんね）看上去是女主，然而确实女主的女儿2333当初就是为了凛音的人设才开始游戏的，结果冬篇最后喜欢上了Rinne。凛音一直喜欢说「因为――我也是个时间旅行者啊」,一开始以为只是为了附和setsuna，结果从某种意义上来说还真的是。这个孩子也受够了苦，从小受虐待，喜欢的人死了，记忆也是缺失的。setsuna出现后，与他玩上了过家家的游戏，setsuna不是那个御原切那，这一点凛音比谁都清楚。一开始分不清Rinne和凛音，冬篇后才发现这完全是两个人，从房间和性格各个方面都可以感受得到。 伽蓝堂 纱罗 （がらんどう さら）原以为是全作的智商担当，结果是胡乱瞎猜素质巫女。动不动就要杀了setsuna凛音篇的时候更是助攻送了凛音一程难受QAQ 不过冬篇里的Sarah还是很不错的。 枢都 夏莲 （くるつけ かれん）可以从夏莲身上看到自己的影子，努力地想要出岛，与父亲作对，因该是本作中最正常的女生了吧（虽然在冬篇里是靠那啥吃饭的） 三千界 刹那 （さんぜんかい せつな）我至今都没弄懂setsuna到底是哪里来的……13岁到37岁通吃，正好是冬篇Rinne的岁数和真夏篇玖音的岁数。单曲大小（&lt;=8cm） RinneOhara （リンネオハラ）/ 御原 玖音什么都不说，先唱岛歌 ランランララン～♪アイランジャ～♪戦え爱を守るため～♪今だ！合体だ！セツナ！リンネ！ 本作的灵魂，充满活力的少女特别喜欢Rinne说过的一句话：“一直呆在一起的话，就会慢慢喜欢上的吧” QAQ 我现在后悔死了 这里留白就好，要不然会写到明天。 BGM一开始觉得不是很好听，有一首还挺像《桑坦路奇亚》。直到打完后，重新听OST，才发现这是天籁😭最顶上的网易云音乐外链就是整个OST推荐第2、20、35、38首 乱七八糟想说的要说我打通的galgame，ISLAND是第一部，打完的那一天，停在标题画面久久无法释怀。完全被作者牵着鼻子走了，夏篇的时候只想着凛音却把很多伏笔漏了。凛音篇的时候总以为自己就是那个切那，能让凛音幸福，结果还是假面。冬篇的时候总想着回去救凛音，甚至对和Rinne在一起的日常感到厌烦，结果到了最后才发现自己想拯救的是Rinne而不是凛音😭一直都是这样，整个游戏下来我一直都很难受。这个游戏玩下来不但烧脑，虐心，伤眼睛，还疯狂打脸，但即便如此，我仍然觉得这是个好游戏，欠我真冬篇啦！烂人杰！哦 对，这里有一篇超厉害的伏笔回收还有这个标签什么鬼啊，性和犯罪，难道只要擦到了边算吗？还是说本来可以不加，官方为了销量故意加的？]]></content>
  </entry>
  <entry>
    <title><![CDATA[宜春中学团委招新啦！！]]></title>
    <url>%2F2018%2F07%2F26%2F%E5%9B%A2%E5%A7%94%E6%8B%9B%E6%96%B0%2F</url>
    <content type="text"><![CDATA[在宜中学子中，有这样一群人他们是众多校园活动的策划者，他们协助宜春中学各个社团管理社团事务，他们能带着小牌子穿梭于各项活动，他们常年以学生身份出现于行政楼、科技楼之中他们是谁！ ——宜春中学团委学生干部可爱的新高一学弟学妹们：加入朝气蓬勃的宜春中学团委吧！在这里，你能培养、锻炼管理能力、组织能力、应变能力；在这里，你能得到展现自我，提升自我的机会；在这里，你能感受到组织浓浓的凝聚力；在这里，你能参与组织诗歌朗诵大赛，大型校园义卖，主持人大赛等等精彩的活动；在这里，你能第一时间了解各大活动的第一消息，观看各种精彩活动；在这里，有不定时聚餐，下乡活动等诸多福利在这里，还有高颜值高智商高情商的学长学姐做你们的师父手把手带你成长带你飞！ 你还在等什么？加入我们，就是最好的选择！ 让我们一起飞上天，与太阳肩并肩！让我们策马扬鞭，青春年华一起成长！ 报名安排：8月21、22日下午教学楼旁边摆摊8月23日晚自习初试（具体时间地点另行通知）8月24日晚自习复试（具体时间地点另行通知） 另附： 关注我们 Q&amp;A你可以通过QQ，微信，微博，评论等方式向我们提出问题，这里将集中公示大家的疑问，方便查询。 Q：团委是社团还是什么？A：中国共产主义青年团委员会的简称是团委，是中国共青团的组织之一，是广大青年在实践中学习中国特色社会主义和共产主义的学校，是中国共产党的助手和后备军。 总而言之不是社团是一个组织。]]></content>
  </entry>
  <entry>
    <title><![CDATA[2018NOI导刊被虐记]]></title>
    <url>%2F2018%2F07%2F18%2F2018NOI%E5%AF%BC%E5%88%8A%E8%A2%AB%E8%99%90%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[序言结束以来已经过了很久了，终于有时间填坑，写这篇博客的目的就是想要保存这份回忆，无论今后怎么也好，当下才是最重要的。 过程Day0好像我是比较晚和大家在火车站集合的，为了一个舒适的路程，特意买的是高铁票（为此还放弃了直达票）路程大概是宜春-&gt;杭州-&gt;常州-&gt;嘉兴-&gt;宜春正好宜春这边有暴雨，赶紧逃！高铁上还是比较舒适的，有电有网有吃，十几个人把电脑打开，俨然一个高档网吧（误） 然而只有到杭州的那段路是这样的，后面就十分无聊了（杭州的火车站是真的大） 在杭州站捐了50元给一个关爱听障组织，一个同学还笑我，受不了。不过也确实如他所说，万一是骗子怎么办？要是我没有看过《声之形》的话我还会不会给他捐钱呢？说实话我也不清楚。 杭州-&gt;常州的那段遇到了一位日本女士，带着一对小孩（兄妹），为什么这两个小孩会这么乖啊！上车的时候被堵在车厢走廊，别的小孩都在闹，但那对兄妹也没有吵（也许是身在国外？这对小孩只会日语，但母亲会中文） 到了之后已经很晚了，于是老师带我们去吃饭，好甜，我指的是菜。。。 这7天住酒店，两个人一间房，但是因为我们这边男生个数是奇数，所以我就和另一个参加培训的常州本地学生一间房，嘛，感觉还是可以的，他也一直在玩手机，对话完了之后两个人都在做自己的事。也幸亏我和他住一间房，才知道培训的地方临时换了，通知了我们学校的人。（常州高级中学-&gt;常州外国语学校，据说前者被举报暑假补课）总之远了多，每天坐大巴一个小时好难受。 Day1早上到了常州外国语学校（私立）就觉得这学校不一般，特别气派就连机房里都装了Ubuntu（NOILinux） 正式开始上课！！上午曹文老师讲课，年纪比较大，讲了些基本算法（枚举，模拟，递推和递归），第一次发现原来基本算法也不简单。中午在学校食堂吃饭，不得不说15元一餐就是不一样，三荤一素有水果有汤，菜多的吃不完。下午的老师是堵君懿，NOI金牌（之后给我们授课的老师基本都是这种“怪物”），完全跟不上节奏，大概也是讲了些基本算法，还有点数学内容。 在和旁边同学闲聊的时候了解到他们基本是从初中开始学的，还有很多从小学开始学的，如果就按学习oi的时间来讲，我们可能他们所有人的学弟学妹吧。 还有就是在提高组的学生里面有挺多学习态度不端正的（尤其是我旁边的），交了这么多钱，结果就是下课打游戏，上课讲话，摸鱼，睡觉的态度。 晚自习后回酒店，第一次用浴缸洗澡，有点不习惯，洗完衣服就睡了，第一天实在是太累了。 Day2第二天一整天都是蔡昊源老师讲课，讲着讲着看我们觉得太难了就开始讲语文，如果觉得这两个都很难的怎么办😂。 一整天讲的都是动态规划，主要是优化，什么前缀和，矩阵乘法，四边形不等式，斜率优化，单调队列，凸包（有些是day7才讲的） 主要是晚上的考试，差点爆零，结果有两道是codeforces上的……其实我觉得这7天3次考试题目基本和讲的内容没关系。 最后一次用浴缸洗，之后就没有这么享受了。 Day3第三天讲课老师的名字忘了，总之也很厉害，一天的搜索，特别精彩。 上午是深搜和广搜，然后拓展了一下迭代加深深搜和双向广搜，然后讲了下剪枝。 下午的随机化搜索令人影响深刻，由爬山推广到模拟退火，玄的不能再玄的算法，在某些时候还真的很管用。 晚上给我们重新讲了些前些天的内容，各种数学知识orz，在这些人面前自己真的就是⑨。 Day4第四天和第五天由毕克——毕大爷（codeforces红名）给我们讲课，说实话还是挺喜欢的，就是身上很臭。这一天就是讲数据结构。 上午讲了堆，并查集，字符串hash（这东西贼神奇）。讲字符串hash的时候讲了好久关于hack的内容，明明我们NOI和NOIP用不到，但是听着很有趣。 下午讲树状数组，差分，线段树。 晚上考试很难过，有一个要求组合数的题目，结果要用一个我听都没听过的方法——逆元，还要用到费马小定理，我太弱了orz Day5上午对昨天的考试做了讲评，讲了逆元，以及 $ 方差=平方的平均数-平均数的平方 $ 然后就是乱七八糟的听不懂的东西，什么积性函数，欧拉函数，莫比乌斯函数。 下午讲了概率与期望，又是一些乱七八糟颠覆尝试的东西。比如说：如果一个房间里有23个或23个以上的人，那么至少有两个人的生日相同的概率要大于50%。 Day6后面两天都是李煜东讲课，（毕克说BZOJ网址lydsy是李煜东刷牙的意思233） 他是《算法竞赛进阶指南》的作者，可以看得出他写这本书特别用心，而且也确实很优秀，推荐！他的个人网站 这一天讲的是图论，树的直径，树的中心，图的直径，树网的核……总之还有一大堆神奇算法。 晚上考试第二题太暴力了!拉出去续一秒！ Day7这一天详细地讲了下动态规划的各种方法，讲了下昨天考试的题目。下午发了点奖品，我这种蒟蒻当然是没有的，不过我有些同学还是拿到了的李煜东的亲笔签名书晚上没有晚自习，老师带我们去川菜馆吃，然而也不是很辣。因为那个本地人今晚回家，为了省钱我就和另外两个同学一起住，打了一下cs1.6（真的是打了“一下”） 后记感觉这次培训收获到最多的东西就是很多新名词（雾）一开始还是挺兴奋的，但后面还是在三点一线的日常。从每个Day的长度就能看出来。很感谢一路走来有同学们和老师的陪伴，如果没有他们，这场培训我估计会撑不住。这次培训之后感觉自己还是有很多不懂，无论是没学过的，还是已经学过的，听这些大佬讲课，总有新的收获，但是这7天课程安排太紧，想要消化是不可能的，所以回来过后还是要多练。 NOIP2018加油！]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[2018NOI导刊]B君的病症]]></title>
    <url>%2F2018%2F07%2F17%2F%5B2018NOI%E5%AF%BC%E5%88%8A%5DB%E5%90%9B%E7%9A%84%E7%97%85%E7%97%87%2F</url>
    <content type="text"><![CDATA[题目题目描述享国之日浅，国家无事。B 君看到了 Z 君的第二题，觉得很难。 于是自己出了一个简单题。 大 A 是一名强迫症患者，现在他要给一群带颜色的珠子排成一列，现在有 n 种颜色，其中第 i 种颜色的珠子有 ai 个。要求排列中第 i 种颜色珠子的所有珠子，一定要排在第 i + 1 种颜色的第一个和最后一个珠子之间。问有多少种排列珠子的方案，因为方案数会很大，所以请输出答案对1000000007 取模之后的结果。 输入格式第一行一个整数 n。 以下 n 行，每行一个整数 ai。 输出格式一行一个整数表示答案。 输入样例12343244 输出样例1168 说明对于 100% 的数据，满足 1 ≤ n ≤ 10^4 , 2 ≤ ai ≤ 15。 对于 70% 的数据，满足 1 ≤ n ≤ 10^2。 题解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;#define MOD 1000000007#define MAXN 100001long long fact[MAXN],inv[MAXN];long long pow(long long a,long long b)&#123; long long ans=1; while(b)&#123; if(b&amp;1)ans=a*ans%MOD; a=a*a%MOD; b&gt;&gt;=1; &#125; return ans%MOD;&#125;long long c(long long m,long long n)&#123; return fact[m]*inv[n]%MOD*inv[m-n]%MOD;&#125;void pre()&#123; fact[0]=1; inv[0]=1; for(int i=1;i&lt;MAXN;i++)&#123; fact[i]=fact[i-1]*i%MOD; inv[i]=pow(fact[i],MOD-2); &#125;&#125;int main()&#123; long long x,y; pre(); cin&gt;&gt;x; long long z=1; int s=0; for(int i=1;i&lt;=x;i++)&#123; scanf("%lld",&amp;y); z=z*c(s+y-2,y-2)%MOD; s+=y; &#125; cout&lt;&lt;z; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>逆元</tag>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[poj1845]Sumdiv]]></title>
    <url>%2F2018%2F07%2F09%2F%5Bpoj1845%5DSumdiv%2F</url>
    <content type="text"><![CDATA[题目题目描述Consider two natural numbers A and B. Let S be the sum of all natural divisors of A^B. Determine S modulo 9901 (the rest of the division of S by 9901). 输入The only line contains the two natural numbers A and B, (0 &lt;= A,B &lt;= 50000000)separated by blanks. 输出The only line of the output will contain S modulo 9901. 样例输入12 3 样例输出115 提示$ 2^3 = 8. $The natural divisors of 8 are: 1,2,4,8. Their sum is 15.15 modulo 9901 is 15 (that should be output). 来源Romania OI 2002 传送门Sumdiv 题解问题分析刚一看到这个题，一股浓浓的数论感就扑面而来，求$ A^B $的约数和，暴力当然是不可取的，我们不妨换个角度如果我们把$ A $分解质因数，表示为 $$ A=p_1^(c_1)p_2^(c_2)p_3^(c_3)…p_n^(c_n) $$ 那么$ A^B $可表示为$$ A=p_1^(Bc_1)p_2^(Bc_2)p_3^(Bc_3)…p_n^(Bc_n) $$则$ A^B $所有约数和为$$ (1+p_1+p_1^2+…+p_1^(Bc_1)) $$ 质因数分解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;#define MAXN 50001const int MOD=9901;long long a,b;long long p[MAXN],c[MAXN];long long m;long long ans; long long pow(long long p,long long n)&#123; long long sq=1; while(n)&#123; if(n&amp;1)sq=(sq*p)%MOD; n&gt;&gt;=1; p=(p*p)%MOD; &#125; return sq;&#125; bool prime(int n)&#123; if(n&lt;2)return 0; for(int i=2;i&lt;=sqrt(n);i++)&#123; if(n%i==0)return 0; &#125; return 1;&#125; void divide(int n)&#123; m=0; for(int i=2;i&lt;=sqrt(n);i++)&#123; if(n%i==0&amp;&amp;prime(i))&#123; p[++m]=i,c[m]=0; while(n%i==0)n/=i,c[m]++; &#125; &#125; if(n&gt;1&amp;&amp;prime(n))p[++m]=n,c[m]=1; return;&#125; long long sum(long long p,long long c)&#123; if(c==0)return 1; if(c%2==0)return (sum(p,c/2-1)*(1+pow(p,c/2+1))+pow(p,c/2))%MOD; else return (sum(p,c/2)*(1+pow(p,c/2+1)))%MOD;&#125; void work()&#123; ans=1; for(int i=1;i&lt;=m;i++)&#123; ans=(ans*sum(p[i],c[i]*b)%MOD)%MOD; &#125;&#125; int main()&#123; cin&gt;&gt;a&gt;&gt;b; divide(a); work(); printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[poj3263]Tallest Cow]]></title>
    <url>%2F2018%2F07%2F09%2F%5Bpoj3263%5DTallest%20Cow%2F</url>
    <content type="text"><![CDATA[题目题目描述FJ’s N (1 ≤ N ≤ 10,000) cows conveniently indexed 1..N are standing in a line. Each cow has a positive integer height (which is a bit of secret). You are told only the height H (1 ≤ H ≤ 1,000,000) of the tallest cow along with the index I of that cow. FJ has made a list of R (0 ≤ R ≤ 10,000) lines of the form “cow 17 sees cow 34”. This means that cow 34 is at least as tall as cow 17, and that every cow between 17 and 34 has a height that is strictly smaller than that of cow 17. For each cow from 1..N, determine its maximum possible height, such that all of the information given is still correct. It is guaranteed that it is possible to satisfy all the constraints. 输入Line 1: Four space-separated integers: N, I, H and RLines 2..R+1: Two distinct space-separated integers A and B (1 ≤ A, B ≤ N), indicating that cow A can see cow B. 输出Lines 1..N: Line i contains the maximum possible height of cow i. 输入样例1234569 3 5 51 35 34 33 79 8 输出样例123456789545344555 来源USACO 2007 January Silver 传送门Tallest Cow 题解代码12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;map&gt;using namespace std;int d[100001];unsigned int s[100001];int n,i,h,r;int x,y;map&lt;pair&lt;int,int&gt;,bool&gt; judge; int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;i,&amp;h,&amp;r); d[1]=h; for(int i=1;i&lt;=r;i++)&#123; scanf("%d%d",&amp;x,&amp;y); if(x&gt;y)swap(x,y); if(judge[make_pair(x,y)])continue; d[x+1]--,d[y]++; judge[make_pair(x,y)]=1; &#125; for(int i=1;i&lt;=n;i++)&#123; s[i]=s[i-1]+d[i]; &#125; for(int i=1;i&lt;=n;i++)&#123; printf("%d\n",s[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2003]激光炸弹]]></title>
    <url>%2F2018%2F07%2F09%2F%5BHNOI2003%5D%E6%BF%80%E5%85%89%E7%82%B8%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[题目题目描述一种新型的激光炸弹，可以摧毁一个边长为R的正方形内的所有的目标。现在地图上有n(N&lt;=10000)个目标，用整数Xi,Yi(其值在[0,5000])表示目标在地图上的位置，每个目标都有一个价值。激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆破范围，即那个边长为R的正方形的边必须和x，y轴平行。若目标位于爆破正方形的边上，该目标将不会被摧毁。 输入输入文件的第一行为正整数n和正整数R，接下来的n行每行有3个正整数，分别表示xi,yi,vi 输出输出文件仅有一个正整数，表示一颗炸弹最多能炸掉地图上总价值为多少的目标（结果不会超过32767）。 输入样例1232 10 0 11 1 1 输出样例11 题解代码12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n,R;int a[5002][5002];int ans; int main()&#123; cin&gt;&gt;n&gt;&gt;R; for(int i=1;i&lt;=n;i++)&#123; int x,y,num; scanf("%d%d%d",&amp;x,&amp;y,&amp;num); a[y+1][x+1]=num; &#125; for(int i=1;i&lt;=5001;i++)&#123; for(int j=1;j&lt;=5001;j++)&#123; a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1]; &#125; &#125; for(int i=R;i&lt;=5001;i++)&#123; for(int j=R;j&lt;=5001;j++)&#123; int tmp=a[i][j]-a[i-R][j]-a[i][j-R]+a[i-R][j-R]; if(ans&lt;tmp)ans=tmp; &#125; &#125; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1880][NOI1995]石子合并]]></title>
    <url>%2F2018%2F07%2F05%2F%5B%E6%B4%9B%E8%B0%B7P1880%5D%5BNOI1995%5D%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[题目题目描述在一个圆形操场的四周摆放N堆石子,现要将石子有次序地合并成一堆.规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。 试设计出1个算法,计算出将N堆石子合并成1堆的最小得分和最大得分. 输入格式数据的第1行试正整数N,1≤N≤100,表示有N堆石子.第2行有N个数,分别表示每堆石子的个数. 输出格式输出共2行,第1行为最小得分,第2行为最大得分. 样例输入1244 5 9 4 样例输出124354 题解代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#define MAXN 402using namespace std;int fmin[MAXN][MAXN];int sum[MAXN];int fmax[MAXN][MAXN];int n;int main()&#123; memset(fmin,0x3f,sizeof(fmin)); memset(fmax,0,sizeof(fmax)); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; int a; scanf("%d",&amp;a); fmin[i][i]=0; fmin[i+n][i+n]=0; sum[i]=sum[i-1]+a; &#125; for(int i=1;i&lt;=n;i++)&#123; sum[i+n]=sum[n]+sum[i]; &#125; for(int len=2;len&lt;=n;len++)&#123; for(int i=1;i&lt;=n+n-len+1;i++)&#123; int j=i+len-1; for(int k=i;k&lt;j;k++)&#123; fmax[i][j]=max(fmax[i][j],fmax[i][k]+fmax[k+1][j]+sum[j]-sum[i-1]); fmin[i][j]=min(fmin[i][j],fmin[i][k]+fmin[k+1][j]+sum[j]-sum[i-1]); &#125; &#125; &#125; int minn=1&lt;&lt;30; int maxx=0; for(int i=1;i&lt;=n;i++)&#123; minn=min(minn,fmin[i][i+n-1]); maxx=max(maxx,fmax[i][i+n-1]); &#125; printf("%d\n%d",minn,maxx); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>环状dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1049]装箱问题]]></title>
    <url>%2F2018%2F07%2F04%2F%5B%E6%B4%9B%E8%B0%B7P1049%5D%E8%A3%85%E7%AE%B1%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目题目描述有一个箱子容量为 V （正整数，$ 0 &lt;= V &lt;=20000 $），同时有 n 个物品（ $ 0&lt;n&lt;=30 $ ，每个物品有一个体积（正整数）。 要求 nn 个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。注：此问题区分大小写 输入格式1 个整数，表示箱子容量 1 个整数，表示有 n 个物品 接下来 n 行，分别表示这 n 个物品的各自体积 输出格式1个整数，表示箱子剩余空间。 样例输入123456782468312797 样例输出10 来源NOIp2001普及组 第4题 题解代码1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n,v;int w[31];int f[20001];int main()&#123; scanf("%d%d",&amp;v,&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;w[i]); &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=v;j&gt;=w[i];j--)&#123; f[j]=max(f[j],f[j-w[i]]+w[i]); &#125; &#125; printf("%d",v-f[v]); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>背包</category>
      </categories>
      <tags>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1435]回文字串]]></title>
    <url>%2F2018%2F07%2F04%2F%5B%E6%B4%9B%E8%B0%B7P1435%5D%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目题目描述回文词是一种对称的字符串。任意给定一个字符串，通过插入若干字符，都可以变成回文词。此题的任务是，求出将给定字符串变成回文词所需要插入的最少字符数。 比如 “Ab3bd”插入2个字符后可以变成回文词“dAb3bAd”或“Adb3bdA”，但是插入少于2个的字符无法变成回文词。 注：此问题区分大小写 输入格式一个字符串(0&lt;strlen&lt;=1000) 输出格式有且只有一个整数，即最少插入字符数 样例输入1Ab3bd 样例输出12 来源IOI2000第一题 题解这里有个易错点，关于strlen函数的。 strlen()函数其实就是个计数器，它会从字符串开头，到终止符结束，最后返回结果。 但是，有些时候我们为了方便，会在读入字符串的时候使用scanf(“%s”,a+1)这时候，strlen(a)的返回值一定是0，因为a字符串的开头就是终止符，正确做法strlen(a+1) 代码123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;char str[5001];int n;int f[5001][5001];int main()&#123; cin&gt;&gt;str+1; n=strlen(str+1); for(int len=1;len&lt;=n;len++)&#123; for(int i=1;i&lt;=n-len+1;i++)&#123; int j=i+len-1; if(str[i]==str[j])f[i][j]=f[i+1][j-1]; else f[i][j]=min(f[i+1][j],f[i][j-1])+1; &#125; &#125; printf("%d",f[1][n]); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>区间dp</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[hdu1114]猪猪储蓄罐]]></title>
    <url>%2F2018%2F07%2F03%2F%5BYZOJ1582%5D%E7%8C%AA%E7%8C%AA%E5%82%A8%E8%93%84%E7%BD%90%2F</url>
    <content type="text"><![CDATA[我写的是单输入版本，改一下应该不会超时 题目题目描述Before ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig. After a sufficiently long time, there should be enough cash in the piggy-bank to pay everything that needs to be paid. But there is a big problem with piggy-banks. It is not possible to determine how much money is inside. So we might break the pig into pieces only to find out that there is not enough money. Clearly, we want to avoid this unpleasant situation. The only possibility is to weigh the piggy-bank and try to guess how many coins are inside. Assume that we are able to determine the weight of the pig exactly and that we know the weights of all coins of a given currency. Then there is some minimum amount of money in the piggy-bank that we can guarantee. Your task is to find out this worst case and determine the minimum amount of cash inside the piggy-bank. We need your help. No more prematurely broken pigs! 输入格式The input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers E and F. They indicate the weight of an empty pig and of the pig filled with coins. Both weights are given in grams. No pig will weigh more than 10 kg, that means 1 &lt;= E &lt;= F &lt;= 10000. On the second line of each test case, there is an integer number N (1 &lt;= N &lt;= 500) that gives the number of various coins used in the given currency. Following this are exactly N lines, each specifying one coin type. These lines contain two integers each, Pand W (1 &lt;= P &lt;= 50000, 1 &lt;= W &lt;=10000). P is the value of the coin in monetary units, W is it’s weight in grams. 输出格式Print exactly one line of output for each test case. The line must contain the sentence “The minimum amount of money in the piggy-bank is X.” where X is the minimum amount of money that can be achieved using coins with the given total weight. If the weight cannot be reached exactly, print a line “This is impossible.”. 样例输入12345678910111213310 11021 130 5010 11021 150 301 6210 320 4 样例输出123The minimum amount of money in the piggy-bank is 60.The minimum amount of money in the piggy-bank is 100.This is impossible. 来源Central Europe 1999 题解代码12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int e,F,s;int n;int p[10001],w[10001];int f[10001];const int inf=0x3f3f3f3f;int main()&#123; scanf("%d%d",&amp;e,&amp;F); s=F-e; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d",&amp;p[i],&amp;w[i]); f[i]=inf; &#125; f[0]=0; for(int i=1;i&lt;=s;i++)f[i]=inf; for(int i=1;i&lt;=n;i++)&#123; for(int v=w[i];v&lt;=s;v++)&#123; f[v]=min(f[v],f[v-w[i]]+p[i]); &#125; &#125; if(f[s]==inf)printf("This is impossible."); else printf("The minimum amount of money in the piggy-bank is %d.",f[s]); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>背包</category>
      </categories>
      <tags>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HAOI2006]受欢迎的牛]]></title>
    <url>%2F2018%2F06%2F21%2F%5BHAOI2006%5D%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E7%89%9B%2F</url>
    <content type="text"><![CDATA[题目题目描述每一头牛的愿望就是变成一头最受欢迎的牛。现在有N头牛，给你M对整数(A,B)，表示牛A认为牛B受欢迎。 这种关系是具有传递性的，如果A认为B受欢迎，B认为C受欢迎，那么牛A也认为牛C受欢迎。你的任务是求出有多少头牛被所有的牛认为是受欢迎的。 输入第一行两个数N,M。 接下来M行，每行两个数A,B，意思是A认为B是受欢迎的（给出的信息有可能重复，即有可能出现多个A,B） 输出一个数，即有多少头牛被所有的牛认为是受欢迎的。 样例输入12343 31 22 12 3 样例输出11 提示100%的数据N&lt;=10000,M&lt;=50000 题解虽然网上有不少题解，但我觉得还是自己写下，毕竟题解这东西首先是写给自己的。 缩点 分析假如你已经完全搞懂了tarjan的话可以直接看这里。当我们把所有的强连通分量分别合并到一个点里（每次标记出栈的点，这些点就在同一个强连通分量里），不难发现，统计每一个点的出度，如果有1个点出度为0，那么这个点里的所有牛就是最受欢迎的了，其他情况则没有最受欢迎的牛，如图： tarjan算法tarjan算法用来寻找有向图的强连通分量的算法，它可以在$ O(|V|+|E|) $ 的时间内得出结果。下面内容大部分来源于这篇文章。 为了更好地理解tarjan算法是如何通过dfs来求强连通分量的，我们这里不妨先了解下搜索树。比如这是一个有向图： 而他的搜索树长这样： 从图中我们可以看到3种边（实际上有4种，但是其实第四种只要和第一种一样处理就可以了） 1.实线画出来的是树边，每次搜索找到一个还没有访问过的结点的时候就形成了一条树边。2.用长虚线画出来的是反祖边，也被叫做回边,它主要是在搜索的时候遇到了一个已经访问过的结点，而且这个结点是当前节点的祖先时形成的。3.用短虚线画出来的是横叉边，它主要是在搜索的时候遇到了一个已经访问过的结点，但是这个结点不是当前节点的祖先时形成的。 现在我们来看看在 DFS 的过程中强连通分量有什么性质。 很重要的一点是如果结点 u 是某个强连通分量在搜索树中遇到的第一个结点（这通常被称为这个强连通分量的根），那么这个强连通分量的其余结点肯定是在搜索树中以 u 为根的子树中。如果有个结点 v 在该强连通分量中但是不在以 u 为根的子树中，那么 u 到 v 的路径中肯定有一条离开子树的边。但是这样的边只可能是横叉边或者反祖边，然而这两条边都要求指向的结点已经被访问过了，这就和 u 是第一个访问的结点矛盾了。 Tarjan 算法主要是在 DFS 的过程中维护了一些信息：dfn、low 和一个栈。 栈里的元素表示的是当前已经访问过但是没有被归类到任一强连通分量的结点。 dfn[u] 表示结点 u 在 DFS 中第一次搜索到的次序，通常被叫做时间戳。 low[u] 稍微有些复杂，它表示从 u 或者以 u 为根的子树中的结点，再通过一条反祖边或者横叉边可以到达的时间戳最小的结点 v 的时间戳，并且要求 v 有一些额外的性质：v 还要能够到达 u。显然通过反祖边到达的结点 v 满足 low 的性质，但是通过横叉边到达的却不一定。可以证明，结点 u 是某个强连通分量的根等价于 dfn[u] 和 low[u] 相等。简单可以理解成当它们相等的时候就不可能从 u 通过子树再经过其它时间戳比它小的结点回到 u。 当通过 u 搜索到一个新节点 v 的时候可以有多种情况： $ 1° $ 结点 u 通过树边到达结点 v$$ low[u]=min(low[u],low[v]) $$ $ 2° $ 结点 u 通过反祖边到达结点 v，或者通过横叉边到达结点 v 并且满足 low 定义中 v 的性质$$ low[u]=min(low[u],dfn[v]) $$ 如果 dfn 和 low 相等，那么就不断退栈直到当前结点为止，这些结点就属于一个强连通分量。 至于如何更新 low，关键就在于第二种情况，当通过反祖边或者横叉边走到一个结点的时候，只需要判断这个结点是否在栈中，如果在就用它的 low 值更新当前节点的 low 值，否则就不更新。因为如果不在栈中这个结点就已经确定在某个强连通分量中了，不可能回到 u。 附：链式前向星代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;#define MAXN 50001int E[MAXN],low[MAXN],Next[MAXN],Head[MAXN],dfn[MAXN],num=0,count,out[MAXN],o,how_many[MAXN],chudu[MAXN],zhan[MAXN],top=0;bool v[MAXN],chuzhan[MAXN];void add(int x,int y,int i)&#123; E[i]=y; Next[i]=Head[x]; Head[x]=i;&#125;int find()&#123; int ans=0; for(int i=1;i&lt;=o;i++)&#123; for(int p=Head[out[i]];p;p=Next[p])&#123; if(!chuzhan[E[p]])&#123; ans++; &#125; &#125; &#125; return ans;&#125;void tarjan(int u)&#123; dfn[u]=low[u]=++num; zhan[++top]=u; v[u]=1; for(int p=Head[u];p;p=Next[p])&#123; int y=E[p]; if(!dfn[y])&#123; tarjan(y); low[u]=min(low[y],low[u]); &#125;else&#123; if(v[y])low[u]=min(low[u],dfn[y]); &#125; &#125; if(dfn[u]==low[u])&#123; int y; count++; do&#123; y=zhan[top--]; v[y]=0; out[++o]=y; chuzhan[y]=1; how_many[count]++; &#125;while(y!=u); chudu[count]=find(); o=0; memset(chuzhan,0,sizeof(chuzhan)); &#125;&#125;int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); add(x,y,i); &#125; for(int i=1;i&lt;=n;i++)&#123; if(!dfn[i])tarjan(i); &#125; int c=0,ans; for(int i=1;i&lt;=count;i++)&#123; if(!chudu[i])c++,ans=i; &#125; if(c==1)cout&lt;&lt;how_many[ans]; else cout&lt;&lt;"0"; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>图的连通</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2820]局域网]]></title>
    <url>%2F2018%2F06%2F17%2F%5B%E6%B4%9B%E8%B0%B7P2820%5D%E5%B1%80%E5%9F%9F%E7%BD%91%2F</url>
    <content type="text"><![CDATA[题目题目背景某个局域网内有n(n&lt;=100)台计算机，由于搭建局域网时工作人员的疏忽，现在局域网内的连接形成了回路，我们知道如果局域网形成回路那么数据将不停的在回路内传输，造成网络卡的现象。因为连接计算机的网线本身不同，所以有一些连线不是很畅通，我们用f(i,j)表示i,j之间连接的畅通程度，f(i,j)值越小表示i,j之间连接越通畅，f(i,j)为0表示i,j之间无网线连接。 题目描述需要解决回路问题，我们将除去一些连线，使得网络中没有回路，并且被除去网线的Σf(i,j)最大，请求出这个最大值。 输入格式第一行两个正整数n k接下来的k行每行三个正整数i j m表示i,j两台计算机之间有网线联通，通畅程度为m。 输出格式一个正整数，Σf(i,j)的最大值。 输入样例1234565 51 2 81 3 11 5 32 4 53 4 2 输出样例18 说明f(i,j)&lt;=1000 题解这里可以采用存边的方法存储图，再用克鲁斯卡尔按边求出最小生成树，把这些边标记起来，再把没有标记过的相加，这样做的好处是避免数据溢出（当然你也可以开长整型） 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;struct Tedge&#123; int from; int to; int num;&#125;edge[10001];int father[101];//并查集bool Ebook[10001];int n,k,ans;int find(int x)&#123; if(x==father[x])return x; return find(father[x]);//这里一定要有return&#125;void solve()&#123; for(int i=1;i&lt;=k;i++)&#123; int f1,f2; f1=find(edge[i].from); f2=find(edge[i].to); if(f1!=f2)&#123; father[f1]=f2; Ebook[i]=1; &#125; &#125;&#125;bool cmp(Tedge a,Tedge b)&#123; return a.num&lt;b.num;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++)father[i]=i; for(int i=1;i&lt;=k;i++)&#123; scanf("%d %d %d",&amp;edge[i].from,&amp;edge[i].to,&amp;edge[i].num); &#125; sort(edge+1,edge+k+1,cmp);//求最小生成树，边由小到大 solve(); for(int i=1;i&lt;=k;i++)if(Ebook[i]==0)ans+=edge[i].num; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1908]逆序对]]></title>
    <url>%2F2018%2F06%2F17%2F%5B%E6%B4%9B%E8%B0%B7P1908%5D%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[题目题目描述猫猫TOM和小老鼠JERRY最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。最近，TOM老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中ai&gt;aj且i&lt;j的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。 输入格式第一行，一个数n，表示序列中有n个数。第二行n个数，表示给定的序列。 输出格式给定序列中逆序对的数目。 输入样例1265 4 2 6 3 1 输出样例111 说明对于50%的数据，n≤2500对于100%的数据，n≤40000。 题解树状数组既然名字都叫树状数组，那么肯定是和数有关的咯，我们来先看一个二叉树 我们来稍微变下形 现在我们把树状数组c[]摆放到每一列的顶端 C[i]代表子树的叶子结点的权值之和我们通过这张图可以知道$$ C[1]=A[1]; $$$$ C[2]=A[1]+A[2]; $$$$ C[3]=A[3]; $$$$ C[4]=A[1]+A[2]+A[3]+A[4]; $$$$ C[5]=A[5]; $$$$ C[6]=A[5]+A[6]; $$$$ C[7]=A[7]; $$$$ C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8]; $$通过分情况讨论好像是有什么规律，那有没有更一般的规律呢？我们不妨将树状数组的编号转换成二进制看看$$ 1=(001)—C[1]=A[1]; $$$$ 2=(010)—C[2]=A[1]+A[2]; $$$$ 3=(011)—C[3]=A[3]; $$$$ 4=(100)—C[4]=A[1]+A[2]+A[3]+A[4]; $$$$ 5=(101)—C[5]=A[5]; $$$$ 6=(110)—C[6]=A[5]+A[6]; $$$$ 7=(111)—C[7]=A[7]; $$$$ 8=(1000)—C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8]; $$ 对照式子可以发现 C[i]=A[i-2^k+1]+A[i-2^k+2]+……A[i]; （k为i的二进制中从最低位到高位连续零的长度）例如i=8时，k=3。 而lowbit(x)函数的作用就是取出x的最低位。 树状数组的优点在于单点更新以及区间查询，对于求逆序对来说，知道一个数的位置x，那么1~x范围内就是比它小的数，而用已经插入的数的个数减去这个数，累加起来就是我们要算的逆序对数。 离散化上面提到我们要知道一个数的位置，可以用树状数组下标来表示$ c[x] $，但整型范围很大,不可能开这么大的数组，所以我们只需要保留它们的相对大小，用离散化处理。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define MAXN 100001using namespace std;int n;struct node&#123; int num,index;&#125;a[MAXN];int c[MAXN];//树状数组int A[MAXN];//离散化后的数组int low_bit(int i)&#123; return i&amp;(-i);&#125;void update(int i,int v)//插入&#123; while(i&lt;=n)&#123; c[i]+=v; i+=low_bit(i); &#125;&#125;int get_sum(int i)//区间查找&#123; int res=0; while(i)&#123; res+=c[i]; i-=low_bit(i); &#125; return res;&#125;bool cmp(node a,node b) &#123; return a.num&lt;b.num; &#125; int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i].num); a[i].index=i; &#125; sort(a+1,a+1+n,cmp); int p=0; for(int i=1;i&lt;=n;i++)&#123; /*if(a[i].num!=a[i-1].num)p++; A[a[i].index]=p;*///如果数据中存在重复数据才需要 A[a[i].index]=i;//离散化 &#125; long long ans=0; for(int i=1;i&lt;=n;i++)&#123; update(A[i],1);//插入 ans+=i-get_sum(A[i]); &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POJ-3264] Balanced Lineup]]></title>
    <url>%2F2018%2F06%2F16%2F%5BPOJ-3264%5D%20Balanced%20Lineup%2F</url>
    <content type="text"><![CDATA[注：数据改编自原题，输入输出略有不同 题目题目描述For the daily milking, Farmer John’s N cows (1 ≤ N ≤ 50,000) always line up in the same order. One day Farmer John decides to organize a game of Ultimate Frisbee with some of the cows. To keep things simple, he will take a contiguous range of cows from the milking lineup to play the game. However, for all the cows to have fun they should not differ too much in height. Farmer John has made a list of Q (1 ≤ Q ≤ 200,000) potential groups of cows and their heights (1 ≤ height ≤ 1,000,000). For each group, he wants your help to determine the difference in height between the shortest and the tallest cow in the group. 输入Line 1: Two space-separated integers, N and Q.Lines 2..N+1: Line i+1 contains a single integer that is the height of cow iLines N+2..N+Q+1: Two integers A and B (1 ≤ A ≤ B ≤ N), representing the range of cows from A to B inclusive. 输出Lines 1..Q: Each line contains a single integer that is a response to a reply and indicates the difference in height between the tallest and shortest cow in the range. 样例输入123456789106 31734251 54 62 2 样例输出123630 题解代码1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;#define MAXN 50001int n,q;int stmin[MAXN][20];int stmax[MAXN][20];void pre_work()&#123; for(int j = 1; j &lt; 20; ++j) for(int i = 1; i &lt;= n; ++i) if(i + (1 &lt;&lt; j) - 1 &lt;= n)&#123; stmax[i][j] = max(stmax[i][j-1], stmax[i + (1 &lt;&lt; (j - 1))][j - 1]); stmin[i][j] = min(stmin[i][j-1], stmin[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++)&#123; scanf("%d", &amp;stmin[i][0]); stmax[i][0]=stmin[i][0]; &#125; pre_work(); for(int i=1;i&lt;=q;i++)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); int k=(int)(log(y - x + 1.0) / log(2.0)); int maxsum = max(stmax[x][k], stmax[y - (1 &lt;&lt; k) + 1][k]); int minsum = min(stmin[x][k], stmin[y - (1 &lt;&lt; k) + 1][k]); printf("%d\n",maxsum-minsum); &#125; return 0;&#125; 线段树代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;#define MAXN 50001int n,q;struct Ttree&#123; int maxdata,mindata;&#125;t[MAXN*4],tmp0;void push_up(int l,int r,int k)&#123; t[k].maxdata=max(t[k*2].maxdata,t[k*2+1].maxdata); t[k].mindata=min(t[k*2].mindata,t[k*2+1].mindata);&#125;void make(int l,int r,int k)&#123; if(l==r)&#123; scanf("%d",&amp;t[k].maxdata); t[k].mindata=t[k].maxdata; return; &#125; int mid=(l+r)/2; make(l,mid,k*2); make(mid+1,r,k*2+1); push_up(l,r,k); return;&#125;Ttree ask(int L,int R,int l,int r,int k)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)return t[k]; int mid=(l+r)/2; Ttree res1; if(L&lt;=mid)res1=ask(L,R,l,mid,k*2); else res1=tmp0; Ttree res2; if(R&gt;mid)res2=ask(L,R,mid+1,r,k*2+1); else res2=tmp0; Ttree res=&#123;0&#125;; res.maxdata=max(res1.maxdata,res2.maxdata); res.mindata=min(res1.mindata,res2.mindata); return res;&#125;int main()&#123; tmp0.maxdata=-1e9,tmp0.mindata=1e9; scanf("%d%d",&amp;n,&amp;q); make(1,n,1); for(int i=1;i&lt;=q;i++)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); Ttree ans; ans=ask(x,y,1,n,1); printf("%d\n",ans.maxdata-ans.mindata); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Spoj GSS3]Can you answer these queries III]]></title>
    <url>%2F2018%2F06%2F15%2F%5BSpoj%20GSS3%5DCan%20you%20answer%20these%20queries%20III%2F</url>
    <content type="text"><![CDATA[题目题目描述给定长度为N的数列A，以及M条指令 (N≤500000, M≤100000)，每条指令可能是以下两种之一：“2 x y”，把 A[x] 改成 y。“1 x y”，查询区间 [x,y] 中的最大连续子段和，即 max(x≤l≤r≤y)⁡ { ∑(i=l~r) A[i] }。对于每个询问，输出一个整数表示答案。 输入第一行两个整数N,M 第二行N个整数Ai 接下来M行每行3个整数k,x,y，k=1表示查询（此时如果x&gt;y，请交换x,y），k=2表示修改 输出对于每个询问输出一个整数表示答案。 样例输入123455 31 2 -3 4 51 2 32 2 -11 3 2 样例输出122-1 提示数据范围与约定 对于100%的数据: N≤500000, M≤100000, |Ai|&lt;=1000 题解树存储空间大小这道题与原题略微有点区别，数据输入顺序不一样，以及范围更大了，但是稍微改一下就可以过了。第一个问题，为什么树要开到4*N？首先，我们构造的线段树有可能是完全二叉树（最好情况），叶子节点存储的就是我们每一个点的数据，而我们可以分析下完全二叉树的图。不难发现，我们设节点有n个，那么二叉树的层数为$ log_2(n+1) $而设叶子节点有k个，那么就得到一个k与n的关系：$ k(1-(1/2)^n)=2n $n随k的变化关系曲线为当k趋于无穷大，$ n=2k $ 而对于最坏情况，请参见这篇文章对于最坏的情况我们要开4n的空间来存储。 树存储方式第二个问题，我们要存树，这里可以开一个结构体，里面有四个变量| 变量名称 | 变量作用 ||-|:-:|-|| data | 储存该区间内的最大连续子段和 || ldata | 储存该区间从左端开始的最大和 || rdata | 储存该区间从右端开始的最大和 || sum | 储存该区间内的所有数的和 |这些就够了，不必纪录左子树和右子树。 建树对于每个叶子节点（r==l），我们给他们赋值，而其他节点我们就需要来分析情况了。 sum的值sum的值还用说吗，就是左子树的sum+右子树的sum data的值data是该区间内的最大连续子段和，所以对于data就有几种可能，而我们要做的就是取最大的：1.data=左子树data2.data=右子树data3.data=左子树rdata+右子树ldata ldata和rdata的值ldata储存该区间从左端开始的最大和，所以：1.ldata=左子树ldata2.ldata=左子树sum+右子树rdatardata同理 改变值改变值其实就是建树，只不过因为只改变一个值，所以分治时要么是左子树，要么是右子树，改变完后要注意重新维护其他点的值。 查询值查询值较为复杂，但我们也可以把它看成一个建树的过程。首先，对于我们要查询的范围，如果这个范围大于等于我们分治下去的范围，那么就返回这个范围的值。（实际上就是我们建树时存在这个范围的点）如果这个范围没有点满足，那么我们可以用叶子节点建树来建成我们想要的范围的点。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;#define MAXN 500000struct Ttree&#123; int data; int ldata,rdata; int sum; &#125;t[MAXN*4],tmp0;int n,m;void push_up(int l,int r,int k)&#123; t[k].sum=t[k*2].sum+t[k*2+1].sum; t[k].data=max(t[k*2].data,t[k*2+1].data); t[k].data=max(t[k*2].rdata+t[k*2+1].ldata,t[k].data); t[k].ldata=max(t[k*2].ldata,t[k*2].sum+t[k*2+1].ldata); t[k].rdata=max(t[k*2+1].rdata,t[k*2+1].sum+t[k*2].rdata); return;&#125;void make(int l,int r,int k)&#123; if(l==r)&#123; scanf("%d",&amp;t[k].data); t[k].ldata=t[k].rdata=t[k].sum=t[k].data; return; &#125; int mid=(l+r)/2; make(l,mid,k*2); make(mid+1,r,k*2+1); push_up(l,r,k); return;&#125;Ttree ask(int L,int R,int l,int r,int k)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)return t[k]; int mid=(l+r)/2; Ttree res1; if(L&lt;=mid)res1=ask(L,R,l,mid,k*2); else res1=tmp0;/*目前分治的点的左子树不包含要查询的左端范围，不参与建树，tmp0初始化很小，在取最大值的时候含有它的情况会被忽略掉，但是tmp0.sum初始化还是0*/ Ttree res2; if(R&gt;mid)res2=ask(L,R,mid+1,r,k*2+1); else res2=tmp0;//同理 Ttree res=&#123;0&#125;; res.sum=res1.sum+res2.sum; res.data=max(res1.data,res2.data); res.data=max(res1.rdata+res2.ldata,res.data); res.ldata=max(res1.ldata,res1.sum+res2.ldata); res.rdata=max(res2.rdata,res2.sum+res1.rdata); return res;&#125;void change(int x,int y,int l,int r,int k)&#123; if(l==r)&#123; t[k].data=y; t[k].ldata=t[k].rdata=t[k].sum=t[k].data; return; &#125; int mid=(r+l)/2; if(x&lt;=mid)change(x,y,l,mid,k*2); else change(x,y,mid+1,r,k*2+1); push_up(l,r,k); return;&#125;int main()&#123; tmp0.data=tmp0.ldata=tmp0.rdata=-1e9; scanf("%d%d",&amp;n,&amp;m); make(1,n,1); for(int i=1;i&lt;=m;i++)&#123; int k,x,y; scanf("%d%d%d",&amp;k,&amp;x,&amp;y); if(k==1)&#123; if(x&gt;y)swap(x,y); printf("%d\n",ask(x,y,1,n,1).data); &#125;else&#123; change(x,y,1,n,1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>区间求和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六度空间]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[题目题目描述“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如下图所示。六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。 假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。 输入格式输入第1行给出两个正整数，分别表示社交网络图的结点数N（1&lt;N≤10000，表示人数）、边数M（≤33×N，表示社交关系数）。随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到N编号）。 输出格式对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。 输入样例1234567891010 91 22 33 44 55 66 77 88 99 10 输出样例123456789101: 70.00%2: 80.00%3: 90.00%4: 100.00%5: 100.00%6: 100.00%7: 100.00%8: 90.00%9: 80.00%10: 70.00% 题解简单的一道图的遍历题，这里我用的是bfs（感觉这道题用bfs更简单），超过6次就跳出，这里有一个重点就是如何在队列里判断一轮结束，具体看代码。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;#define MAXN 10001bool a[MAXN][MAXN];//这里可以扣一点开个boolbool visited[MAXN];//用来标记访问过的点，注意重置int n,m;int bfs(int v)&#123; int que[MAXN]; int head=1,tail=1; int step=1,last=v;//last存放上一个点访问的最后一个点 int tmp; int count; visited[v]=1; count=1; que[tail++]=v; while(head&lt;tail)&#123; int out=que[head++];//出队元素 for(int i=1;i&lt;=n;i++)&#123; if(visited[i])continue; if(a[out][i])&#123; visited[i]=1; que[tail++]=i; count++; tmp=i;//不断更新，最后访问的点被tmp存到 &#125; &#125; if(out==last)&#123;//如果出队元素等于上个点最后访问的点 step++;//说明这一轮结束，step++，last更新为tmp last=tmp; &#125; if(step==7)break; &#125; return count;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); a[x][y]=a[y][x]=1;//无向图 &#125; for(int i=1;i&lt;=n;i++)&#123;//从每个点开始 memset(visited,0,sizeof(visited));//每次要重置visited double ratio; ratio=bfs(i)*1.0/n*100; printf("%d: %.2f%%\n",i,ratio);//用%%转义字符输出% &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>图的连通</category>
      </categories>
      <tags>
        <tag>bfs</tag>
        <tag>邻接矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[YZOJ1370]无聊的锤锤]]></title>
    <url>%2F2018%2F06%2F09%2F%5BYZOJ1370%5D%E6%97%A0%E8%81%8A%E7%9A%84%E9%94%A4%E9%94%A4%2F</url>
    <content type="text"><![CDATA[题目题目描述罗宏明（白客），1988年7月9日出生于中国山东省泰安市，中国内地新生代男演员，毕业于中国传媒大学南广学院。原先是配音员，《搞笑漫画日和》配音团队cucn201的主要成员之一。2013年因出演导演叫兽易小星的搞笑网剧《万万没想到》中的男一号“王大锤”，从而备受关注。 这么火的搞笑剧中，大家是否注意到这样一个剧情(没看过也没关系的)：王大锤要回家过年，上司不让，无奈之下，王大锤就发挥了自己的聪明才智，决定和上司玩个游戏，想着锤锤是个数学白痴，上司欣然答应，胜了就让他回家。游戏是这样的,开始时，白板上有两个不等的整数，他们轮流行动，每次行动必须在白板上写出任意两个已在白板上出现的整数的差且非负，而且这个数字必须是新的，谁再也写不出来就输了。 为了彰显上司魅力，上司让锤锤先开始。上司足够聪明，当然王大锤也不笨，不然会这么火吗？如果你事先知道白板上的数字，聪明的你能推理出王大锤能否回家呢？ 输入测试数据有多组，每组有两个整数，即白板上最初的数字，数据保证在int范围内。 输出每组测试数据输出一行，锤锤能回家就输出“1”，不能输出“0”。 样例输入125 34 8 样例输出1210 题解一开始还打算用暴力，写到一般就打消了这个念头。其实显而易见的是，对于正整数n,m来说,这两个数相减可以得出的所有数x,则 代码12345678910111213141516171819#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int gcd(int a,int b)&#123; return b==0?a:gcd(b,a%b);&#125;int main()&#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)!=EOF)&#123; int num=gcd(n,m); int c1=n/num;//看它最多能写几个数 int c2=m/num; if(c1&gt;c2)printf("%d\n",c1%2); else printf("%d\n",c2%2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>最小公倍数与最大公因数</category>
      </categories>
      <tags>
        <tag>欧几里得算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F09%2FHello%20World%2F</url>
    <content type="text"><![CDATA[123456#include &lt;stdio.h&gt;int main()&#123; printf(&quot;Hello, World!&quot;); return 0;&#125;]]></content>
  </entry>
</search>
